#Azure Service Bus

Независимо от того, работают ли приложение или служба в облаке или локально, они часто должны взаимодействовать с другими приложениями или службами. Для этого платформа Azure предлагает служебную шину. В данной статье приводится обзор, описание и сценарии использования этой технологии.

## Базовая информация о Service Bus
В разных ситуациях требуются разные способы взаимодействия. Иногда лучшим решением является обмен сообщениями между приложениями через простую очередь. В других ситуациях обычной очереди недостаточно и лучше использовать очередь с механизмом публикации и подписки. В некоторых случаях необходимо лишь соединение между приложениями, а очередь не требуется. Service Bus предлагает все три варианта, позволяя приложениям взаимодействовать несколькими способами.

Service Bus — это мультитенантная облачная служба, т. е. служба, совместно используемая несколькими пользователями. Каждый пользователь, например, разработчик приложений, создает *пространство имен* и определяет механизмы взаимодействия, которые должны использоваться в нем. [Рисунок 1](#Fig1) демонстрирует, как это выглядит.

<a name="Fig1"></a>![Схема служебной шины Azure][svc-bus]
 
**Рис. 1. Служебная шина предоставляет мультитенантную службу для связи приложений через облако.**

В рамках пространства имен можно использовать один или несколько экземпляров четырех механизмов взаимодействия, по-разному связывающих приложения. Возможны следующие варианты.

- *Очереди*, которые поддерживают однонаправленное взаимодействие. Каждая очередь действует как посредник (иногда называемый *брокером*), который хранит отправленные сообщения, пока они не будут получены. Каждое сообщение получает один получатель.
- *Разделы*, которые поддерживают однонаправленное взаимодействие с использованием *подписок*. В одном разделе может быть несколько подписок. Подобно очереди, раздел действует как посредник, но каждая подписка может при необходимости применить фильтр, чтобы получать только те сообщения, которые соответствуют определенным условиям.
- *Ретрансляторы*, которые обеспечивают двунаправленное взаимодействие. В отличие от очередей и разделов, ретранслятор не хранит передаваемые сообщения, так как не является посредником. Он просто передает сообщения целевым приложениям.
- *Концентраторы событий*, которые обеспечивают передачу входящих данных событий и телеметрии в облако с массовым масштабированием, низкой задержкой и высокой надежностью.

При создании очереди, раздела, ретранслятора или концентратора событий задается имя. В комбинации с именем пространства имен это имя создает уникальный идентификатор объекта. Приложения могут передать это имя службе Service Bus, а затем использовать соответствующие очередь, раздел, ретранслятор или центр уведомлений для взаимодействия с другими приложениями.

Приложения Windows могут использовать эти объекты с помощью Windows Communication Foundation (WCF). Для очередей, разделов и концентраторов событий приложения для Windows также могут использовать интерфейсы Messaging API, определенные службой Service Bus. Чтобы упростить использование этих объектов из приложений сторонних разработчиков, Майкрософт предлагает пакеты SDK для Java, Node.js и других языков. К очередям, разделам и концентраторам событий также можно получить доступ с помощью REST API через HTTP.

Важно понимать, что хотя служебная шина и работает в облаке (т. е. в центрах обработки данных Microsoft Azure), использующие ее приложения могут работать где угодно. С помощью служебной шины можно связать приложения, выполняемые, например, в Azure и в локальном центре обработки данных. Эту службу также можно использовать для связи приложения, работающего в Azure или на другой облачной платформе, с локальным приложением или с планшетами и телефонами. Можно даже связывать бытовые приборы, датчики и другие устройства с центральным приложением или друг с другом. Service Bus — это универсальный механизм взаимодействия в облаке, доступный практически везде. Способ ее использования зависит от целей приложения.


## Очереди

Предположим, вам необходимо связать два приложения с помощью очереди служебной шины. Эта ситуация показана на [рисунке 2](#Fig2).

<a name="Fig2"></a>![Схема очередей Service Bus][queues]
 
**Рис. 2. Очереди служебной шины обеспечивают однонаправленное асинхронное взаимодействие.**

Процесс прост: отправитель отправляет сообщение в очередь Service Bus, а получатель извлекает это сообщение позднее. У очереди может быть только один получатель, как показано на [рисунке 2](#Fig2), или же несколько приложений могут считывать сообщения из одной очереди. В последнем случае каждое сообщение считывается только одним получателем. Для многоадресного обслуживания лучше использовать разделы.

Каждое сообщение состоит из двух частей: набора свойств (пар ключ/значение) и двоичного тела сообщения. Способ их использования зависит от целей приложения. Например, приложение, отправляющее сообщение о недавней продаже, может включить в него свойства *Seller="Ava"* and *Amount=10000*. Тело сообщения может содержать отсканированное изображение подписанного контракта или может остаться пустым.

Получатель может считать сообщение из очереди Service Bus двумя способами. Первый способ, *ReceiveAndDelete*, извлекает сообщение из очереди и сразу удаляет его. Это простой способ, но если у получателя произойдет сбой до того, как он завершит обработку сообщения, оно будет потеряно. Поскольку сообщение было удалено из очереди, другие получатели не смогут прочитать его.

Второй способ, *PeekLock*, направлен на решение этой проблемы. Как и ReceiveAndDelete, PeekLock извлекает сообщение из очереди. Однако он не удаляет сообщение. Вместо этого он блокирует сообщение, делая его невидимым для других получателей, а затем ожидает одно из трех событий:

- если получатель успешно обрабатывает сообщение, вызывается функция *Complete* и очередь удаляет сообщение; 
- если получатель не может обработать сообщение, вызывается функция *Abandon*; очередь разблокирует сообщение и делает его доступным для других получателей;
- Если получатель не вызывает ни одну из этих функций в течение заданного периода времени (по умолчанию 60 секунд), очередь считает, что получателю не удалось обработать сообщение. В этом случае очередь делает сообщение доступным для других получателей, как при вызове функции "Отменить".

Обратите внимание, что может произойти: одно и то же сообщение может быть доставлено дважды, возможно, двум разным получателям. Приложения, использующие очереди Service Bus, должны быть готовы к этому. Чтобы упростить удаление дубликатов, каждое сообщение имеет уникальное свойство MessageID, которое по умолчанию не изменяется, независимо от того, сколько раз сообщение считывается из очереди.

Очереди полезны во многих ситуациях. Они позволяют приложениям взаимодействовать, даже если эти приложения работают не одновременно. Это особенно удобно в случае пакетных и мобильных приложений. Очередь с несколькими получателями обеспечивает автоматическую балансировку нагрузки, так как отправленные сообщения распределяются между получателями.


## Разделы

Хотя очереди удобны, они не всегда являются правильным выбором. Иногда лучше использовать разделы Service Bus. [На рисунке 3](#Fig3) показан принцип работы разделов.

<a name="Fig3"></a>![Схема разделов и подписок Service Bus][topics-subs]
 
**Рис. 3. Подписанное приложение определяет фильтр, на основании которого оно может получать некоторые или все сообщения, отправленные в раздел служебной шины.**

Разделы во многом похожи на очереди. Отправители отправляют сообщения в раздел так же, как в очередь, и эти сообщения выглядят в разделе так же, как в очереди. Существенное отличие заключается в том, что разделы позволяют каждому принимающему приложению создать собственную подписку, определив *фильтр*. Подписчик будет видеть только те сообщения, которые соответствуют фильтру. Например, [на рисунке 3](#Fig3) показан отправитель и раздел с тремя подписчиками, у каждого из которых имеется собственный фильтр:

- Подписчик 1 получает только сообщения, содержащие свойство *Seller="Ava"*.
- Подписчик 2 получает сообщения, содержащие свойства *Seller="Ruby"* и *Amount* со значением больше 100 000. Возможно, Ruby — это продавец, который хочет видеть собственные продажи и крупные продажи независимо от того, кто их осуществил.
- Подписчик 3 задал для фильтра значение *True*, которое означает, что он получает все сообщения. Это приложение может, к примеру, вести журнал аудита, и поэтому ему нужен доступ ко всем сообщениям.

Как и в случае очередей, подписчики раздела могут считывать сообщения с помощью методов ReceiveAndDelete или PeekLock. Однако в отличие от очередей, сообщение, отправленное в раздел, может быть получено несколькими подписчиками. Такой подход, обычно называемый *публикация и подписка*, используется, когда несколько приложений могут быть заинтересованы в одних и тех же сообщениях. Правильно определив фильтр, каждый подписчик может получить доступ лишь к той части потока сообщений, которая ему необходима.


## Ретрансляторы

Очереди и разделы обеспечивают однонаправленное асинхронное взаимодействие через посредника. Трафик протекает только в одном направлении, и между отправителями и получателями нет прямой связи. Но что делать, если требуется другой механизм? Предположим, что вашим приложениям нужно и отправлять и получать сообщения, или необходима прямая связь между приложениями, а посредник для хранения сообщений не требуется. Для выполнения таких сценариев служебная шина предлагает ретрансляторы, схема которых показана на [рис. 4](#Fig4).

<a name="Fig4"></a>![Схема ретранслятора Service Bus][relay]
 
**Рис. 4. Ретранслятор служебной шины обеспечивает синхронное двунаправленное взаимодействие между приложениями.**

В каких случаях используются ретрансляторы? Даже если очереди не нужны, почему бы приложениям не взаимодействовать не через облачную службу, а напрямую? Дело в том, что организовать прямой обмен сообщениями сложнее, чем кажется.

Предположим, нужно связать два локальных приложения, которые выполняются в корпоративных центрах обработки данных. Каждое из этих приложений находится за брандмауэром, а центры обработки данных могут использовать преобразование сетевых адресов (NAT). Брандмауэр блокирует входящие данные на всех портах кроме нескольких, а вследствие действия NAT компьютеры, на которых работают приложения, не имеют фиксированных IP-адресов, к которым можно получить непосредственный доступ за пределами центра обработки данных. Без дополнительных средств эти приложения непросто связать через общедоступный Интернет.

Таким средством может быть ретранслятор Service Bus. Для двунаправленного взаимодействия через ретранслятор каждое приложение устанавливает исходящее TCP-соединение с Service Bus и держит его открытым. Весь обмен данными между двумя приложениями будет проходить через эти соединения. Так как каждое соединение установлено из центра обработки данных, брандмауэр разрешит входящий трафик для каждого приложения без открытия новых портов. Этот подход также решает проблему NAT, так как каждое приложение имеет постоянную конечную точку в облаке на протяжении всего обмена данными. Обмениваясь данными через ретранслятор, приложения могут избежать проблем, которые в противном случае осложнили бы взаимодействие.

Приложения могут использовать ретрансляторы Service Bus с помощью Windows Communication Foundation (WCF). Service Bus предоставляет привязки WCF, которые упрощают взаимодействие приложений Windows через ретрансляторы. Приложения, которые уже используют WCF, могут просто указать одну из этих привязок и обмениваться данными через ретранслятор. В отличие от очередей и разделов, использование ретрансляторов из приложений, работающих не под управлением Windows, хотя и возможно, но требует дополнительных усилий программистов; стандартные библиотеки не предусмотрены.

В отличие от очередей и разделов, приложения не создают ретрансляторы явно. Когда приложение, которое собирается получать сообщения, устанавливает TCP-соединение с Service Bus, ретранслятор создается автоматически. Когда соединение разрывается, ретранслятор удаляется. Чтобы приложение могло найти ретранслятор, созданный конкретным прослушивателем, Service Bus предоставляет реестр, который позволяет приложениям найти конкретный ретранслятор по имени.

Ретрансляторы являются оптимальным решением, когда требуется прямое взаимодействие между приложениями. Например, система бронирования авиабилетов, работающая в локальном центре обработки данных, к которой должен осуществляться доступ из киосков регистрации, с мобильных устройств и с других компьютеров. Приложения, работающие во всех этих системах, могут взаимодействовать через ретрансляторы Service Bus в облаке, где бы они ни находились.

## Концентраторы событий

Концентратор событий — это высокомасштабируемая приемная система, которая может обрабатывать миллионы событий в секунду, позволяя приложению обрабатывать и анализировать огромное количество данных, создаваемых подключенными устройствами и приложениями. Концентратор событий можно использовать, к примеру, для сбора данных о производительности двигателя в режиме реального времени из множества автомобилей. После сбора данных в концентраторах событий их можно преобразовать и сохранить с помощью любого поставщика аналитики в реальном времени или в кластере хранилища. Дополнительную информацию о концентраторах событий см. в разделе [Обзор концентраторов событий][].

## Сводка

Подключение приложений всегда было частью создания полноценных решений. Диапазон сценариев, для которых требуется взаимодействие между приложениями и службами, будет расти по мере подключения все большего количества приложений и устройств к Интернету. При предоставлении облачных технологий с помощью очередей, разделов, ретрансляторов и концентраторов событий используется Service Bus, которая упрощает эту важную функцию и делает ее более доступной.

[svc-bus]: ./media/hybrid-solutions/SvcBus_01_architecture.png
[queues]: ./media/hybrid-solutions/SvcBus_02_queues.png
[topics-subs]: ./media/hybrid-solutions/SvcBus_03_topicsandsubscriptions.png
[relay]: ./media/hybrid-solutions/SvcBus_04_relay.png
[Обзор концентраторов событий]: https://msdn.microsoft.com/library/azure/dn836025.aspx

<!---HONumber=August15_HO6-->