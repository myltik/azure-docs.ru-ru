---
title: Уникальные ключи в Azure Cosmos DB | Документация Майкрософт
description: Узнайте, как использовать уникальные ключи в базе данных Azure Cosmos DB.
services: cosmos-db
keywords: ограничение уникального ключа, нарушение ограничения уникального ключа
author: rafats
manager: jhubbard
editor: monicar
documentationcenter: ''
ms.assetid: b15d5041-22dd-491e-a8d5-a3d18fa6517d
ms.service: cosmos-db
ms.workload: data-services
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 03/21/2018
ms.author: rafats
ms.openlocfilehash: 0c80ee13298c2c749c5f7eb7e55d1d77a8d6a34e
ms.sourcegitcommit: 48ab1b6526ce290316b9da4d18de00c77526a541
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/23/2018
---
# <a name="unique-keys-in-azure-cosmos-db"></a>Уникальные ключи в Azure Cosmos DB

Уникальные ключи предоставляют разработчикам возможность добавить слой целостности данных в базу данных. Создавая политику уникальных ключей при создании контейнера, вы гарантируете уникальность одного или нескольких значений [ключа секции](partition-data.md). После создания контейнера с политикой уникальных ключей он предотвращает создание любых новых или обновленных элементов со значениями, которые дублируют значения, заданные с помощью уникального ограничения ключа.   

> [!NOTE]
> Уникальные ключи поддерживаются последними версиями пакетов SDK SQL для [.NET](sql-api-sdk-dotnet.md) и [.NET Core](sql-api-sdk-dotnet-core.md), а также [API MongoDB](mongodb-feature-support.md#unique-indexes). API таблицы и API Graph в текущее время не поддерживают уникальные ключи. 
> 
>

## <a name="use-case"></a>Вариант использования 

Например, рассмотрим как пользовательская база данных, связанная с приложением [социальных сетей](use-cases.md#web-and-mobile-applications), может получить преимущества от политики уникальных ключей для адресов электронной почты. Сделав адрес электронной почты пользователя уникальным ключом, убедитесь, что каждая запись имеет уникальный адрес электронной почты и что невозможно создать запись с дублирующимся адресом электронной почты. 

Если нужно, чтобы пользователи могли для создавать нескольких записей с одним адресом электронной почты, но не с тем же именем, фамилией и адресом электронной почты, можно добавить другие пути для политики уникальных ключей. Поэтому вместо создания уникального ключа, который просто основан на адресе электронной почты, можно создать уникальный ключ, который представляет собой комбинацию имени, фамилии и электронной почты. В этом случае каждая уникальная комбинация из трех путей разрешена, поэтому база данных может содержать элементы, которые имеют следующие значения пути. Каждая из этих записей передала бы политику уникальных ключей.  

**Допустимые значения для уникального ключа столбцов firstName, lastName и адрес электронной почты**

|Имя|Фамилия|Адрес электронной почты|
|---|---|---|
|Гэби|Дюперре|gaby@contoso.com |
|Гэби|Дюперре|gaby@fabrikam.com|
|Иван|Дюперре|gaby@fabrikam.com|
|    |Дюперре|gaby@fabrikam.com|
|    |       |gaby@fabraikam.com|

При попытке вставить другую запись с любым сочетанием, которые перечислены в приведенной выше таблице, вы получите сообщение об ошибке, указывающее, что ограничение уникального ключа не выполнено. Azure Cosmos DB возвращается ошибку "Ресурс с указанными идентификатором или именем уже существует" или "Ресурс с определенным идентификатором, именем или уникальным индексом уже существует". 

## <a name="using-unique-keys"></a>Использование уникальных ключей

Уникальные ключи должны быть определены при создании контейнера, а уникальный ключ привязан к ключу секции. Чтобы использовать предыдущий пример, если секция основана на почтовом индексе, можно получить записи из таблицы, которые дублируются в каждой секции.

Имеющиеся контейнеры нельзя обновить для использования уникальных ключей.

После создания контейнера с политикой уникальных ключей политику можно изменить только при повторном создании контейнера. При наличии данных, в которых нужно реализовать уникальные ключи, создайте контейнер и используйте соответствующее средство миграции данных, чтобы перенести данные в новый контейнер. Для контейнеров SQL используйте [средство миграции данных](import-data.md). Для контейнеров MongoDB используйте [mongoimport.exe или mongorestore.exe](mongodb-migrate.md).

В каждый уникальный ключ можно включить до 16 значений путей (например, /firstName, /lastName, /address/zipCode и т. д.) 

Каждая политика уникальных ключей может иметь не более 10 ограничений уникальных ключей или сочетаний. А комбинированные пути для всех свойств уникальных индексов не должны содержать более 60 символов. Таким образом пример выше, который использует имя, фамилию и адрес электронной почты, является только одним ограничением и использует три из 16 возможных путей. 

Затраты единиц запросов для создания, обновления и удаления элемента значительно выше при наличии в контейнере политики уникальных ключей. 

Разреженные уникальные ключи не поддерживаются. Если значения для некоторых уникальных путей отсутствуют, они рассматриваются как имеющие специальное значение null, которое принимает участие в ограничении уникальности.

## <a name="sql-api-sample"></a>Пример API SQL

В следующем примере кода показано, как создать новый контейнер SQL с двумя ограничениями уникального ключа. Первое ограничение — это ограничение по firstName, lastName, адресу электронной почты, описанное в примере выше. Второе ограничение — это адрес или почтовый индекс пользователей. Пример файла JSON, который использует пути в этой политике уникальных ключей, следует примеру кода. 

```csharp
// Create a collection with two separate UniqueKeys, one compound key for /firstName, /lastName,
// and /email, and another for /address/zipCode.
private static async Task CreateCollectionIfNotExistsAsync(string dataBase, string collection)
{
    try
    {
        await client.ReadDocumentCollectionAsync(UriFactory.CreateDocumentCollectionUri(dataBase, collection));
    }
    catch (DocumentClientException e)
    {
        if (e.StatusCode == System.Net.HttpStatusCode.NotFound)
        {
            DocumentCollection myCollection = new DocumentCollection();
            myCollection.Id = collection;
            myCollection.PartitionKey.Paths.Add("/pk");
            myCollection.UniqueKeyPolicy = new UniqueKeyPolicy
            {
                UniqueKeys =
                new Collection<UniqueKey>
                {
                    new UniqueKey { Paths = new Collection<string> { "/firstName" , "/lastName" , "/email" }}
                    new UniqueKey { Paths = new Collection<string> { "/address/zipCode" } },

                }
            };
            await client.CreateDocumentCollectionAsync(
                UriFactory.CreateDatabaseUri(dataBase),
                myCollection,
                new RequestOptions { OfferThroughput = 2500 });
        }
        else
        {
            throw;
        }
    }
```

Пример документа JSON.

```json
{
    "id": "1",
    "firstName": "Gaby",
    "lastName": "Duperre",
    "email": "gaby@contoso.com",
    "address": [
        {            
            "line1": "100 Some Street",
            "line2": "Unit 1",
            "city": "Seattle",
            "state": "WA",
            "zipCode": 98012
        }
    ],
}
```
## <a name="mongodb-api-sample"></a>Пример API MongoDB

В следующем примере команды показано, как создать уникальный индекс для полей firstName, lastName и электронной почты коллекции пользователей для MongoDB API. Это гарантирует уникальность комбинации во всех трех полях во всех документах в коллекции. Для коллекций API MongoDB уникальный индекс создается после создания коллекции, но перед ее заполнением.

```
db.users.createIndex( { firstName: 1, lastName: 1, email: 1 }, { unique: true } )
```

## <a name="next-steps"></a>Дополнительная информация

В этой статье вы узнали, как создавать уникальные ключи для элементов в базе данных. При создании контейнера в первый раз ознакомьтесь со статьей о [секционировании данных в Azure Cosmos DB](partition-data.md), чтобы узнать, как уникальные ключи и ключи секций зависят друг от друга. 


