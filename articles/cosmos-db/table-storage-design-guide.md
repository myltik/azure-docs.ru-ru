---
title: Руководство по разработке хранилищ таблиц Azure | Документация Майкрософт
description: Разработка масштабируемых и высокопроизводительных таблиц в табличном хранилище Azure
services: cosmos-db
documentationcenter: na
author: SnehaGunda
manager: kfile
ms.assetid: 8e228b0c-2998-4462-8101-9f16517393ca
ms.service: cosmos-db
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: data-services
ms.date: 11/03/2017
ms.author: sngun
ms.openlocfilehash: 667fef855238b2524c05bbc2f137d466c0e56de8
ms.sourcegitcommit: 9cdd83256b82e664bd36991d78f87ea1e56827cd
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/16/2018
---
# <a name="azure-storage-table-design-guide-designing-scalable-and-performant-tables"></a>Руководство по разработке табличных хранилищ Azure: разработка масштабируемых и высокопроизводительных таблиц
[!INCLUDE [storage-table-cosmos-db-tip-include](../../includes/storage-table-cosmos-db-tip-include.md)]

При разработке масштабируемых и высокопроизводительных таблиц необходимо учитывать ряд факторов, таких как эффективность, масштабируемость и затраты. Если вы уже занимались созданием схем для реляционных баз данных, эти рекомендации будут вам известны. Однако несмотря на некоторое сходство между моделью хранения службы таблиц Azure и реляционными моделями, необходимо также отметить множество важных различий. Как правило, эти различия приводят к созданию совершенно разных вариантов, которые могут показаться пользователям, знакомым с реляционными базами данных, алогичными или неверными. Но если разработка выполняется для хранилища NoSQL типа "ключ-значение", например службы таблиц Azure, эти различия будут иметь смысл. Многие из них будут отражать тот факт, что служба таблиц предназначена для поддержки масштабирования облачных приложений, содержащих миллиарды сущностей ("строк" в терминологии реляционных баз данных) данных, или для наборов данных, которые должны поддерживать значительные объемы транзакций. Поэтому необходимо по-новому взглянуть на способы хранения данных и понять, как работает служба таблиц. Решение, в котором используется правильно спроектированное хранилище данных NoSQL, имеет все перспективы для значительного масштабирования (при более низких затратах), по сравнению с решением на основе реляционной базы данных. Данное руководство поможет решить эти задачи.  

## <a name="about-the-azure-table-service"></a>Информация о службе таблиц Azure
В этом разделе представлены некоторые ключевые функции службы таблиц, имеющие особое значение в процессе разработки производительных и масштабируемых компонентов. Если вы работаете со службой хранилища Microsoft Azure и службой таблиц впервые, прежде чем прочесть оставшуюся часть этой статьи, ознакомьтесь со следующими ресурсами: [Введение в хранилище Microsoft Azure](../storage/common/storage-introduction.md) и [Приступая к работе с хранилищем таблиц Azure с помощью .NET](table-storage-how-to-use-dotnet.md). Несмотря на то, что основной акцент в руководстве сделан на службе таблиц, здесь будут рассматриваться некоторые вопросы, имеющие отношение к службам очередей и больших двоичных объектов Azure и их использовании в решении вместе со службой таблиц.  

Что такое служба таблиц? Как видно из названия, служба таблиц использует табличный формат для хранения данных. Согласно стандартной терминологии каждая строка таблицы представляет сущность, а различные свойства этой сущности хранятся в столбцах. Каждая сущность имеет пару ключей для своего однозначного определения, а также столбец отметки времени, используемых службой таблиц для отслеживания времени последнего обновления сущности (это происходит автоматически, поэтому перезаписать отметку времени произвольным значением нельзя). Служба таблиц применяет отметку времени последнего изменения (LMT) для управления оптимистическим параллелизмом.  

> [!NOTE]
> Операции API-интерфейса REST службы таблиц также возвращают значение **ETag** , являющееся производным от отметки времени последнего изменения (LMT). В этом документе термины «ETag» и «LMT» будут использоваться на взаимозаменяемой основе, поскольку они относятся к одним и тем же базовым данным.  
> 
> 

В следующем примере показана простая схема таблицы для хранения сущностей сотрудников и отделов. Подобную структуру имеет большинство таблиц, приведенных далее в этом руководстве.  

<table>
<tr>
<th>PartitionKey</th>
<th>RowKey</th>
<th>Timestamp</th>
<th></th>
</tr>
<tr>
<td>Marketing</td>
<td>00001</td>
<td>2014-08-22T00:50:32Z</td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td>Don</td>
<td>Hall</td>
<td>34</td>
<td>donh@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td>Marketing</td>
<td>00002</td>
<td>2014-08-22T00:50:34Z</td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td>Jun</td>
<td>Cao</td>
<td>47</td>
<td>junc@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td>Marketing</td>
<td>Department</td>
<td>2014-08-22T00:50:30Z</td>
<td>
<table>
<tr>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td>Marketing</td>
<td>153</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>Sales</td>
<td>00010</td>
<td>2014-08-22T00:50:44Z</td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td>Ken</td>
<td>Kwok</td>
<td>23</td>
<td>kenk@contoso.com</td>
</tr>
</table>
</td>
</tr>
</table>


Итак, эта таблица очень похожа на таблицу в реляционной базе данных. Главными отличиями являются обязательные для заполнения столбцы, а также возможность хранения в одной таблице нескольких типов сущностей. Кроме того, все определенные пользователями свойства, например **FirstName** или **Age**, имеют такой тип данных, как целое или строка, аналогично столбцам в реляционной базе данных. В отличие от традиционных реляционных баз данных табличное хранилище имеет бессхемную конструкцию. Это значит, что свойства могут относиться к разным типам. Для хранения сложных типов данных в одном свойстве необходимо использовать сериализованный формат, например JSON или XML. Дополнительные сведения о службе таблиц, например о поддерживаемых типах данных, поддерживаемых диапазонах дат, правилах именования и ограничений по размерам, см. в статье [Understanding the Table Service Data Model](http://msdn.microsoft.com/library/azure/dd179338.aspx) (Общие сведения о модели данных службы таблиц).

Как вы сможете убедиться позднее, основой для разработки эффективной таблицы является выбор свойств **PartitionKey** и **RowKey**. Каждая сущность, хранящаяся в таблице, должна иметь уникальное сочетание значений **PartitionKey** и **RowKey**. Как и в случае с ключами в таблице реляционной базы данных, значения **PartitionKey** и **RowKey** индексируются для создания кластеризованного индекса, обеспечивающего быстрое выполнение операций поиска. Однако служба таблиц не поддерживает вторичные индексы, поэтому они — единственные два индексированных свойства (как обойти это ограничение, вы узнаете, изучив некоторые приведенные далее шаблоны).  

Таблица состоит из одного или нескольких разделов. Как вы сами увидите, большая часть принимаемых проектных решений будет связана с выбором подходящих свойств **PartitionKey** и **RowKey** для оптимизации решения. В решение может входить только одна таблица, в которой все сущности упорядочены по разделам. Однако обычно решение будет состоять из нескольких таблиц. Таблицы позволяют логически организовать сущности, они упрощают управление доступом к данным с помощью списков контроля доступа, а для их удаления достаточно выполнить одну операцию хранения.  

### <a name="table-partitions"></a>Разделы таблицы
Имя учетной записи, имя таблицы и свойство **PartitionKey**, вместе взятые, определяют раздел в службе хранилища, где служба таблиц хранит сущность. Так как разделы являются частью схемы адресации для сущностей, они определяют область действия транзакций (см. раздел [Транзакции группы сущностей](#entity-group-transactions) ниже) и формируют основу варианта масштабирования таблицы. Дополнительные сведения о разделах см. в статье [Целевые показатели масштабируемости и производительности службы хранилища Azure](../storage/common/storage-scalability-targets.md).  

В службе таблиц отдельный узел обслуживает один или несколько полных разделов, а масштабирование службы осуществляется за счет динамического распределения нагрузки разделов между узлами. Если узел находится под нагрузкой, служба таблиц может *разделить* диапазон разделов, обслуживаемых этим узлом, на отдельные узлы. При уменьшении объема трафика служба может *объединить* диапазоны разделов с незагруженных узлов в один узел.  

Дополнительные сведения о внутренних подробностях службы таблиц и, в частности, информацию об управлении разделами см. в статье [Хранилище Azure: доступная служба облачного хранения со строгой согласованностью](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx).  

### <a name="entity-group-transactions"></a>Транзакции группы сущностей
В службе таблиц транзакции группы сущностей (EGT) являются единственным встроенным механизмом для выполнения атомарных обновлений в нескольких сущностях. В некоторых документах транзакции группы сущностей называются *пакетными транзакциями* . Эти транзакции поддерживаются только для сущностей, хранящихся в одном разделе (имеющих общий ключ раздела в данной таблице), поэтому каждый раз, когда в нескольких сущностях требуется провести атомарные транзакции, необходимо убедиться, что эти сущности находятся в одном разделе. Именно этот момент часто является основанием для хранения нескольких типов сущностей в одной таблице (и разделе) и отказа от использования нескольких таблиц для разных типов сущностей. Одна транзакция группы сущностей может работать с максимум 100 сущностей.  При отправке сразу нескольких EGT для обработки важно убедиться в том, что эти EGT не работают с сущностями, которые являются общими между EGT, в противном случае обработка может быть отложена.

Кроме того, применение транзакций группы сущностей приводит к необходимости сопоставить преимущества и недостатки и сделать компромиссный выбор при разработке: использование дополнительных разделов будет способствовать повышению масштабируемости приложения, так как Azure предоставляет множество вариантов для балансировки нагрузки запросов между узлами. Но это может ограничить возможности приложения по выполнению атомарных транзакций и обеспечению высокого уровня согласованности данных. Кроме того, следует принять во внимание наличие определенных целевых показателей масштабируемости на уровне раздела, которые могут ограничивать ожидаемую пропускную способность для транзакций на одном узле. Дополнительные сведения о целевых показателях масштабируемости для учетных записей хранения Azure и службы таблиц см. в статье [Целевые показатели масштабируемости и производительности службы хранилища Azure](../storage/common/storage-scalability-targets.md). В последующих разделах данного руководства рассматриваются различные стратегии разработки, упрощающие управление подобными компромиссными решениями, а также описываются оптимальные варианты выбора ключа раздела с учетом конкретных требований клиентского приложения.  

### <a name="capacity-considerations"></a>Рекомендации по емкости
В следующей таблице перечислены некоторые ключевые значения, которые следует учитывать при разработке решения для службы таблиц.  

| Общая емкость учетной записи хранения Azure | 500 TБ |
| --- | --- |
| Количество таблиц в учетной записи хранения Azure |Ограничено только емкостью учетной записи хранения |
| Количество разделов в таблице |Ограничено только емкостью учетной записи хранения |
| Количество сущностей в разделе |Ограничено только емкостью учетной записи хранения |
| Размер отдельной сущности |До 1 МБ с максимум 255 свойствами (включая свойства **PartitionKey**, **RowKey** и **Timestamp**) |
| Размер свойства **PartitionKey** |Строка размером до 1 кБ. |
| Размер свойства **RowKey** |Строка размером до 1 кБ. |
| Размер транзакции группы сущностей |Транзакция может содержать не более 100 сущностей, а объем полезных данных не должен превышать 4 МБ. Транзакция группы сущностей может обновлять сущность только один раз. |

Дополнительные сведения см. в статье [Understanding the Table Service Data Model](http://msdn.microsoft.com/library/azure/dd179338.aspx) (Общие сведения о модели данных службы таблиц).  

### <a name="cost-considerations"></a>Рекомендации по стоимости
Табличное хранилище является относительно недорогой системой хранения данных. Однако в рамках оценки любого решения, в котором развернута служба таблиц, необходимо провести расчет затрат как на использование емкостей, так и на количество транзакций. Во многих сценариях хранение денормализованных или повторяющихся данных для повышения производительности или масштабируемости решения является вполне правомерным подходом. Дополнительные сведения о ценах см. на странице [Цены на хранилища Azure](https://azure.microsoft.com/pricing/details/storage/).  

## <a name="guidelines-for-table-design"></a>Рекомендации по разработке таблиц
В этих списках обобщены некоторые ключевые рекомендации, которые следует учитывать при разработке таблиц. Более подробно они будут рассматриваться в руководстве немного позднее. Эти рекомендации значительно отличаются от тех, которым необходимо следовать при разработке для реляционных баз данных.  

Разработка эффективного для *чтения* решения для службы таблиц:

* ***Разрабатывайте решения с учетом выполнения запросов в приложениях с большим количеством операций чтения.*** При проектировании таблиц сначала необходимо сосредоточиться на запросах (особенно на чувствительных к задержкам), которые будут выполняться, а затем уделить внимание вариантам обновления сущностей. Это позволит создать эффективное и высокопроизводительное решение.  
* ***Указывайте свойства PartitionKey и RowKey в запросах.*** *Точечные запросы* , подобные им, — самые эффективные запросы службы таблиц.  
* ***Рассмотрите возможность хранения повторяющихся копий сущностей.*** Хранилище таблиц является недорогим в использовании, поэтому в целях создания более эффективных запросов рекомендуется сохранять одни и те же сущности несколько раз (с разными ключами).  
* ***Рассмотрите возможность денормализации данных.*** Хранилище таблиц не требует больших затрат поэтому рассмотрите возможность денормализации данных. Например, храните сущности сводки, чтобы запросы к объединенным данным обращались только к одной сущности.  
* ***Используйте значения составного ключа.*** Доступны только ключи **PartitionKey** и **RowKey**. Например, значения составного ключа можно использовать для включения альтернативных путей доступа с ключами к сущностям.  
* ***Используйте проекции в запросах.*** С помощью запросов, выбирающих только необходимые поля, можно сократить объем данных, передаваемых по сети.  

Разработка эффективного для *записи* решения для службы таблиц:  

* ***Не создавайте разделы с высокой нагрузкой.*** Выбирайте ключи, которые позволяют распределять запросы по нескольким разделам в любой момент времени.  
* ***Избегайте пиковых нагрузок по трафику.*** Обеспечьте выравнивание трафика в течение разумного периода времени и избегайте пиковых нагрузок по трафику.
* ***Для каждого типа сущности не требуется создавать отдельную таблицу.*** Чтобы выполнять атомарные транзакции с типами сущностей, эти несколько типов сущностей можно хранить в одном разделе одной таблицы.
* ***Рассмотрите требуемую максимальную пропускную способность.*** Необходимо иметь в виду целевые показатели масштабируемости для службы таблиц и обеспечить их соблюдение.  

При чтении данного руководства вы увидите примеры, которые демонстрируют практическую реализацию всех этих принципов.  

## <a name="design-for-querying"></a>Разработка для запросов
в решениях службы таблиц может быть связана с большим количеством операций чтения, записи или сочетания этих двух видов нагрузки. В этом разделе рассматриваются вопросы, которые необходимо иметь в виду при разработке службы таблиц для эффективной поддержки операций чтения. Как правило, схема, поддерживающая операции чтения, также эффективна для операций записи. Тем не менее, при реализации поддержки операций записи следует придерживаться дополнительных рекомендаций, которые приводятся в следующем разделе [Разработка для изменения данных](#design-for-data-modification).

Хорошей отправной точкой для разработки решения службы таблиц с эффективным чтением данных является вопрос о том, какие запросы потребуется выполнить приложению для получения необходимых данных из службы таблиц.  

> [!NOTE]
> Для службы таблиц очень важно правильно заранее спроектировать решение, поскольку его последующие изменения связаны с реализацией трудных и дорогостоящих процессов. Например, чтобы устранить проблемы с производительностью в реляционной базе данных, можно просто добавить индексы в существующую базу данных. Но этот вариант неприемлем для службы таблиц.  
> 
> 

В этом разделе рассматриваются основные вопросы, которые необходимо учитывать при проектировании таблиц для выполнения запросов. В этом разделе затрагиваются следующие темы.

* [Влияние выбора свойств PartitionKey и RowKey на производительность запросов](#how-your-choice-of-partitionkey-and-rowkey-impacts-query-performance)
* [Выбор соответствующего свойства PartitionKey](#choosing-an-appropriate-partitionkey)
* [Оптимизация запросов для службы таблиц](#optimizing-queries-for-the-table-service)
* [Сортировка данных в службе таблиц](#sorting-data-in-the-table-service)

### <a name="how-your-choice-of-partitionkey-and-rowkey-impacts-query-performance"></a>Влияние выбора свойств PartitionKey и RowKey на производительность запросов
В следующих примерах предполагается, что сущности сотрудников хранятся в службе таблиц согласно приведенной далее структуре (для большей ясности во многих примерах свойство **Timestamp** опущено).  

| *Имя столбца* | *Тип данных* |
| --- | --- |
| **PartitionKey** (Название отдела) |Строка |
| **RowKey** (ИД сотрудника) |Строка |
| **FirstName** |Строка |
| **LastName** |Строка |
| **Age** |Целое число  |
| **EmailAddress** |Строка |

В разделе [Информация о службе таблиц Azure](#overview) описываются некоторые ключевые особенности службы таблиц Azure, оказывающие прямое влияние на процесс разработки запросов. С их учетом были сформулированы следующие общие рекомендации по разработке запросов службы таблиц. Обратите внимание, что синтаксис фильтрации, используемый в приведенных ниже примерах, взят из REST API службы таблиц. Дополнительные сведения см. в статье о [сущностях запроса](http://msdn.microsoft.com/library/azure/dd179421.aspx).  

* ***Точечный запрос*** представляет собой самый эффективный вариант поиска и рекомендуется к использованию при крупномасштабном поиске или поиске, требующем минимальной задержки. Для эффективного поиска отдельных сущностей в таком запросе можно использовать индексы и указать значения **PartitionKey** и **RowKey**. Например: $filter=(PartitionKey eq 'Sales') and (RowKey eq '2')  
* Вторым по эффективности можно назвать ***запрос диапазона***, который использует свойство **PartitionKey** и выполняет фильтрацию в диапазоне значений **RowKey** для возврата нескольких сущностей. Значение **PartitionKey** определяет конкретный раздел, а значения **RowKey** определяют подмножество сущностей в этом разделе. Например: $filter=PartitionKey eq 'Sales' and RowKey ge 'S' and RowKey lt 'T'  
* Третьим по эффективности является ***просмотр разделов*** с использованием свойства **PartitionKey** и фильтрации по другому неключевому свойству. Этот тип поиска может возвращать несколько сущностей. Значение **PartitionKey** определяет конкретный раздел и значения свойств, выбранные для подмножества сущностей в этом разделе. Например: $filter=PartitionKey eq 'Sales' and LastName eq 'Smith'  
* Тип поиска ***просмотр таблицы*** не использует свойство **PartitionKey** и является очень неэффективным, так как поиск совпадающих сущностей выполняется по всем разделам таблицы. Просмотр таблицы будет осуществляться независимо от того, использует фильтр свойство **RowKey**или нет. Например: $filter=LastName eq 'Jones'  
* Запросы, возвращающие несколько сущностей, возвращают их отсортированными по свойствам **PartitionKey** и **RowKey**. Чтобы избежать повторной сортировки сущностей в клиенте, выберите свойство **RowKey**, которое определяет самый распространенный порядок сортировки.  

Обратите внимание, что использование **or** для указания фильтра на основе **RowKey** приведет к запуску просмотра раздела и не будет обрабатываться как запрос диапазона. Поэтому следует избегать запросов, использующих следующие фильтры: $filter=PartitionKey eq 'Sales' and (RowKey eq '121' or RowKey eq '322').  

Примеры кода на стороне клиента с использованием клиентской библиотеки хранилища для выполнения запросов см. в следующих разделах.  

* [Выполнение запроса точки с помощью клиентской библиотеки хранилища](#executing-a-point-query-using-the-storage-client-library)
* [Извлечение нескольких сущностей с помощью LINQ](#retrieving-multiple-entities-using-linq)
* [Проекция на стороне сервера](#server-side-projection)  

Примеры кода на стороне клиента, который может обрабатывать несколько типов сущностей, хранящихся в одной таблице, см. в следующем разделе:  

* [Работа с разными типами сущностей](#working-with-heterogeneous-entity-types)  

### <a name="choosing-an-appropriate-partitionkey"></a>Выбор соответствующего свойства PartitionKey
Выбранное свойство **PartitionKey** должно сбалансировать необходимость использования транзакций группы сущностей (для обеспечения согласованности) и требование к распределению сущностей по нескольким разделам (для построения масштабируемого решения).  

С одной стороны, все сущности можно хранить в одном разделе, но это может ограничить масштабируемость решения, а служба таблиц не сможет балансировать нагрузку запросов. С другой стороны, в каждом разделе можно хранить одну сущность, что обеспечит значительную масштабируемость решения и распределение нагрузки запросов, но не позволит использовать транзакции группы сущностей.  

Идеальное свойство **PartitionKey** позволяет применять эффективные запросы и располагает достаточным количеством разделов для обеспечения масштабируемости решения. Вы поймете, что сущности имеют соответствующее свойство, которое распределяет их по необходимому количеству разделов.

> [!NOTE]
> Например, в системе, где хранятся сведения о пользователях или сотрудниках, идентификатор пользователя (UserID) может быть выражен подходящим значением PartitionKey. Использовать тот или иной идентификатор пользователя (UserID) в качестве ключа раздела могут сразу несколько сущностей. Все сущности, в которых хранятся данные о пользователе, группируются в один раздел. В результате все операции с этими сущностями выполняются через транзакции группы сущностей, но масштабируемость остается высокой.
> 
> 

При выборе свойства **PartitionKey** необходимо учесть ряд дополнительных аспектов, которые имеют отношение к операциям вставки, обновления и удаления сущностей. Дополнительные сведения см. в разделе [Разработка для изменения данных](#design-for-data-modification) ниже.  

### <a name="optimizing-queries-for-the-table-service"></a>Оптимизация запросов для службы таблиц
Служба таблиц автоматически индексирует сущности с помощью значений **PartitionKey** и **RowKey** в одном кластеризованном индексе. Именно поэтому точечные запросы самые эффективные. Однако не существует индексов, отличных от кластеризованного индекса, использующего значения **PartitionKey** и **RowKey**.

Многие разработки должны соответствовать требованиям по включению поиска сущностей на основании нескольких условий. Например, поиск сущностей сотрудников на основе адреса электронной почты, ИД сотрудника или фамилии. Следующие шаблоны в разделе [Шаблоны для разработки таблиц](#table-design-patterns) обеспечивают соответствие этим типам требований и описывают способы работы с тем фактом, что в службе таблиц отсутствуют вторичные индексы.  

* [Шаблон вторичного индекса внутри раздела](#intra-partition-secondary-index-pattern) — хранение нескольких копий каждой сущности с помощью различных значений **RowKey** (в одном разделе) для выполнения быстрых и эффективных операций поиска и активации альтернативных порядков сортировки с помощью различных значений **RowKey**.  
* [Шаблон вторичного индекса в разных разделах](#inter-partition-secondary-index-pattern) — хранение нескольких копий каждой сущности с помощью различных значений **RowKey** в отдельных разделах или отдельных таблицах для выполнения быстрых и эффективных операций поиска и активации альтернативных порядков сортировки с помощью различных значений **RowKey**.  
* [Шаблон сущностей индекса](#index-entities-pattern) — поддержка сущностей индекса для выполнения эффективных операций поиска, возвращающих списки сущностей.  

### <a name="sorting-data-in-the-table-service"></a>Сортировка данных в службе таблиц
Служба таблиц возвращает сущности, отсортированные по возрастанию сначала на основе **PartitionKey**, а затем на основе **RowKey**. Эти ключи являются строковыми значениями. Чтобы правильно отсортировать числовые значения, их необходимо преобразовать в значения фиксированной длины и заполнить нулями. Например, если значение идентификатора сотрудника, используемое в качестве **RowKey**, является целочисленным значением, ИД сотрудника **123** необходимо преобразовать в **00000123**.  

Многие приложения предъявляют требования к использованию данных, отсортированных в разных порядках. Например, сотрудники могут быть отсортированы по имена или по дате присоединения. Следующие шаблоны в разделе [Шаблоны для разработки таблиц](#table-design-patterns) предназначены для выбора альтернативных порядков сортировки для сущностей.  

* [Шаблон вторичного индекса внутри раздела](#intra-partition-secondary-index-pattern) — хранение нескольких копий каждой сущности с помощью различных значений RowKey (в одном разделе) для выполнения быстрых и эффективных операций поиска и активации альтернативных порядков сортировки с помощью различных значений RowKey.  
* [Шаблон вторичного индекса в разных разделах](#inter-partition-secondary-index-pattern) — хранение нескольких копий каждой сущности с помощью различных значений RowKey в отдельных разделах или отдельных таблицах для выполнения быстрых и эффективных операций поиска и активации альтернативных порядков сортировки с помощью различных значений RowKey.
* [Шаблон для заключительного фрагмента журнала](#log-tail-pattern) — извлечение *n* сущностей, недавно добавленных в раздел, с помощью значения **RowKey** , выполняющего сортировку по дате и времени в обратном порядке.  

## <a name="design-for-data-modification"></a>Разработка для изменения данных
В этом разделе рассматриваются вопросы разработки для оптимизации операций вставки, обновления и удаления. В некоторых случаях будет необходимо тщательно проанализировать модели оптимизации запросов и модели оптимизации изменения данных. Действия выполняются так же, как в модели для реляционных баз данных (несмотря на то, что в реляционной базе данных существуют другие методы управления компромиссами при разработке). В разделе [Шаблоны для разработки таблиц](#table-design-patterns) приводится описание шаблонов разработки для службы таблиц и рассматриваются некоторые компромиссные варианты. На практике вы увидите, что многие модели, оптимизированные для выполнения запросов к сущностям, также хорошо подходят для изменения сущностей.  

### <a name="optimizing-the-performance-of-insert-update-and-delete-operations"></a>Оптимизация производительности операций вставки, обновления и удаления
Чтобы обновить или удалить сущность, ее необходимо определить с помощью значений **PartitionKey** и **RowKey**. В связи с этим при выборе значений **PartitionKey** и **RowKey** для изменения сущностей следует придерживаться тех же условий, которые действуют для поддержки точечных запросов. Это позволит максимально эффективно определять сущности. Следует исключить неэффективный просмотр раздела или таблицы для поиска сущности с целью обнаружения значений **PartitionKey** и **RowKey**, необходимых для ее обновления или удаления.  

Следующие шаблоны в разделе [Шаблоны для разработки таблиц](#table-design-patterns) будут полезны для оптимизации производительности операций вставки, обновления и удаления.  

* [Шаблон для удаления больших объемов сущностей](#high-volume-delete-pattern) — включение операции удаления больших объемов сущностей за счет сохранения всех сущностей для одновременного удаления в отдельной таблице. Удаление сущностей происходит при удалении таблицы.  
* [Шаблон для рядов данных](#data-series-pattern) — хранение целых рядов данных в одной сущности для сокращения количества выполняемых запросов.  
* [Шаблон для масштабных сущностей](#wide-entities-pattern) — использование нескольких физических сущностей для хранения логических сущностей с более чем 252 свойствами.  
* [Шаблон для сущностей больших размеров](#large-entities-pattern) — для хранения больших по объему значений свойств используйте хранилище больших двоичных объектов.  

### <a name="ensuring-consistency-in-your-stored-entities"></a>Обеспечение согласованности хранимых сущностей
Другим фактором, который влияет на выбор ключей для оптимизации изменения данных, является обеспечение согласованности с помощью атомарных операций. Транзакции группы сущностей можно использовать только для работы с сущностями, хранящимися в одном разделе.  

Следующие шаблоны в разделе [Шаблоны для разработки таблиц](#table-design-patterns) предназначены для управления согласованностью.  

* [Шаблон вторичного индекса внутри раздела](#intra-partition-secondary-index-pattern) — хранение нескольких копий каждой сущности с помощью различных значений **RowKey** (в одном разделе) для выполнения быстрых и эффективных операций поиска и активации альтернативных порядков сортировки с помощью различных значений **RowKey**.  
* [Шаблон вторичного индекса в разных разделах](#inter-partition-secondary-index-pattern) — хранение нескольких копий каждой сущности с помощью различных значений RowKey в отдельных разделах или отдельных таблицах для выполнения быстрых и эффективных операций поиска и активации альтернативных порядков сортировки с помощью различных значений **RowKey**.  
* [Шаблон для согласованных транзакций](#eventually-consistent-transactions-pattern) — обеспечение согласованного поведения в рамках границ раздела или границ системы хранения с помощью запросов Azure.
* [Шаблон сущностей индекса](#index-entities-pattern) — поддержка сущностей индекса для выполнения эффективных операций поиска, возвращающих списки сущностей.  
* [Шаблон денормализации](#denormalization-pattern) — объединение связанных данных в одной сущности для извлечения необходимых данных с помощью одного точечного запроса.  
* [Шаблон для рядов данных](#data-series-pattern) — хранение целых рядов данных в одной сущности для сокращения количества выполняемых запросов.  

Сведения о транзакциях группы сущностей см. в разделе [Транзакции группы сущностей](#entity-group-transactions).  

### <a name="ensuring-your-design-for-efficient-modifications-facilitates-efficient-queries"></a>Использование эффективных запросов в разработке для эффективных изменений
Во многих случаях разработка эффективных запросов способствует эффективным изменениям. Однако в каждом конкретном случае всегда следует проверять, так ли это. Некоторые шаблоны в разделе [Шаблоны для разработки таблиц](#table-design-patterns) позволяют явным образом сопоставить выгоды и недостатки процессов создания запросов и изменения сущностей. Вместе с этим всегда необходимо учитывать количество операций каждого типа.  

Следующие шаблоны в разделе [Шаблоны для разработки](#table-design-patterns) таблиц предназначены для определения компромиссных вариантов между разработкой для эффективных запросов и разработкой для эффективного изменения данных.  

* [Шаблон составного ключа](#compound-key-pattern) — использование составных значений **RowKey** для предоставления клиенту возможности выполнять поиск связанных данных с помощью одного точечного запроса.  
* [Шаблон для заключительного фрагмента журнала](#log-tail-pattern) — извлечение *n* сущностей, недавно добавленных в раздел, с помощью значения **RowKey** , выполняющего сортировку по дате и времени в обратном порядке.  

## <a name="encrypting-table-data"></a>Шифрование данных таблицы
Клиентская библиотека хранилища Azure для .NET поддерживает шифрование строковых свойств для операций вставки и замены. Зашифрованные строки хранятся в службе в виде двоичных свойств. Они преобразуются обратно в строки после расшифровки.    

Что касается таблиц, то в дополнение к политике шифрования пользователи должны указать свойства, которые необходимо зашифровать. Это можно сделать путем указания атрибута [PropertyAttribute] \(для сущностей POCO, которые являются производными от TableEntity) или с помощью сопоставителя шифрования в параметрах запроса. Сопоставитель шифрования — это делегат, который получает ключ секции, ключ строки и имя свойства, а затем возвращает логическое значение, которое указывает, следует ли это свойство шифровать. Во время шифрования клиентская библиотека использует эти сведения, чтобы решить, следует ли шифровать свойство перед отправкой. Делегат также обеспечивает возможность логики в отношении того, как шифруются свойства. (Например, если значение равно X, то шифровать свойство А; в противном случае шифровать свойства А и В.) Обратите внимание, что нет необходимости предоставлять эти сведения при чтении или выполнении запросов к сущностям.

Обратите внимание, что слияние в настоящее время не поддерживается. Поскольку подмножество свойств могло уже быть зашифровано с помощью другого ключа, простое слияние новых свойств и обновление метаданных приведет к потере данных. Для слияния требуется либо сначала прочитать данные существующей сущности в службе, либо использовать новый ключ для каждого свойства, однако оба способа не подходят из-за низкой эффективности.     

Дополнительные сведения о шифровании данных таблицы см. в статье [Шифрование на стороне клиента для службы хранилища Microsoft Azure](../storage/common/storage-client-side-encryption.md).  

## <a name="modelling-relationships"></a>Моделирование отношений
Построение модели предметной области является одним из ключевых этапов при разработке комплексных систем. Как правило, процесс моделирования используется для определения сущностей и отношений между ними. Это позволяет понять направление бизнес-деятельности и представить структуру системы. В этом разделе рассматривается процедура преобразования некоторых распространенных типов отношений, присутствующих в моделях предметной области, в схемы для службы таблиц. Процесс сопоставления логической модели данных с физической моделью данных на базе NoSQL существенно отличается от аналогичного процесса, используемого при проектировании реляционной базы данных. При разработке реляционных баз данных обычно предполагается наличие таких компонентов, как оптимизированный процесс нормализации данных для сведения к минимуму избыточности и возможность выполнения декларативных запросов, которая абстрагирует процесс реализации базы данных.  

### <a name="one-to-many-relationships"></a>Отношения «один-ко-многим»
Отношения «один-ко-многим» между бизнес-объектами являются практически самыми распространенными. Например, в одном отделе работает много сотрудников. Существует несколько способов реализации отношений «один-ко-многим» в службе таблиц, каждый со своими преимуществами и недостатками, которые могут иметь определенное значение в конкретном сценарии.  

Рассмотрим пример с крупной международной компанией, имеющей десятки тысяч сущностей отделов и сотрудников, где в каждом отделе работает множество сотрудников, каждый из которых, в свою очередь, связан с одним конкретным отделом. Первый подход заключается в хранении отдельных сущностей отделов и сотрудников, как показано ниже.  

![][1]

В этом примере демонстрируется явное отношение «один-ко-многим» между типами на основе значения **PartitionKey** . В каждом отделе может работать много сотрудников.  

В этом примере также показана сущность отдела и связанные сущности сотрудников в одном разделе. Для разных типов сущностей можно выбрать использование разных разделов, таблиц или даже учетных записей хранилища.  

В качестве альтернативного подхода выступает денормализация данных и хранение только сущностей сотрудников с денормализованными данными отдела, как показано в следующем примере. В данном случае денормализованный подход может оказаться не лучшим вариантом, если присутствуют требования к возможности изменения сведений о руководителе отдела, поскольку для этого придется обновлять каждого сотрудника отдела.  

![][2]

Дополнительные сведения см. в разделе [Шаблон денормализации](#denormalization-pattern).  

В следующей таблице приводятся преимущества и недостатки каждого из описанных выше подходов для хранения сущностей сотрудников и отделов, связанных отношением «один-ко-многим». Следует также учитывать планируемую частоту выполнения различных операций. В некоторых случаях допускается использование схемы с ресурсоемкой операцией, если только эта операция выполняется редко.  

<table>
<tr>
<th>Подход</th>
<th>Преимущества</th>
<th>Недостатки</th>
</tr>
<tr>
<td>Отдельные типы сущностей, один раздел, одна таблица</td>
<td>
<ul>
<li>Сущность отдела можно обновить с помощью одной операции.</li>
<li>Если требуется изменять сущность отдела при каждом обновлении, вставке или удалении сущности сотрудника, в целях обеспечения согласованности можно использовать транзакции группы сущностей. Например, в случае поддержки осведомленности о количестве сотрудников в каждом отделе.</li>
</ul>
</td>
<td>
<ul>
<li>Для некоторых действий на стороне клиента может потребоваться получить сущность как сотрудника, так и отдела.</li>
<li>Операции хранения выполняются в одном разделе. При значительных объемах транзакций это может привести к формированию активной области.</li>
<li>Транзакции группы сущностей нельзя использовать для перемещения сотрудника в другой отдел.</li>
</ul>
</td>
</tr>
<tr>
<td>Отдельные типы сущностей, разные разделы или таблицы, или учетные записи хранилища</td>
<td>
<ul>
<li>Сущность отдела или сущность сотрудника можно обновить с помощью одной операции.</li>
<li>При значительных объемах транзакций это может помочь распределить нагрузку по нескольким разделам.</li>
</ul>
</td>
<td>
<ul>
<li>Для некоторых действий на стороне клиента может потребоваться получить сущность как сотрудника, так и отдела.</li>
<li>Транзакции группы сущностей нельзя использовать для обеспечения согласованности при обновлении, вставке или удалении сотрудника или обновлении отдела. Например, для обновления количества сотрудников в сущности отдела.</li>
<li>Транзакции группы сущностей нельзя использовать для перемещения сотрудника в другой отдел.</li>
</ul>
</td>
</tr>
<tr>
<td>Денормализация в один тип сущности</td>
<td>
<ul>
<li>Все необходимые данные можно извлечь с помощью одного запроса.</li>
</ul>
</td>
<td>
<ul>
<li>Если требуется обновить сведения об отделе (будет необходимо обновить всех сотрудников в отделе), обеспечение согласованности может оказаться ресурсоемким процессом.</li>
</ul>
</td>
</tr>
</table>

Выбор подходящего варианта и определение наиболее значимых преимуществ и недостатков зависит от конкретных сценариев в приложении. Например, как часто выполняется изменение сущностей отдела? Всем ли запросам к сотрудникам требуются дополнительные сведения об отделе? Насколько близко вы подошли к показателям ограничения масштабируемости в разделах или учетной записи хранения?  

### <a name="one-to-one-relationships"></a>Отношения «один-к-одному»
В модель предметной области могут входить отношения между сущностями «один-к-одному». Чтобы реализовать отношение «один-к-одному» в службе таблиц, необходимо выбрать способ привязки двух связанных сущностей, если потребуется извлечь их обе. Эта связь может быть либо неявной (на основе соглашения в значениях ключа), либо явной с сохранением связи в форме значений **PartitionKey** и **RowKey** в каждой сущности. Сведения о необходимости хранения связанных сущностей в одном разделе см. в разделе [Отношения "один-ко-многим"](#one-to-many-relationships).  

Обратите внимание на ряд аспектов, которые могут привести к реализации отношений «один-к-одному» в службе таблиц.  

* Обработка сущностей большого размера (дополнительные сведения см. в статье [Шаблон для сущностей больших размеров](#large-entities-pattern)).  
* Внедрение средств управления доступом (см. раздел [Управление доступом с помощью подписанных URL-адресов](#controlling-access-with-shared-access-signatures)).  

### <a name="join-in-the-client"></a>Присоединение клиента
Несмотря на то, что в службе таблиц существуют возможности моделирования, не следует забывать две основные причины использования службы таблиц — масштабируемость и производительность. Если вы считаете, что моделируете много отношений, которые приводят к ухудшению производительности и масштабируемости решения, стоит подумать о необходимости ввода всех взаимосвязей между данными в структуру таблицы. Необходимые операции присоединения, выполненные клиентским приложением, позволят упростить структуру и улучшить масштабируемость и производительность решения.  

Например, данные, которые содержатся в небольших таблицах и меняются не очень часто, можно извлекать по мере необходимости и кэшировать на стороне клиента. Это позволит избежать повторяющихся циклические операций по извлечению одних и тех же данных. В примерах, рассмотренных в данном руководстве, количество отделов в небольшой организации, вероятно, будет невысоким с нечастыми изменениями. В таком случае оптимален вариант, когда клиентское приложение один раз загружает данные и кэширует их.  

### <a name="inheritance-relationships"></a>Отношения наследования
Если клиентское приложение использует набор классов, которые являются частью наследственной связи для представления бизнес-сущностей, эти сущности можно сохранить в службе таблиц. Например, в клиентском приложении может быть определен следующий набор классов, где класс **Person** является абстрактным.

![][3]

Экземпляры двух конкретных классов можно сохранить в службе таблиц с помощью одной таблицы Person с сущностями, которые выглядят следующим образом.  

![][4]

Дополнительные сведения о работе с несколькими типами сущностей в одной таблице в клиентском коде см. в разделе [Работа с разными типами сущностей](#working-with-heterogeneous-entity-types) далее в этом руководстве. Там приводятся примеры определения типа сущности в клиентском коде.  

## <a name="table-design-patterns"></a>Шаблоны для разработки таблиц
В предыдущих разделах вы подробно изучили вопрос оптимизации структуры таблицы как для извлечения данных сущностей с помощью запросов, так и для выполнения операций по вставке, обновлению и удалению данных сущностей. В этом разделе приводится описание некоторых шаблонов, которые подходят для использования с решениями для службы таблиц. Кроме того, вы увидите практическое решение ряда проблем и сможете выбрать компромиссный вариант. На следующей схеме показаны связи между различными шаблонами.  

![][5]

На схеме шаблонов представлены некоторые связи между шаблонами (синий цвет) и антишаблонами (оранжевый цвет), которые приведены в этом руководстве. Безусловно, существует множество других стоящих внимания шаблонов. Например, один из основных сценариев для службы таблиц — использование [шаблона материализованного представления](https://msdn.microsoft.com/library/azure/dn589782.aspx) из шаблона [Разделение ответственности команд и запросов (CQRS)](https://msdn.microsoft.com/library/azure/jj554200.aspx).  

### <a name="intra-partition-secondary-index-pattern"></a>Шаблон вторичного индекса внутри раздела
Хранение нескольких копий каждой сущности с помощью различных значений **RowKey** (в одном разделе) для выполнения быстрых и эффективных операций поиска и активации альтернативных порядков сортировки с помощью различных значений **RowKey**. Транзакции группы сущностей обеспечивают согласованность обновлений копий.  

#### <a name="context-and-problem"></a>Контекст и проблема
Служба таблиц автоматически индексирует сущности с помощью значений **PartitionKey** и **RowKey**. Это позволяет клиентскому приложению эффективно извлекать сущности с использованием этих значений. Например, используя приведенную ниже структуру таблицы, клиентское приложение может выполнить точечный запрос для извлечения отдельной сущности сотрудника с указанием названия отдела и идентификатора сотрудника (значения **PartitionKey** и **RowKey**). Клиент также может извлекать сущности, отсортированные по ИД сотрудника в каждом отделе.

![][6]

Чтобы найти сущность сотрудника на основе другого свойства (например, адрес электронной почты), необходимо использовать менее эффективную функцию просмотра раздела. Это связано с тем, что служба таблиц не поддерживает вторичные индексы. Кроме того, невозможно запросить список сотрудников, отсортированный в порядке, отличном от **RowKey**.  

#### <a name="solution"></a>Решение
Чтобы решить проблему отсутствия вторичных индексов, можно сохранить несколько копий каждой сущности с каждой копией, используя другое значение **RowKey**. При сохранении сущностей с приведенными ниже структурами можно эффективно извлекать сущности сотрудников на основе адреса электронной почты или ИД сотрудника. Значения префиксов empid_ и email_ для **RowKey** позволяют выполнять запросы на одного сотрудника или ряд сотрудников с помощью диапазона адресов электронной почты или идентификаторов сотрудников.  

![][7]

Следующие два условия фильтрации (одно для поиска по идентификатору сотрудника и второе для поиска по адресу электронной почты сотрудника) задают запросы точек.  

* $filter=(PartitionKey eq 'Sales') and (RowKey eq 'empid_000223')  
* $filter=(PartitionKey eq 'Sales') and (RowKey eq 'email_jonesj@contoso.com')  

Если требуется запросить диапазон сущностей сотрудников, можно указать диапазон, отсортированный по идентификаторам сотрудников или по их адресам электронной почты, выполнив запрос на сущности с соответствующим префиксом в свойстве **RowKey**.  

* Чтобы найти всех сотрудников отдела продаж с идентификатором в диапазоне от 000100 до 000199, используйте следующее условие фильтрации: $filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000100') and (RowKey le 'empid_000199').  
* Чтобы найти всех сотрудников отдела продаж с адресом электронной почты, начинающимся с буквы "a", используйте следующее условие фильтрации: $filter=(PartitionKey eq 'Sales') and (RowKey ge 'email_a') and (RowKey lt 'email_b').  
  
  Обратите внимание, что синтаксис фильтрации, используемый в приведенных выше примерах, взят из REST API службы таблиц. Дополнительные сведения см. в статье о [сущностях запроса](http://msdn.microsoft.com/library/azure/dd179421.aspx).  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Хранилище таблиц является относительно недорогим в использовании, поэтому накладные расходы на хранение повторяющихся данных не являются предметом первостепенной важности. Однако затраты на разработку всегда следует оценивать с учетом требований к планируемому хранилищу и добавлять повторяющиеся сущности только в целях поддержки запросов, которые будет выполнять клиентское приложение.  
* Поскольку сущности вторичного индекса хранятся в одном разделе с исходными сущностями, следует убедиться в том, что целевые показатели масштабируемости для отдельного раздела не превышены.  
* Чтобы обеспечить согласованность повторяющихся сущностей, можно воспользоваться транзакциями группы сущностей (EGT) для автоматического обновления двух копий сущности. Это означает, что все копии сущности необходимо хранить в одном разделе. Дополнительные сведения см. в разделе [Транзакции группы сущностей](#entity-group-transactions).  
* Значение свойства **RowKey** должно быть уникальным для каждой сущности. Рекомендуется использовать значения составного ключа.  
* Заполнение числовых значений в свойстве **RowKey** (например, для идентификатора сотрудника 000223) позволяет правильно выполнять операции сортировки и фильтрации на основе верхних и нижних границ.  
* Дублировать все свойства сущности не требуется. Например, если для запросов, которые ищут сущности по электронному адресу в **RowKey**, не требуется возраст сотрудника, то эти сущности могут иметь следующую структуру:

![][8]

* Рекомендуется сохранить повторяющиеся данные и убедиться в том, что все необходимые данные можно получить с помощью одного запроса, а не использовать один запрос для поиска сущности, а другой — для поиска необходимых данных.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон, если клиентскому приложению требуется извлечь сущности с помощью множества различных ключей, если клиенту требуется извлечь сущностей в различных порядках сортировки и если каждую сущность можно определить с помощью целого ряда уникальных значений. При выполнении поисков сущностей с использованием различных значений **RowKey** следует убедиться, что целевые показатели масштабируемости раздела не превышены.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации данного шаблона можно принять во внимание следующие шаблоны и рекомендации:  

* [Шаблон вторичного индекса в разных разделах;](#inter-partition-secondary-index-pattern)
* [Шаблон составного ключа;](#compound-key-pattern)
* [Транзакции группы сущностей;](#entity-group-transactions)
* [Работа с разными типами сущностей](#working-with-heterogeneous-entity-types)

### <a name="inter-partition-secondary-index-pattern"></a>Шаблон вторичного индекса в разных разделах
Храните несколько копий каждой сущности с помощью различных значений **RowKey** в отдельных разделах или отдельных таблицах для выполнения быстрых и эффективных операций поиска и активации альтернативных порядков сортировки с помощью различных значений **RowKey**.  

#### <a name="context-and-problem"></a>Контекст и проблема
Служба таблиц автоматически индексирует сущности с помощью значений **PartitionKey** и **RowKey**. Это позволяет клиентскому приложению эффективно извлекать сущности с использованием этих значений. Например, используя приведенную ниже структуру таблицы, клиентское приложение может выполнить точечный запрос для извлечения отдельной сущности сотрудника с указанием названия отдела и идентификатора сотрудника (значения **PartitionKey** и **RowKey**). Клиент также может извлекать сущности, отсортированные по ИД сотрудника в каждом отделе.  

![][9]

Чтобы найти сущность сотрудника на основе другого свойства (например, адрес электронной почты), необходимо использовать менее эффективную функцию просмотра раздела. Это связано с тем, что служба таблиц не поддерживает вторичные индексы. Кроме того, невозможно запросить список сотрудников, отсортированный в порядке, отличном от **RowKey**.  

Вы планируете выполнять множество операций с этими сущностями и хотите свести к минимуму риск регулирования клиента со стороны службы таблиц.  

#### <a name="solution"></a>Решение
Чтобы решить проблему отсутствия вторичных индексов, можно сохранить несколько копий каждой сущности с каждой копией, используя различные значения **PartitionKey** и **RowKey**. При сохранении сущностей с приведенными ниже структурами можно эффективно извлекать сущности сотрудников на основе адреса электронной почты или ИД сотрудника. Значения префиксов empid_ и email_ для **PartitionKey** позволяют определить нужный индекс, который будет использоваться для запроса.  

![][10]

Следующие два условия фильтрации (одно для поиска по идентификатору сотрудника и второе для поиска по адресу электронной почты сотрудника) задают запросы точек.  

* $filter=(PartitionKey eq 'empid_Sales') and (RowKey eq '000223')
* $filter=(PartitionKey eq 'email_Sales') and (RowKey eq 'jonesj@contoso.com')  

Если требуется запросить диапазон сущностей сотрудников, можно указать диапазон, отсортированный по идентификаторам сотрудников или по их адресам электронной почты, выполнив запрос на сущности с соответствующим префиксом в свойстве **RowKey**.  

* Чтобы найти всех сотрудников отдела продаж с ИД сотрудника в диапазоне от **000100** до **000199**, отсортированном по ИД сотрудника, используйте следующее условие: $filter=(PartitionKey eq 'empid_Sales') and (RowKey ge '000100') and (RowKey le '000199').  
* Чтобы найти всех сотрудников отдела продаж с адресом электронной почты, который начинается с "a", и сортировкой по ИД сотрудника, используйте следующее условие: $filter=(PartitionKey eq 'email_Sales') and (RowKey ge 'a') and (RowKey lt 'b').  

Обратите внимание, что синтаксис фильтрации, используемый в приведенных выше примерах, взят из REST API службы таблиц. Дополнительные сведения см. в статье о [сущностях запроса](http://msdn.microsoft.com/library/azure/dd179421.aspx).  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Чтобы обеспечить согласованность копий сущностей, можно использовать [шаблон для согласованных транзакций](#eventually-consistent-transactions-pattern) для сущностей основного и вторичного индексов.  
* Хранилище таблиц является относительно недорогим в использовании, поэтому накладные расходы на хранение повторяющихся данных не являются предметом первостепенной важности. Однако затраты на разработку всегда следует оценивать с учетом требований к планируемому хранилищу и добавлять повторяющиеся сущности только в целях поддержки запросов, которые будет выполнять клиентское приложение.  
* Значение свойства **RowKey** должно быть уникальным для каждой сущности. Рекомендуется использовать значения составного ключа.  
* Заполнение числовых значений в свойстве **RowKey** (например, для идентификатора сотрудника 000223) позволяет правильно выполнять операции сортировки и фильтрации на основе верхних и нижних границ.  
* Дублировать все свойства сущности не требуется. Например, если для запросов, которые ищут сущности по электронному адресу в **RowKey**, не требуется возраст сотрудника, то эти сущности могут иметь следующую структуру:
  
  ![][11]
* Повторяющиеся данные рекомендуется сохранить и убедиться, что все необходимые данные можно извлечь с помощью одного запроса, вместо того, чтобы выполнять одни запрос для поиска сущности с помощью вторичного индекса, а другой — для поиска необходимых данных в первичном индексе.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон, если клиентскому приложению требуется извлечь сущности с помощью множества различных ключей, если клиенту требуется извлечь сущностей в различных порядках сортировки и если каждую сущность можно определить с помощью целого ряда уникальных значений. Используйте этот шаблон, если при поиске сущностей с помощью различных значений **RowKey** нужно избежать превышения показателей ограничения масштабирования раздела.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации данного шаблона можно принять во внимание следующие шаблоны и рекомендации:  

* [Шаблон для согласованных транзакций;](#eventually-consistent-transactions-pattern)  
* [Шаблон вторичного индекса внутри раздела;](#intra-partition-secondary-index-pattern)  
* [Шаблон составного ключа;](#compound-key-pattern)  
* [Транзакции группы сущностей;](#entity-group-transactions)  
* [Работа с разными типами сущностей](#working-with-heterogeneous-entity-types)  

### <a name="eventually-consistent-transactions-pattern"></a>Шаблон для согласованных транзакций
Обеспечьте согласованное поведение в рамках границ раздела или границ системы хранения с помощью запросов Azure.  

#### <a name="context-and-problem"></a>Контекст и проблема
Транзакции группы сущностей приводят к выполнению атомарных транзакций в нескольких сущностях, использующих один общий ключ раздела. Из соображений производительности и масштабируемости может потребоваться сохранить сущности согласно требованиям к согласованности в отдельных разделах или отдельной системе хранения. В этом случае использовать транзакции группы сущностей для обеспечения согласованности нельзя. Например, может существовать требование к обеспечению согласованности между следующими элементами.  

* Сущности, хранящиеся в двух разных разделах в одной таблице, в разных таблицах, в разных учетных записях хранилища.  
* Сущность, хранящаяся в службе таблиц, и большой двоичный объект, хранящийся в службе BLOB-объектов.  
* Сущность, хранящаяся в службе таблиц, и файл в файловой системе.  
* Хранилище сущностей в службе таблиц, проиндексированное с помощью службы поиска Azure.  

#### <a name="solution"></a>Решение
Используя очереди Azure, можно реализовать решение, обеспечивающее согласованность между двумя и более разделами или системами хранения.
Чтобы продемонстрировать этот подход, предположим, что существует требование к архивации старых сущностей сотрудников. К старым сущностям сотрудников редко выполняются запросы, поэтому они должны быть исключены из любых действий, связанных с текущими сотрудниками. Чтобы реализовать это требование, действующие сотрудники сохраняются в таблице **Current**, а старые сотрудники — в таблице **Archive**. Для архивации сотрудника необходимо удалить сущность из таблицы **Current** и добавить сущность в таблицу **Archive**. Но для выполнения этих двух операций нельзя использовать транзакции группы сущностей. Чтобы избежать риска отображения сущности в обеих таблицах или ни в одной из них в случае сбоя, операция архивации должна быть согласованной. Этапы этой операции приведены на следующей схеме. Дополнительные сведения об исключениях см. далее.  

![][12]

Клиент инициирует операцию архивации, помещая сообщение в очередь Azure. В этом примере выполняется архивация сотрудника №456. Рабочая роль опрашивает очередь на наличие новых сообщений. При обнаружении такого сообщения она читает сообщение и оставляет в очереди скрытую копию. Затем рабочая роль извлекает копию сущности из таблицы **Current**, вставляет копию в таблицу **Archive** и после этого удаляет исходную сущность из таблицы **Current**. Если предыдущие действия выполнены без ошибок, рабочая роль удаляет скрытое сообщения из очереди.  

В этом примере на шаге 4 происходит вставка сотрудника в таблицу **Archive** . Сотрудника можно добавить в большой двоичный объект в службе BLOB-объектов или в файл в файловой системе.  

#### <a name="recovering-from-failures"></a>Восстановление после сбоев
Важно отметить, что, если рабочей роли требуется перезапустить операцию архивации, операции на шагах **4** и **5** должны быть *идемпотентными*. Если используется служба таблиц, на шаге **4** необходимо выполнить операцию "Вставить или заменить". На шаге **5** в клиентской библиотеке необходимо выполнить операцию "Удалить, если существует". Если используется другая система хранения данных, необходимо выполнить соответствующую идемпотентную операцию.  

Если рабочая роль никогда не выполняет действие на шаге **6**, по истечении времени ожидания сообщение повторно появится в очереди, чтобы рабочая роль могла обработать его еще раз. Рабочая роль может проверить, сколько раз было прочтено сообщение в очереди, и при необходимости пометит его как «подозрительное» и требующее изучения, отправив в отдельную очередь. Дополнительные сведения о чтении сообщений в очередях и проверке количества сообщений, выведенных из очереди, см. в статье о [получении сообщений](https://msdn.microsoft.com/library/azure/dd179474.aspx).  

Некоторые ошибки в службах очередей и таблиц являются временными, поэтому клиентское приложение должно содержать логику повтора, подходящую для их обработки.  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Это решение не поддерживает изоляцию транзакций. Например, клиент мог считывать таблицы **Current** и **Archive**, когда рабочая роль находилась между шагами **4** и **5**, и заметить несогласованное представление данных. Обратите внимание, что в конечном счете данные будут согласованы.  
* Необходимо убедиться, что для обеспечения окончательной согласованности окончательной шаги 4 и 5 являются идемпотентными.  
* Для масштабирования решения можно использовать несколько очередей и экземпляров рабочих ролей.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон, чтобы обеспечить согласованность между сущностями, которые существуют в различных разделах или таблицах. Этот шаблон можно расширить и обеспечить согласованность операций в службе таблиц и службе BLOB-объектов, а также в других источниках данных, не входящих в службу хранения Azure, таких как база данных или файловая система.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации данного шаблона можно принять во внимание следующие шаблоны и рекомендации:  

* [Транзакции группы сущностей;](#entity-group-transactions)  
* [Объединение или замена.](#merge-or-replace)  

> [!NOTE]
> Если изоляция транзакции имеет важное значение для решения, рекомендуется переработать таблицы для использования транзакций группы сущностей.  
> 
> 

### <a name="index-entities-pattern"></a>Шаблон сущностей индекса
Поддерживайте сущности индексов для выполнения эффективных операций поиска, возвращающих списки сущностей.  

#### <a name="context-and-problem"></a>Контекст и проблема
Служба таблиц автоматически индексирует сущности с помощью значений **PartitionKey** и **RowKey**. Это позволяет клиентскому приложению эффективно извлекать сущность с помощью запроса точки. Например, используя приведенную ниже структуру таблицы, клиентское приложение может эффективно извлекать сущность отдельного сотрудника с помощью названия отдела и идентификатора сотрудника (**PartitionKey** и **RowKey**).  

![][13]

Если наряду с этим необходимо извлекать список сущностей сотрудников на основе значения другого неуникального свойства, например фамилий, для поиска совпадений следует использовать менее эффективную функцию просмотра раздела, а не индекс для прямого поиска. Это связано с тем, что служба таблиц не поддерживает вторичные индексы.  

#### <a name="solution"></a>Решение
Чтобы включить поиск по фамилии с помощью структуры сущности, приведенной выше, необходимо создать и поддерживать списки идентификаторов сотрудников. Чтобы извлечь сущности сотрудников с определенной фамилией, например Jones, сначала найдите список идентификаторов для сотрудников с фамилией Jones, а затем извлеките сущности этих сотрудников. Существует три основных варианта хранения списков идентификаторов сотрудников.  

* Использование хранилища больших двоичных объектов.  
* Создание сущностей индексов в одном разделе с сущностями сотрудников.  
* Создание сущностей индексов в отдельном разделе или таблице.  

<u>Вариант № 1. Использование хранилища больших двоичных объектов</u>  

В этом случае вы создаете большой двоичный объект для каждой уникальной фамилии, а затем в каждом таком объекте сохраняете список значений **PartitionKey** (отдел) и **RowKey** (идентификатор сотрудника) для сотрудников с этой фамилией. При добавлении или удалении сотрудника следует убедиться, что содержимое соответствующего большого двоичного объекта согласовано с сущностями сотрудников.  

<u>Вариант 2.</u> Создание сущностей индексов в одном разделе с сущностями сотрудников  

В этом случае используйте сущности индексов, хранящие следующие данные.  

![][14]

Свойство **EmployeeIDs** содержит список идентификаторов для сотрудников, фамилии которых хранятся в свойстве **RowKey**.  

Ниже описан процесс, которого следует придерживаться при добавлении нового сотрудника при использовании второго варианта. В этом примере мы добавляем сотрудника с идентификатором 000152 и фамилией Jones в отдел продаж.  

1. Извлеките сущность индекса с помощью значения **PartitionKey** Sales и значения **RowKey** Jones. Сохраните ETag это сущности для использования на шаге 2.  
2. Создайте транзакцию группы сущностей, которая вставляет новую сущность сотрудника (значение **PartitionKey** Sales и значение **RowKey** 000152) и обновляет сущность индекса (значение **PartitionKey** Sales и значение **RowKey** Jones), добавив новый идентификатор сотрудника в список в поле EmployeeIDs. Сведения о транзакциях группы сущностей см. в разделе [Транзакции группы сущностей](#entity-group-transactions).  
3. Если транзакция группы сущностей не может быть выполнена из-за ошибки оптимистичного параллелизма (другой пользователь только что изменил сущность индекса), необходимо вернуться к шагу 1.  

Если используется второй вариант, можно использовать аналогичный подход для удаления сотрудника. Изменить фамилию сотрудника немного сложнее, поскольку потребуется выполнить транзакцию группы сущностей для обновления трех сущностей: сущности сотрудника, сущности индекса для старой фамилии и сущности индекса для новой фамилии. Перед внесением любых изменений необходимо извлекать каждую сущность для последующего получения значений ETag, которые затем можно использовать для выполнения обновлений с помощью оптимистичного параллелизма.  

Если используется второй вариант, следуйте приведенной далее процедуре поиска всех сотрудников отдела с нужной фамилией. В этом примере осуществляется поиск всех сотрудников с фамилией Jones в отделе продаж.  

1. Извлеките сущность индекса с помощью значения **PartitionKey** Sales и значения **RowKey** Jones.  
2. Выполните анализ списка идентификаторов сотрудников в поле EmployeeIDs.  
3. Чтобы получить дополнительные сведения о каждом из этих сотрудников (например, адрес электронной почты), извлеките каждую сущность сотрудника с помощью значения **PartitionKey** Sales и значений **RowKey** из списка сотрудников, полученного на шаге 2.  

<u>Вариант 3.</u> Создание сущностей индексов в отдельном разделе или таблице  

Для этого варианта используйте сущности индексов, хранящих следующие данные.  

![][15]

Свойство **EmployeeIDs** содержит список идентификаторов для сотрудников, фамилии которых хранятся в свойстве **RowKey**.  

В третьем случае использовать транзакции группы сущностей для обеспечения согласованности нельзя, поскольку сущности индексов находятся в разделе, отличном от раздела с сущностями сотрудников. Следует убедиться, что сущности индексов согласованы с сущностями сотрудников.  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* В этом решении требуется как минимум два запроса для извлечения совпадающих сущностей: один для запроса сущностей индексов с целью получения списка значений **RowKey** , а другой — для извлечения каждой сущности в списке.  
* С учетом того, что размер отдельной сущности не превышает 1 МБ, в вариантах 2 и 3 решения предполагается, что размер списка идентификаторов сотрудников с любой заданной фамилией никогда не будет больше 1 МБ. Если размер списка идентификаторов сотрудников, вероятнее всего, превышает 1 МБ, следует использовать вариант 1 и сохранить данные индекса в хранилище BLOB-объектов.  
* Если выбран вариант 2 (с использованием транзакций группы сущностей для обработки операций добавления и удаления сотрудников и изменения фамилии сотрудника), то необходимо оценить отношение объема транзакций к ограничениям масштабируемости в определенном разделе. Если значение объема транзакций приближается к ограничениям, рекомендуется обратить внимание на согласованное решение (вариант 1 или 3), которое использует очереди для обработки запросов на обновление и позволяет хранить сущности индексов в разделе, отличном от раздела с сущностями сотрудников.  
* Вариант 2 в этом решении предполагает, что поиск в рамках отдела будет выполняться по фамилии. Например, нужно получить список сотрудников с фамилией Jones из отдела продаж. Чтобы получить возможность поиска всех сотрудников с фамилией Jones в масштабах организации, выберите вариант 1 или 3.
* Можно развернуть решение на основе очереди, что обеспечит согласованность (дополнительные сведения см. в разделе [Шаблон для согласованных транзакций](#eventually-consistent-transactions-pattern)).  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон для поиска набора сущностей с общим значением свойства, например всех сотрудников с фамилией Jones.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации данного шаблона можно принять во внимание следующие шаблоны и рекомендации:  

* [Шаблон составного ключа;](#compound-key-pattern)  
* [Шаблон для согласованных транзакций;](#eventually-consistent-transactions-pattern)  
* [Транзакции группы сущностей;](#entity-group-transactions)  
* [Работа с разными типами сущностей](#working-with-heterogeneous-entity-types)  

### <a name="denormalization-pattern"></a>Шаблон денормализации
Объедините связанные данных в одной сущности для извлечения необходимых данных с помощью одного запроса точки.  

#### <a name="context-and-problem"></a>Контекст и проблема
В реляционной базе данных нормализация данных обычно выполняется для удаления дубликатов, что приводит к созданию запросов для извлечения данных из нескольких таблиц. Если нормализация данных осуществляется в таблицах Azure, для извлечения связанных данных требуется сделать несколько переходов от клиента к серверу и обратно. Например, чтобы получить сведения об отделе при использовании показанной ниже структуры таблицы, необходимо два круговых перехода: один для получения сущности отдела, включающей идентификатор руководителя, а затем выполнить другой запрос для получения сведений о руководителе в сущности сотрудника.  

![][16]

#### <a name="solution"></a>Решение
Вместо хранения данных в двух отдельных сущностях денормализуйте данные и сохраните копию со сведениями о руководителе в сущности отдела. Например:   

![][17]

Теперь когда сущности отделов хранятся с этими свойствами, все сведения об отделе можно получать с помощью запроса точки.  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Двойное хранение некоторых данных связано с определенными издержками. Повышение производительности (достигаемое в результате сокращения количества запросов к службе хранилища) обычно перевешивает незначительный рост затрат на хранение (эти затраты частично компенсируются снижением количества транзакций для получения сведения об отделе).  
* Необходимо поддерживать согласованность двух сущностей, в которых хранятся сведения о руководителях. Для решения проблем согласованности можно воспользоваться транзакциями групп сущностей, которые обновляют несколько сущностей с помощью одной атомарной транзакции. В этом случае сущность отдела и сущность сотрудника для руководителя отдела хранятся в одном разделе.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон, если необходимость поиска связанных данных возникает довольно часто. Этот шаблон уменьшает количество запросов, которые необходимо выполнить клиенту для извлечения требуемых данных.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации данного шаблона можно принять во внимание следующие шаблоны и рекомендации:  

* [Шаблон составного ключа;](#compound-key-pattern)  
* [Транзакции группы сущностей;](#entity-group-transactions)  
* [Работа с разными типами сущностей](#working-with-heterogeneous-entity-types)

### <a name="compound-key-pattern"></a>Шаблон составного ключа
Используйте составные значения **RowKey** , чтобы клиент мог выполнять поиск связанных данных с помощью одного точечного запроса.  

#### <a name="context-and-problem"></a>Контекст и проблема
В реляционной базе считается вполне естественным использовать присоединения в запросах с целью возврата связанных частей данных в клиент в одном запросе. Например, с помощью идентификатора сотрудника можно выполнить поиск списка связанных сущностей, которые содержат данные о производительности этого сотрудника.  

Предположим, что сущности сотрудников хранятся в службе таблиц с использованием следующей структуры.  

![][18]

Необходимо также сохранить исторические данные, связанные с производительностью и оценкой продуктивности по каждому году, отработанному сотрудников в организации. Кроме того, эти данные должны быть доступны по каждому году. Одним из вариантов является создание другой таблицы, в которой хранятся сущности со следующей структурой.  

![][19]

Обратите внимание, что в этом случае вы можете дублировать некоторые сведения (например, имя и фамилию) в новую сущность, чтобы затем извлекать данные с помощью одного запроса. Но вы не можете поддерживать высокий уровень согласованности, поскольку использование транзакций группы сущностей для обновления двух сущностей не допускается.  

#### <a name="solution"></a>Решение
Сохраните новый тип сущности в исходную таблицу с помощью сущностей со следующей структурой.  

![][20]

Обратите внимание, что **RowKey** теперь является составным ключом, состоящим из идентификатора сотрудника и года отчетных данных. Этот ключ позволяет извлекать данные о производительности сотрудника с помощью одного запроса к одной сущности.  

В следующем примере показан процесс извлечения всех отчетных данных по конкретному сотруднику (например, сотрудник 000123 из отдела продаж).  

$filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000123') and (RowKey lt 'empid_000124')&$select=RowKey,Manager Rating,Peer Rating,Comments  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Необходимо использовать соответствующий символ-разделитель, упрощающий анализ значения **RowKey**. Например, **000123_2012**.  
* Эта сущность сохраняется в одном разделе с другими сущностями, которые содержат связанные данные по тому же сотруднику. Это значит, что поддержка высокого уровня согласованности осуществляется с помощью транзакций группы сущностей.
* Чтобы определить допустимость использования этого шаблона, рекомендуется принять во внимание частоту выполнения запросов к данным.  Если вы будете обращаться к отчетным данным редко, а к основным данным сотрудника часто, их следует сохранить как отдельные сущности.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон, если необходимо сохранить одну или несколько связанных часто запрашиваемых сущностей.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации данного шаблона можно принять во внимание следующие шаблоны и рекомендации:  

* [Транзакции группы сущностей;](#entity-group-transactions)  
* [Работа с разными типами сущностей](#working-with-heterogeneous-entity-types)  
* [Шаблон для согласованных транзакций;](#eventually-consistent-transactions-pattern)  

### <a name="log-tail-pattern"></a>Шаблон для заключительного фрагмента журнала
Извлечение *n* сущностей, недавно добавленных в раздел, с помощью значения **RowKey** , выполняющего сортировку по дате и времени в обратном порядке.  

#### <a name="context-and-problem"></a>Контекст и проблема
Общее требование заключается в возможности извлекать самые последние созданные сущности. Например, 10 последних заявок на возмещение, отправленных сотрудниками. Табличные запросы поддерживают операцию запроса **$top** для возвращения первых *n* сущностей из набора. Аналогичная операция запроса для возвращения последних n сущностей в наборе отсутствует.  

#### <a name="solution"></a>Решение
Сохраните сущности с помощью свойства **RowKey**, которое естественным образом сортирует даты и время в обратном порядке. В этом случае самая последняя запись всегда будет отображаться первой.  

Например, чтобы извлечь десять самых последних заявок на возмещение расходов, отправленных сотрудниками, можно использовать обратное значение тика, являющееся производным от текущей даты и времени. В следующем примере кода C# показан один из способов создания подходящего значения «обратных тиков» для свойства **RowKey** , которое выполняет сортировку с самого последнего значения и до самого первого.  

`string invertedTicks = string.Format("{0:D19}", DateTime.MaxValue.Ticks - DateTime.UtcNow.Ticks);`  

Чтобы вернуться к исходному значению даты и времени, воспользуйтесь следующим кодом.  

`DateTime dt = new DateTime(DateTime.MaxValue.Ticks - Int64.Parse(invertedTicks));`  

Табличный запрос выглядит следующим образом.  

`https://myaccount.table.core.windows.net/EmployeeExpense(PartitionKey='empid')?$top=10`  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Чтобы обеспечить надлежащую сортировку, необходимо заполнить начало значения обратного тика нулями.  
* Необходимо соблюдать целевые показатели масштабирования на уровне раздела. Не создайте разделы с высокой нагрузкой.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Этот шаблон используется в случаях, если необходимо получить доступ к сущностям в обратном порядке даты и времени или если требуется доступ к последним добавленным сущностям.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации данного шаблона можно принять во внимание следующие шаблоны и рекомендации:  

* [Анти-шаблон, предусматривающий добавление в начало или конец;](#prepend-append-anti-pattern)  
* [Извлечение сущностей.](#retrieving-entities)  

### <a name="high-volume-delete-pattern"></a>Шаблон для удаления больших объемов сущностей
Включите операцию удаления больших объемов сущностей за счет сохранения всех сущностей для одновременного удаления в отдельной таблице. Удаление сущностей происходит при удалении таблицы.  

#### <a name="context-and-problem"></a>Контекст и проблема
Многие приложения удаляют старые данные, которые больше не требуются для клиентского приложения. Кроме того, данные могут удаляться при архивации приложения на другой носитель. Такие данные обычно можно определить по дате. Например, существует требование для удаления записей всех запросов на вход, которые были созданы более 60 дней назад.  

Один из возможных вариантов заключается в использовании даты и времени запроса на вход в свойстве **RowKey**.  

![][21]

Такой подход позволяет избежать формирования активных областей в разделах, так как приложение сможет вставлять и удалять сущности входа для каждого пользователя в отдельном разделе. Однако при наличии большого количества сущностей этот подход может быть дорогостоящими и требовать значительного времени, поскольку сначала необходимо просмотреть таблицу, чтобы определить все сущности для удаления, а затем удалить каждую старую сущность. Обратите внимание, что количество переходов к серверу, необходимых для удаления старых сущностей, можно сократить путем пакетной вставки нескольких запросов на удаление в EGT.  

#### <a name="solution"></a>Решение
Используйте отдельную таблицу для каждого дня, когда предпринимаются попытки входа с систему. Можно воспользоваться приведенной выше структурой сущности, чтобы избежание формирование активных областей во время вставки сущностей. Процедура удаления старых сущностей теперь заключается в ежедневном удалении одной таблицы (выполнение одной операции хранения), поскольку находить и удалять сотни и тысячи отдельных сущностей входа больше не требуется.  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Ваш проект поддерживает другие способы использования данных приложением, например поиск конкретных сущностей, установка связи с другими данными или создание сводных данных?  
* Ваш проект предотвращает формирование активных областей в случае вставки новых сущностей?  
* Повторное использование того же имени таблицы после его удаления связано с определенной задержкой. Рекомендуется всегда использовать уникальные имена таблиц.  
* Первое использование новой таблицы предполагает регулирование ресурсов, поскольку служба таблиц изучает шаблоны доступа и распределяет разделы по узлам. Рекомендуется определить периодичность создания новых таблиц.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон при наличии большого количества сущностей для одновременного удаления.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации данного шаблона можно принять во внимание следующие шаблоны и рекомендации:  

* [Транзакции группы сущностей;](#entity-group-transactions)
* [Изменение сущностей.](#modifying-entities)  

### <a name="data-series-pattern"></a>Шаблон для рядов данных
Чтобы сократить количество выполняемых запросов, храните ряды данных в одной сущности.  

#### <a name="context-and-problem"></a>Контекст и проблема
Возьмем распространенный сценарий, когда приложение сохраняет ряды данных, которые требуется извлечь все сразу. Например, приложение может записывать количество сообщений, ежечасно отправляемых каждым сотрудником, а затем использовать эти сведения для отображения количества сообщений, отправленных каждым пользователем за предыдущие 24 часа. Для хранения 24 сущностей для каждого сотрудника можно разработать одну структуру.  

![][22]

В ней можно без труда находить и обновлять сущности для каждого сотрудника каждый раз, когда приложению требуется обновить значение количества сообщений. Однако чтобы извлечь данные для построения графика активности за предыдущие 24 часа, потребуется извлечь 24 сущности.  

#### <a name="solution"></a>Решение
Используйте следующую структуру с отдельным свойством для хранения количества сообщений за каждый час.  

![][23]

В этом случае вы сможете обновлять количество сообщений по сотруднику за определенный час с помощью операции объединения. Теперь с помощью запроса к одной сущности можно извлечь все сведения, необходимые для построения графика.  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Если ряды данных не могут полностью поместиться в одну сущность (сущности могут содержать до 252 свойств), используйте альтернативное хранилище данных, например BLOB-объект.  
* Если сущность обновляется несколькими клиентами одновременно, потребуется воспользоваться **ETag** для реализации оптимистичного параллелизма. Большое количество клиентов может привести к высокому уровню конкуренции.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон, если необходимо обновить и получить ряды данных, связанных с отдельной сущностью.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации данного шаблона можно принять во внимание следующие шаблоны и рекомендации:  

* [Шаблон для сущностей больших размеров](#large-entities-pattern)  
* [Объединение или замена.](#merge-or-replace)  
* [Шаблон для согласованных транзакций](#eventually-consistent-transactions-pattern) (при сохранении рядов данных в BLOB-объект).  

### <a name="wide-entities-pattern"></a>Шаблон для масштабных сущностей
Чтобы сохранить сущности, имеющие более 252 свойств, используйте несколько физических сущностей.  

#### <a name="context-and-problem"></a>Контекст и проблема
Отдельные сущности могут иметь не более 252 свойства (за исключением обязательных свойств системы), а общий объем хранимых данных не должен превышать 1 МБ. В реляционной базе вопрос с ограничениями по размеру строки обычно решается путем добавления новой таблицы и установкой отношения «один-к-одному».  

#### <a name="solution"></a>Решение
С помощью службы таблиц можно сохранить несколько сущностей, которые будут представлять один крупный бизнес-объект с более чем 252 свойствами. Например, чтобы сохранить количество мгновенных сообщений, отправленных каждого сотрудником за последние 365 дней, можно использовать следующую структуру с двумя сущностями, имеющими разные схемы.  

![][24]

Если необходимо внести изменение, требующее обновления обеих сущностей для обеспечения их синхронизации, воспользуйтесь транзакциями группы сущностей. В противном случае можно выполнить одну операцию объединения, которая позволит обновить количество сообщений за определенный день. Чтобы извлечь все данные по отдельному сотруднику, необходимо извлечь обе сущности. Для этого воспользуйтесь двумя эффективными запросами, использующими значения **PartitionKey** и **RowKey**.  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Извлечение логической сущности целиком связано с выполнением как минимум двух операций с хранилищем: одна для извлечения каждой физической сущности.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон, если требуется сохранить сущности, размер или количество свойств которых превышает ограничения для отдельной сущности в службе таблиц.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации данного шаблона можно принять во внимание следующие шаблоны и рекомендации:  

* [Транзакции группы сущностей;](#entity-group-transactions)
* [Объединение или замена.](#merge-or-replace)

### <a name="large-entities-pattern"></a>Шаблон для сущностей больших размеров
Для хранения больших по объему значений свойств используйте хранилище больших двоичных объектов.  

#### <a name="context-and-problem"></a>Контекст и проблема
В отдельной сущности нельзя сохранить данные, общий объем которых превышает 1 МБ. Если в одном или нескольких свойствах хранятся значения, из-за которых общий размер сущности превышает указанное значение, эту сущность нельзя сохранить в службе таблиц.  

#### <a name="solution"></a>Решение
Если размер сущности превышает 1 МБ из-за того, что одно или несколько свойств содержат большой объем данных, эти данные можно сохранить в службе BLOB-объектов, а затем сохранить адрес большого двоичного объекта в свойстве в сущности. Например, фотографию сотрудника можно сохранить в хранилище больших двоичных объектов, а ссылку на фотографию — в свойстве **Photo** сущности сотрудника.  

![][25]

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Чтобы обеспечить согласованность между сущностью в службе таблиц и данными в службе BLOB-объектов, используйте [шаблон для согласованных транзакций](#eventually-consistent-transactions-pattern) .
* Для извлечения полной сущности требуется как минимум две транзакции хранилища: одна для извлечения сущности и одна для извлечения данных большого двоичного объекта.  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Используйте этот шаблон, если необходимо сохранить сущности, размер которых превышает ограничения для отдельной сущности в службе таблиц.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации данного шаблона можно принять во внимание следующие шаблоны и рекомендации:  

* [Шаблон для согласованных транзакций;](#eventually-consistent-transactions-pattern)  
* [Шаблон для масштабных сущностей.](#wide-entities-pattern)

<a name="prepend-append-anti-pattern"></a>

### <a name="prependappend-anti-pattern"></a>Анти-шаблон, предусматривающий добавление в начало или конец
При наличии большого количества операций вставки, повысьте уровень масштабируемости путем распределения вставляемых компонентов по нескольким разделам.  

#### <a name="context-and-problem"></a>Контекст и проблема
Как правило, добавление сущностей в начало или конец хранящихся сущностей приводит к тому, что приложение будет добавлять новые сущности к первому или последнему разделу в последовательности разделов. В этом случае все операции вставки в любой момент времени выполняются в одном разделе. При этом создается активная область, не позволяющая службе таблиц распределять операции вставки по нескольким узлам, и может возникнуть ситуация, когда приложение достигает целевых показателей масштабируемости для раздела. Например, при наличии приложения, регистрирующего доступ сотрудников к сети и ресурсам, использование показанной ниже структуры сущности может привести к тому, что раздел текущего часа станет активной областью, если объем транзакций достигнет целевых показателей масштабируемости для отдельного раздела.  

![][26]

#### <a name="solution"></a>Решение
Следующая альтернативная структура сущности предотвращает формирование активной области в любом разделе во время регистрации событий приложением.  

![][27]

Обратите внимание, что в этом примере **PartitionKey** и **RowKey** являются составными ключами. Свойство **PartitionKey** использует идентификаторы отдела и сотрудника для распределения операции ведения журнала по нескольким разделам.  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При принятии решения о реализации этого шаблона необходимо учитывать следующие моменты.  

* Альтернативная структура ключа, которая предотвращает создание разделов с высокой нагрузкой во время выполнения операций вставки, поддерживает запросы, выполняемые клиентским приложением?  
* Ожидаемый объем транзакций означает вероятность достижения целевых показателей масштабируемости для отдельного раздела и возможность регулирования службой хранения?  

#### <a name="when-to-use-this-pattern"></a>Когда следует использовать этот шаблон
Не используйте анти-шаблон, предусматривающий добавление в начало или конец, если объем транзакций может привести к регулированию при доступе к разделу с высокой нагрузкой.  

#### <a name="related-patterns-and-guidance"></a>Связанные шаблоны и рекомендации
При реализации данного шаблона можно принять во внимание следующие шаблоны и рекомендации:  

* [Шаблон составного ключа;](#compound-key-pattern)  
* [Шаблон для заключительного фрагмента журнала;](#log-tail-pattern)  
* [Изменение сущностей.](#modifying-entities)  

### <a name="log-data-anti-pattern"></a>Анти-шаблон для данных журнала
Как правило, данные журнала следует хранить не в службе таблиц, а в службе BLOB-объектов.  

#### <a name="context-and-problem"></a>Контекст и проблема
Стандартный вариант использования данных журнала — извлечение выборки записей журнала по конкретному диапазону дат и времени. Например, требуется найти все сообщения об ошибках и важные сообщения, зафиксированные приложением в журнале в период с 15:04 до 15:06 в конкретный день. Чтобы определить раздел, в котором хранятся сущности журнала, не рекомендуется использовать дату и время записи журнала, так как это приведет к созданию раздела с высокой нагрузкой. Это означает, что в любой момент времени все сущности журнала будут обращаться к одному общему значению **PartitionKey** (см. раздел [Антишаблон, предусматривающий добавление в начало или конец](#prepend-append-anti-pattern)). Например, следующая схема сущности для сообщения журнала приводит к созданию раздела с высокой нагрузкой, так как приложение записывает все сообщения журнала в раздел для текущей даты и часа.  

![][28]

В этом примере **RowKey** содержит дату и время сообщения журнала, чтобы обеспечить сортировку хранящихся сообщений по дате и времени. Если одинаковые дату и время имеют несколько сообщений журнала, в это свойство также входит идентификатор сообщения.  

Другим вариантом является использование свойства **PartitionKey** для записи сообщений в несколько разделов. Например, если источник сообщения журнала позволяет распределять сообщения по нескольким разделам, можно использовать следующую схему сущности.  

![][29]

Однако здесь возникает проблема, которая заключается в том, что для извлечения всех сообщений журнала за определенный период времени необходимо выполнить поиск в каждом разделе таблицы.

#### <a name="solution"></a>Решение
В предыдущем разделе была отмечена проблема использования службы таблиц для хранения записей журнала и предлагались две неудовлетворительные схемы. Результатом одного решения было формирование активной области с риском снижения производительности записи сообщений журнала. Другое решение приводило к ухудшению производительности запросов в связи с требованием просматривать каждый раздел в таблице для получения сообщений журнала за определенный промежуток времени. Хранилище больших двоичных объектов предлагает наилучшее решение в такой ситуации. Оно связано с преимуществами хранения данных журнала в службе аналитики хранилища Azure.  

Описанные в этом разделе способы хранения данных журнала службой аналитики хранилища в хранилище больших двоичных объектов иллюстрируют подход к хранению данных, запрашиваемых по диапазону.  

Служба аналитики хранилища сохраняет сообщения журнала в формате с разделителями в нескольких больших двоичных объектах. Формат с разделителями упрощает анализ данных в сообщениях журнала.  

Служба аналитики хранилища использует соглашение об именовании больших двоичных объектов, позволяющее находить большой двоичный объект (или большие двоичные объекты), которые содержат искомые сообщения журнала. Например, большой двоичный объект с именем «queue/2014/07/31/1800/000001.log» содержит сообщения журнала, относящиеся к службе очередей, за час, начиная с 18:00 31 июля 2014 г. «000001» означает первый файл журнала за этот период. Служба аналитики хранилища также записывает метки времени первого и последнего сообщений журнала, хранящихся в файле в составе метаданных большого двоичного объекта. С помощью API-интерфейса хранилища больших двоичных объектов можно выполнять поиск больших двоичных объектов в контейнере на основе префикса имени. Чтобы найти все большие двоичные объекты, содержащие данные журнала очереди за час, начиная с 18:00, используйте префикс «queue/2014/07/31/1800».  

Служба аналитики хранилища помещает сообщения журнала во внутренний буфер, а затем периодически обновляет соответствующий большой двоичный объект или создает новый с последним пакетом записей журнала. Это способствует сокращению количества операций записи, которые должны быть выполнены в службу BLOB-объектов.  

При реализации подобного решения в собственном приложении вам необходимо решить вопрос управления компромиссом между надежностью (запись каждого сообщения журнала в хранилище больших двоичных объектов), затратами и масштабируемостью (буферизация обновлений в приложении и их пакетная запись в хранилище больших двоичных объектов).  

#### <a name="issues-and-considerations"></a>Проблемы и рекомендации
При выборе способа хранения данных журнала, необходимо учитывать следующие моменты.  

* При создании схемы таблицы без потенциальных разделов с высокой нагрузкой может оказаться, что доступ к данным журнала осуществляется неэффективно.  
* Для обработки данные журнала клиенту часто требуется загружать много записей.  
* Несмотря на то, что данные журнала часто носят структурированный характер, наилучшим решением может быть хранилище больших двоичных объектов.  

### <a name="implementation-considerations"></a>Рекомендации по реализации
В этом разделе рассматриваются некоторые вопросы, которые необходимо иметь в виду при реализации моделей, описанных в предыдущих разделах. В большей части этого раздела приводятся примеры на языке C#, в которых используется клиентская библиотека хранилища(версия 4.3.0 на момент написания данного руководства).  

### <a name="retrieving-entities"></a>Извлечение сущностей.
Как упоминалось в разделе [Разработка для запросов](#design-for-querying), самый эффективный запрос — точечный. Однако в некоторых случаях может потребоваться извлечь несколько сущностей. В этом разделе описывается ряд общих методов извлечения сущностей с помощью клиентской библиотеки хранилища.  

#### <a name="executing-a-point-query-using-the-storage-client-library"></a>Выполнение запроса точки с помощью клиентской библиотеки хранилища
Самый простой способ выполнения точечного запроса заключается в использовании табличной операции **Retrieve**, приведенной в следующем фрагменте кода C#. Он извлекает сущность, у которой свойство **PartitionKey** имеет значение Sales, а свойство **RowKey** — значение 212:  

```csharp
TableOperation retrieveOperation = TableOperation.Retrieve<EmployeeEntity>("Sales", "212");
var retrieveResult = employeeTable.Execute(retrieveOperation);
if (retrieveResult.Result != null)
{
    EmployeeEntity employee = (EmployeeEntity)retrieveResult.Result;
    ...
}  
```

Обратите внимание на то, что извлекаемая сущность будет иметь тип **EmployeeEntity**.  

#### <a name="retrieving-multiple-entities-using-linq"></a>Извлечение нескольких сущностей с помощью LINQ
Для извлечения нескольких сущностей можно использовать LINQ с клиентской библиотекой хранилища, указав при этом запрос с предложением **where** . Чтобы исключить просмотр таблицы, в предложение where необходимо всегда включать значение **PartitionKey** и, если возможно, значение **RowKey**, которые позволят избежать просмотров таблиц и разделов. Служба таблиц поддерживает ограниченный набор операторов сравнения («больше», «больше или равно», «меньше», «меньше или равно», «равно», «не равно»), которые могут использоваться в предложении where. Следующий фрагмент кода C# предназначен для поиска всех сотрудников, фамилии которых начинаются с буквы B (при условии, что фамилия хранится в свойстве **RowKey**), в отделе продаж (при условии, что название отдела хранится в свойстве **PartitionKey**).  

```csharp
TableQuery<EmployeeEntity> employeeQuery = employeeTable.CreateQuery<EmployeeEntity>();
var query = (from employee in employeeQuery
            where employee.PartitionKey == "Sales" &&
            employee.RowKey.CompareTo("B") >= 0 &&
            employee.RowKey.CompareTo("C") < 0
            select employee).AsTableQuery();
var employees = query.Execute();  
```

Обратите внимание на то, каким образом в запросе указываются свойства **RowKey** и **PartitionKey** для обеспечения максимального быстродействия.  

В следующем примере кода показана эквивалентная функциональность с использованием плавного API (дополнительные сведения о плавных API см. в разделе [Best Practices for Designing a Fluent API](http://visualstudiomagazine.com/articles/2013/12/01/best-practices-for-designing-a-fluent-api.aspx) (Советы и рекомендации по разработке плавного API)).  

```csharp
TableQuery<EmployeeEntity> employeeQuery = new TableQuery<EmployeeEntity>().Where(
    TableQuery.CombineFilters(
    TableQuery.CombineFilters(
        TableQuery.GenerateFilterCondition(
    "PartitionKey", QueryComparisons.Equal, "Sales"),
    TableOperators.And,
    TableQuery.GenerateFilterCondition(
    "RowKey", QueryComparisons.GreaterThanOrEqual, "B")
),
TableOperators.And,
TableQuery.GenerateFilterCondition("RowKey", QueryComparisons.LessThan, "C")
    )
);
var employees = employeeTable.ExecuteQuery(employeeQuery);  
```

> [!NOTE]
> В образце объединено несколько методов **CombineFilters** для включения трех условий фильтрации.  
> 
> 

#### <a name="retrieving-large-numbers-of-entities-from-a-query"></a>Извлечение большого количества сущностей из запроса
Оптимальный запрос возвращает отдельные сущности на основе значений **PartitionKey** и **RowKey**. Однако в некоторых ситуациях может существовать требование о возвращении нескольких сущностей из одного или даже нескольких разделов.  

В таких случаях следует полностью протестировать производительность приложения.  

Запрос к службе таблиц может возвращать максимум 1000 сущностей одновременно, а время его выполнения не превышает 5 секунд. Если результирующий набор содержит более 1000 сущностей, если запрос выполняется более 5 секунд или выходит за пределы раздела, служба таблиц возвращает маркер продолжения, чтобы клиентское приложение смогло выполнить запрос к следующему набору сущностей. Дополнительные сведения о принципе действия маркеров продолжения см. в статье [Query Timeout and Pagination](http://msdn.microsoft.com/library/azure/dd135718.aspx) (Время ожидания запроса и разбивка на страницы).  

Клиентская библиотека хранилища может автоматически обрабатывать маркеры продолжения при возвращении сущностей из службы таблиц. В следующем примере кода C# клиентская библиотека хранилища автоматически обрабатывает маркеры продолжения в случае их возвращения службой таблиц в ответе.  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

var employees = employeeTable.ExecuteQuery(employeeQuery);
foreach (var emp in employees)
{
        ...
}  
```

Следующий код C# обрабатывает маркеры продолжения явным образом.  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

TableContinuationToken continuationToken = null;

do
{
        var employees = employeeTable.ExecuteQuerySegmented(
        employeeQuery, continuationToken);
    foreach (var emp in employees)
    {
    ...
    }
    continuationToken = employees.ContinuationToken;
} while (continuationToken != null);  
```

Явное использование маркеров продолжения позволяет управлять извлечением следующего сегмента данных. Например, если клиентское приложение разрешает пользователям постранично просматривать хранящиеся в таблице сущности, пользователь может отказаться от постраничного просмотра всех сущностей, полученных запросом, поэтому приложение будет использовать маркер продолжения для извлечения следующего сегмента только после того, как пользователь завершит постраничный просмотр всех сущностей в текущем сегменте. Такой подход имеет несколько преимуществ.  

* Он позволяет ограничивать объем данных, извлекаемых из службы таблиц и перемещаемых по сети.  
* Он позволяет выполнять асинхронные операции ввода-вывода в .NET.  
* Он позволяет сериализовать маркер продолжения в постоянное хранилище, чтобы пользователь мог продолжить свои действия в случае сбоя приложения.  

> [!NOTE]
> Маркер продолжения обычно возвращает сегмент, содержащий 1000 сущностей и меньше. Это действительно и в том случае, если количество сущностей, возвращаемых в результате запроса, ограничивается с помощью операции **Take** для возврата первых n сущностей, соответствующих условию поиска. Служба таблиц может вернуть сегмент, содержащий меньше n сущностей, а также маркер продолжения, который позволит получить остальные сущности.  
> 
> 

Следующий код C# демонстрирует процесс изменения количества возвращаемых сущностей в сегменте.  

```csharp
employeeQuery.TakeCount = 50;  
```

#### <a name="server-side-projection"></a>Проекция на стороне сервера
Одна сущность может иметь до 255 свойств и быть размером не более 1 МБ. При выполнении запроса к таблице и извлечении сущностей может потребоваться только часть свойств, а передача данных будет осуществляться только при необходимости (для сокращения времени задержки и снижения затрат). Проекции на стороне сервера можно использовать для передачи только необходимых свойств. В следующем примере показано извлечение только свойства **Email** (вместе с **PartitionKey**, **RowKey**, **Timestamp** и **ETag**) из сущностей, выбранных запросом.  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
List<string> columns = new List<string>() { "Email" };
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter).Select(columns);

var entities = employeeTable.ExecuteQuery(employeeQuery);
foreach (var e in entities)
{
        Console.WriteLine("RowKey: {0}, EmployeeEmail: {1}", e.RowKey, e.Email);
}  
```

Обратите внимание на доступность значения **RowKey** несмотря на то, что оно не включено в список возвращаемых свойств.  

### <a name="modifying-entities"></a>Изменение сущностей.
Клиентская библиотека хранилища позволяет изменять сущности, хранящиеся в службе таблиц путем вставки, удаления и обновления сущностей. С помощью транзакций группы сущностей можно выполнять пакетные операции вставки, обновления и удаления, сокращая тем самым количество круговых переходов и повышая производительность решения.  

Обратите внимание, что исключения, создаваемые в тот момент, когда клиентская библиотека хранилища выполняет транзакцию группы сущностей, обычно содержат индекс сущности, которая вызвала сбой обработки всего пакета. Это может оказаться полезным при отладке кода, использующего транзакции группы сущностей.  

Следует также учитывать влияние разработки на то, каким образом клиентское приложение обрабатывает операций параллелизма и обновления.  

#### <a name="managing-concurrency"></a>Управление параллелизмом
По умолчанию служба таблиц реализует проверки оптимистичного параллелизма на уровне отдельных сущностей для операций **Insert**, **Merge** и **Delete** несмотря на то, что клиент может принудительно заставить службу таблиц обойти эти проверки. Дополнительные сведения о том, каким образом служба таблиц осуществляет управление параллелизмом, см. в статье [Управление параллелизмом в службе хранилища Microsoft Azure](../storage/common/storage-concurrency.md).  

#### <a name="merge-or-replace"></a>Объединение или замена.
Метод **Replace** класса **TableOperation** всегда полностью заменяет сущность в службе таблиц. Если это свойство не включено в запрос, но существует в хранимой сущности, запрос удалит это свойство из хранимой сущности. Каждое свойство требуется в включать в запрос до тех пор, пока оно явным образом не будет удалено из хранимой сущности.  

Метод **Merge** класса **TableOperation** можно использовать для сокращения объема данных, отправляемых в службу таблиц при необходимости обновления сущности. Метод **Merge** заменяет любые свойства в хранимой сущности значениями свойств из сущности в составе запроса, но не изменяет свойства в хранимой сущности, которые не включены в запрос. Это полезно при наличии сущностей больших размеров и если нужно обновить незначительное количество свойств в запросе.  

> [!NOTE]
> Если сущность не существует, методы **Replace** и **Merge** завершаются ошибкой. В качестве альтернативы рекомендуется рассмотреть методы **InsertOrReplace** и **InsertOrMerge**, которые в случае отсутствия сущности создают таковую.  
> 
> 

### <a name="working-with-heterogeneous-entity-types"></a>Работа с разными типами сущностей
Служба таблиц представляет собой табличное хранилище *schema-less*. Это значит, что в одной таблице могут храниться сущности нескольких типов, что обеспечивает исключительную гибкость разработки. В следующем примере показана таблица, в которой хранятся сущности сотрудников и отделов.  

<table>
<tr>
<th>PartitionKey</th>
<th>RowKey</th>
<th>Timestamp</th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>

Обратите внимание, что каждая сущность должна иметь значения **PartitionKey**, **RowKey** и **Timestamp** и при этом может содержать любой набор свойств. Кроме того, тип сущности будет указан только после выбора места для хранения этих сведений. Существует два варианта определения типа сущности.  

* Добавьте тип сущности в начало свойства **RowKey** (или, возможно, свойства **PartitionKey**). Например, **EMPLOYEE_000123** или **DEPARTMENT_SALES** в качестве значений **RowKey**.  
* Используйте отдельное свойство для записи типа сущности, как показано в таблице ниже.  

<table>
<tr>
<th>PartitionKey</th>
<th>RowKey</th>
<th>Timestamp</th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td>Employee</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td>Employee</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td>Department</td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td>Employee</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>

Первый вариант (добавление типа сущности в начало свойства **RowKey**) полезен, если существует вероятность, что две сущности разных типов имеют одинаковое значение ключа. Кроме того, он позволяет объединять сущности одного типа в раздел.  

Методики, рассматриваемые в этом разделе, особенно актуальны для темы [Отношения наследования](#inheritance-relationships), которая обсуждалась ранее в разделе [Моделирование отношений](#modelling-relationships).  

> [!NOTE]
> Чтобы клиентские приложения могли формировать объекты POCO и работать с различными версиями, рекомендуется включить номер версии в значение типа сущности.  
> 
> 

В оставшейся части этого раздела описываются некоторые функции клиентской библиотеки хранилища, которые упрощают работу с несколькими типами сущностей в одной таблице.  

#### <a name="retrieving-heterogeneous-entity-types"></a>Извлечение разных типов сущностей
Если вы используете клиентскую библиотеку хранилища, вам доступны три варианта работы с несколькими типами сущностей.  

Если известен тип сущности, сохраненной с конкретными значениями **RowKey** и **PartitionKey**, то тип сущности можно указать при извлечении сущности, как показано в предыдущих двух примерах по извлечению сущностей типа **EmployeeEntity** — [Выполнение запроса точки с помощью клиентской библиотеки хранилища](#executing-a-point-query-using-the-storage-client-library) и [Извлечение нескольких сущностей с помощью LINQ](#retrieving-multiple-entities-using-linq).  

Вторым вариантом является использование типа **DynamicTableEntity** (контейнер свойств) вместо конкретного типа сущности POCO. Этот вариант способен повысить производительность, так как не нужно выполнять сериализацию и десериализацию сущности в типы .NET. В следующем примере кода C# показано извлечение нескольких сущностей различных типов из таблицы и возврат всех сущностей в качестве экземпляров **DynamicTableEntity**. После этого в примере используется свойство **EntityType** для определения типа каждой сущности.  

```csharp
string filter = TableQuery.CombineFilters(
    TableQuery.GenerateFilterCondition("PartitionKey",
    QueryComparisons.Equal, "Sales"),
    TableOperators.And,
    TableQuery.CombineFilters(
    TableQuery.GenerateFilterCondition("RowKey",
                    QueryComparisons.GreaterThanOrEqual, "B"),
        TableOperators.And,
        TableQuery.GenerateFilterCondition("RowKey",
        QueryComparisons.LessThan, "F")
    )
);
TableQuery<DynamicTableEntity> entityQuery =
    new TableQuery<DynamicTableEntity>().Where(filter);
var employees = employeeTable.ExecuteQuery(entityQuery);

IEnumerable<DynamicTableEntity> entities = employeeTable.ExecuteQuery(entityQuery);
foreach (var e in entities)
{
EntityProperty entityTypeProperty;
if (e.Properties.TryGetValue("EntityType", out entityTypeProperty))
{
    if (entityTypeProperty.StringValue == "Employee")
    {
        // Use entityTypeProperty, RowKey, PartitionKey, Etag, and Timestamp
        }
    }
}  
```

Обратите внимание, что другие свойства извлекаются с помощью метода **TryGetValue** в свойстве **Properties** класса **DynamicTableEntity**.  

Третий вариант заключается в использовании типа **DynamicTableEntity** вместе в экземпляром **EntityResolver**. Он позволяет выполнять разрешение в несколько типов POCO в рамках одного запроса. В этом примере делегат **EntityResolver** использует свойство **EntityType**, чтобы отличать два типа сущности, возвращаемых запросом. Метод **Resolve** использует делегат **resolver** для разрешения экземпляров **DynamicTableEntity** в экземпляры **TableEntity**.  

```csharp
EntityResolver<TableEntity> resolver = (pk, rk, ts, props, etag) =>
{

        TableEntity resolvedEntity = null;
        if (props["EntityType"].StringValue == "Department")
        {
        resolvedEntity = new DepartmentEntity();
        }
        else if (props["EntityType"].StringValue == "Employee")
        {
        resolvedEntity = new EmployeeEntity();
        }
        else throw new ArgumentException("Unrecognized entity", "props");

        resolvedEntity.PartitionKey = pk;
        resolvedEntity.RowKey = rk;
        resolvedEntity.Timestamp = ts;
        resolvedEntity.ETag = etag;
        resolvedEntity.ReadEntity(props, null);
        return resolvedEntity;
};

string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<DynamicTableEntity> entityQuery =
        new TableQuery<DynamicTableEntity>().Where(filter);

var entities = employeeTable.ExecuteQuery(entityQuery, resolver);
foreach (var e in entities)
{
        if (e is DepartmentEntity)
        {
    ...
        }
        if (e is EmployeeEntity)
        {
    ...
        }
}  
```

#### <a name="modifying-heterogeneous-entity-types"></a>Изменение разных типов сущностей
Чтобы удалить тип сущности, его не нужно знать. Однако при вставке тип сущности всегда известен. Чтобы обновить сущность, не зная ее тип и не используя класс сущности POCO, можно воспользоваться типом **DynamicTableEntity**. Следующий пример кода извлекает одну сущность и проверяет свойство **EmployeeCount** перед его обновлением.  

```csharp
TableResult result =
        employeeTable.Execute(TableOperation.Retrieve(partitionKey, rowKey));
DynamicTableEntity department = (DynamicTableEntity)result.Result;

EntityProperty countProperty;

if (!department.Properties.TryGetValue("EmployeeCount", out countProperty))
{
        throw new
        InvalidOperationException("Invalid entity, EmployeeCount property not found.");
}
countProperty.Int32Value += 1;
employeeTable.Execute(TableOperation.Merge(department));  
```

### <a name="controlling-access-with-shared-access-signatures"></a>Управление доступом с помощью подписей общего доступа
Маркеры подписи общего доступа (SAS) позволяют клиентским приложениям напрямую изменять (и выполнять запросы) сущности таблицы без прохождения проверки подлинности в службе таблиц. Существует три основных преимущества использования SAS в приложении.  

* Не нужно распространять ключ учетной записи хранения на небезопасной платформе (например, на мобильном устройстве), чтобы предоставить устройству права на доступ и изменение сущностей в службе таблиц.  
* Часть операций по управлению сущностями, выполняемых веб- и рабочими ролями, можно перенести на клиентские устройства, такие как компьютеры конечных пользователей и мобильные устройства.  
* Клиенту можно назначить ограниченный ресурсами и временем набор разрешений (например, доступ только для чтения к определенным ресурсам).  

Дополнительные сведения об использовании маркеров SAS со службой таблиц см. в статье [Использование подписанных URL-адресов (SAS)](../storage/common/storage-dotnet-shared-access-signature-part-1.md).  

Однако вы по-прежнему должны создавать маркеры SAS, предоставляющие клиентскому приложению доступ к сущностям в службе таблиц. Выполнять эту операцию следует в среде с безопасным доступом к ключам учетной записи хранения. Как правило, для создания маркеров SAS их доставки в клиентские приложения, которым требуется доступ к сущностям, используются веб-роли или рабочие роли. Поскольку процесс создания маркеров SAS и их доставки клиентов по-прежнему связан с издержками, рекомендуется рассмотреть оптимальные варианты сокращения расходов в сценариях с большим количеством операций.  

Можно создать маркер SAS, который предоставляет доступ к подмножеству сущностей в таблице. По умолчанию создается маркер SAS для всей таблицы. Однако можно указать, что маркер SAS предоставляет доступ либо к диапазону значений **PartitionKey**, либо к диапазону значений **PartitionKey** и **RowKey**. Маркеры SAS можно создать для отдельных пользователей системы таким образом, чтобы маркер SAS предоставлял пользователю доступ только к его собственным сущностям в службе таблиц.  

### <a name="asynchronous-and-parallel-operations"></a>Асинхронные и параллельные операции
Чтобы улучшить производительность и время отклика клиента в случае распределения запросов по нескольким разделам, рекомендуется обратить внимание на асинхронные и параллельные запросы.
Например, в вашем распоряжении может быть два или несколько экземпляров рабочих ролей с параллельным доступом к таблицам. Отдельные рабочие роли могут отвечать за определенные наборы разделов или же просто несколько экземпляров рабочих ролей могут получать доступ ко всем разделам в таблице.  

Повысить производительность в экземпляре клиента можно путем асинхронного выполнения операций хранения. Клиентская библиотека хранилища упрощает написание асинхронных запросов и изменений. Например, можно начать с синхронного метода, который извлекает все сущности в разделе, как показано в следующем коде C#.  

```csharp
private static void ManyEntitiesQuery(CloudTable employeeTable, string department)
{
        string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, department);
        TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

        TableContinuationToken continuationToken = null;

        do
        {
        var employees = employeeTable.ExecuteQuerySegmented(
                employeeQuery, continuationToken);
        foreach (var emp in employees)
    {
        ...
    }
        continuationToken = employees.ContinuationToken;
        } while (continuationToken != null);
}  
```

Этот код можно легко изменить, чтобы запрос выполнялся в асинхронном режиме, как показано ниже.  

```csharp
private static async Task ManyEntitiesQueryAsync(CloudTable employeeTable, string department)
{
        string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, department);
        TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);
        TableContinuationToken continuationToken = null;

        do
        {
        var employees = await employeeTable.ExecuteQuerySegmentedAsync(
                employeeQuery, continuationToken);
        foreach (var emp in employees)
        {
            ...
        }
        continuationToken = employees.ContinuationToken;
            } while (continuationToken != null);
}  
```

В данном примере асинхронного режима присутствуют следующие отличия от синхронной версии.  

* Теперь подпись метода содержит модификатор **async** и возвращает экземпляр **Task**.  
* Вместо вызова метода **ExecuteSegmented** для извлечения результатов метод вызывает метод **ExecuteSegmentedAsync** и использует модификатор **await** для асинхронного получения результатов.  

Клиентское приложение может вызывать этот метод несколько раз (с разными значениями параметра **department**), а каждый запрос будет выполняться в отдельном потоке.  

Обратите внимание, что асинхронная версия метода **Execute** в классе **TableQuery** отсутствует, поскольку интерфейс **IEnumerable** не поддерживает асинхронное перечисление.  

Можно вставлять, обновлять и удалять сущности в асинхронном режиме. В следующем примере кода C# показан простой синхронный метод вставки или замены сущности сотрудника.  

```csharp
private static void SimpleEmployeeUpsert(CloudTable employeeTable,
        EmployeeEntity employee)
{
        TableResult result = employeeTable
        .Execute(TableOperation.InsertOrReplace(employee));
        Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
}  
```

Этот код можно легко изменить, чтобы обновление выполнялось в асинхронном режиме, как показано ниже.  

```csharp
private static async Task SimpleEmployeeUpsertAsync(CloudTable employeeTable,
        EmployeeEntity employee)
{
        TableResult result = await employeeTable
        .ExecuteAsync(TableOperation.InsertOrReplace(employee));
        Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
}  
```

В данном примере асинхронного режима присутствуют следующие отличия от синхронной версии.  

* Теперь подпись метода содержит модификатор **async** и возвращает экземпляр **Task**.  
* Вместо вызова метода **Execute** для обновления сущности метод вызывает метод **ExecuteAsync** и использует модификатор **await** для асинхронного получения результатов.  

Клиентское приложение может вызывать несколько подобных асинхронных методов, а каждый вызов метода будет выполняться в отдельном потоке.  

### <a name="credits"></a>Баллы
Выражаем благодарность за вклад в подготовку данного руководства следующим участникам команды разработчиков Azure: Доминику Беттсу (Dominic Betts), Джейсону Хоггу (Jason Hogg), Жану Ганему (Jean Ghanem), Джею Харидасу (Jai Haridas), Джеффу Ирвину (Jeff Irwin), Вамшидхару Комминени (Vamshidhar Kommineni), Винай Шаху (Vinay Shah) и Сердару Озлеру (Serdar Ozler), а также Тому Холландеру (Tom Hollander) из команды Microsoft DX. 

Мы хотим поблагодарить следующих экспертов Майкрософт, высказавших свое мнение во время циклов проверки: Игоря Папирова (Igor Papirov) и Эдварда Бэккера (Edward Bakker).

[1]: ./media/storage-table-design-guide/storage-table-design-IMAGE01.png
[2]: ./media/storage-table-design-guide/storage-table-design-IMAGE02.png
[3]: ./media/storage-table-design-guide/storage-table-design-IMAGE03.png
[4]: ./media/storage-table-design-guide/storage-table-design-IMAGE04.png
[5]: ./media/storage-table-design-guide/storage-table-design-IMAGE05.png
[6]: ./media/storage-table-design-guide/storage-table-design-IMAGE06.png
[7]: ./media/storage-table-design-guide/storage-table-design-IMAGE07.png
[8]: ./media/storage-table-design-guide/storage-table-design-IMAGE08.png
[9]: ./media/storage-table-design-guide/storage-table-design-IMAGE09.png
[10]: ./media/storage-table-design-guide/storage-table-design-IMAGE10.png
[11]: ./media/storage-table-design-guide/storage-table-design-IMAGE11.png
[12]: ./media/storage-table-design-guide/storage-table-design-IMAGE12.png
[13]: ./media/storage-table-design-guide/storage-table-design-IMAGE13.png
[14]: ./media/storage-table-design-guide/storage-table-design-IMAGE14.png
[15]: ./media/storage-table-design-guide/storage-table-design-IMAGE15.png
[16]: ./media/storage-table-design-guide/storage-table-design-IMAGE16.png
[17]: ./media/storage-table-design-guide/storage-table-design-IMAGE17.png
[18]: ./media/storage-table-design-guide/storage-table-design-IMAGE18.png
[19]: ./media/storage-table-design-guide/storage-table-design-IMAGE19.png
[20]: ./media/storage-table-design-guide/storage-table-design-IMAGE20.png
[21]: ./media/storage-table-design-guide/storage-table-design-IMAGE21.png
[22]: ./media/storage-table-design-guide/storage-table-design-IMAGE22.png
[23]: ./media/storage-table-design-guide/storage-table-design-IMAGE23.png
[24]: ./media/storage-table-design-guide/storage-table-design-IMAGE24.png
[25]: ./media/storage-table-design-guide/storage-table-design-IMAGE25.png
[26]: ./media/storage-table-design-guide/storage-table-design-IMAGE26.png
[27]: ./media/storage-table-design-guide/storage-table-design-IMAGE27.png
[28]: ./media/storage-table-design-guide/storage-table-design-IMAGE28.png
[29]: ./media/storage-table-design-guide/storage-table-design-IMAGE29.png

