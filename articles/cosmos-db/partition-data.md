---
title: Секционирование и горизонтальное масштабирование в базе данных Azure Cosmos DB
description: Сведения о работе секционирования в базе данных Azure Cosmos DB, настройке секционирования и ключей секций, а также о выборе подходящего ключа секции для вашего приложения.
services: cosmos-db
author: SnehaGunda
manager: kfile
documentationcenter: ''
ms.assetid: cac9a8cd-b5a3-4827-8505-d40bb61b2416
ms.service: cosmos-db
ms.workload: data-services
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 04/14/2018
ms.author: rimman
ms.custom: H1Hack27Feb2017
ms.openlocfilehash: 35636543ac4cbd260e9db2f6ca5d1548a7329858
ms.sourcegitcommit: fa493b66552af11260db48d89e3ddfcdcb5e3152
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2018
---
# <a name="partition-and-scale-in-azure-cosmos-db"></a>Секционирование и масштабирование в Azure Cosmos DB

[Azure Cosmos DB](https://azure.microsoft.com/services/cosmos-db/) — это глобально распределенная, многомодельная служба базы данных, предназначенная для обеспечения высокой и прогнозируемой производительности. Она легко масштабируется по мере расширения вашего приложения. В этой статье представлены сведения о работе секционирования для всех моделей данных в Azure Cosmos DB. В ней также описывается настройка контейнеров Azure Cosmos DB для эффективного масштабирования приложений.

В этом видео обсуждается секционирование и ключи секций:

> [!VIDEO https://www.youtube.com/embed/SS6WrQ-HJ30]
> 

## <a name="partitioning-in-azure-cosmos-db"></a>Секционирование в базе данных Azure Cosmos DB
В базе данных Azure Cosmos DB можно хранить данные без схемы и запрашивать их, получая ответ с задержкой в миллисекундах вне зависимости от масштаба. Azure Cosmos DB предоставляет контейнеры для хранения данных, которые называются *коллекциями* (для документов), *графами* или *таблицами*. 

Контейнеры — это логические ресурсы, они могут включать в себя одну или несколько физических секций или серверов. Число секций определяется Azure Cosmos DB по размеру хранилища и пропускной способности, выделенной для контейнера. 

*Физическая* секция — это фиксированное количество зарезервированного хранилища на основе SSD. Каждая физическая секция реплицируется для обеспечения высокого уровня доступности. Одна или несколько физических секций составляют контейнер. Управление физическими секциями полностью осуществляется Azure Cosmos DB, и нет необходимости создавать сложный код или управлять секциями. Контейнеры Azure Cosmos DB не ограничены в плане хранения и пропускной способности. 

*Логическая* секция — это секция в пределах физической, которая хранит все данные, связанные со значением ключа одной секции. Несколько логических секций могут оказаться в одной физической секции. На следующей схеме изображен контейнер с тремя логическими секциями. Каждая логическая секция хранит данные для одного ключа секции (LAX, AMS и MEL соответственно). Каждая из этих секций не может превышать максимальный предел — 10 ГБ. 

![Секционирование ресурсов](./media/introduction/azure-cosmos-db-partitioning.png) 

Если контейнер соответствует [требованиям секционирования](#prerequisites), секционирование будет полностью прозрачно для вашего приложения. Azure Cosmos DB поддерживает высокую скорость чтения и записи, запросы, логику транзакции, уровни согласованности и точное управление доступом с помощью методов и API для одного ресурса контейнера. Служба обрабатывает распределение данных в физических и логических секциях, а также направляет запросы в нужную секцию. 

## <a name="how-does-partitioning-work"></a>Как работает секционирование

Как работает секционирование Каждый элемент должен иметь *ключ секции* и *ключ строки*, которые однозначно идентифицируют его. Ключ секции выступает в качестве логической секции для ваших данных и предоставляет Azure Cosmos DB естественную границу для распределения данных между физическими секциями. Данные для одной логической секции должны находиться внутри одной физической секции, но управляет физической секцией Azure Cosmos DB. 

Вот как работает секционирование в Azure Cosmos DB:

* Вы подготавливаете контейнер Azure Cosmos DB с пропускной способностью **T** единиц запросов в секунду.
* В это время Azure Cosmos DB подготавливает необходимое число секций для обслуживания **T** запросов в секунду. Если **T** больше, чем максимальная пропускная способность на секцию **t**, Azure Cosmos DB подготавливает такое количество секций: **N = T/t**. Значение максимальной пропускной способности каждой секции (t) настраивает служба Azure Cosmos DB. Оно присваивается, исходя из общей подготовленной пропускной способности и используемой конфигурации оборудования. 
* Azure Cosmos DB распределяет пространство хэшей ключей секций равномерно по **N** секциям. Таким образом, каждая секция (физическая секция) содержит значения ключа секции **1/N** (логические секции).
* Когда физическая секция **p** достигает предельного размера хранилища, база данных Cosmos DB разделяет **p** на две новые секции (**p1** и **p2**). и распределяет значения, соответствующие примерно половине ключей, в каждую из новых секций. Эта операция разделения полностью незаметна для вашего приложения. Если физическая секция достигает предела размера хранилища, и все данные в ней принадлежат одному и тому же ключу логической секции, операция разделения не выполняется. Это связано с тем, что все данные для одного ключа логической секции должны находиться в одной физической секции. В этом случае следует использовать другую стратегию ключа секций.
* Когда вы подготавливаете пропускную способность выше **t*N**, Azure Cosmos DB разбивает одну или несколько секций для поддержки более высокой пропускной способности.

Семантика для ключей секций несколько отличается, чтобы соответствовать семантике каждого API, как показано в следующей таблице.

| API | Ключ секции | Ключ строки. |
| --- | --- | --- |
| SQL | Пользовательский путь к ключу секции | Фиксированное значение `id` | 
| MongoDB | Пользовательский общий ключ  | Фиксированное значение `_id` | 
| Gremlin | Свойство пользовательского ключа секции | Фиксированное значение `id` | 
| Таблица | Фиксированное значение `PartitionKey` | Фиксированное значение `RowKey` | 

Azure Cosmos DB использует секционирование на основе хэша. При написании элемента Azure Cosmos DB хэширует значение ключа секции и использует хэшированный результат, чтобы определить, в какой секции сохранить элемент. Azure Cosmos DB сохраняет все элементы с помощью одного ключа в одной физической секции. Выбор ключа секции — важное решение, которое придется принять на этапе проектирования. Необходимо выбрать имя свойства, которое имеет широкий диапазон значений и шаблоны доступа. Если физическая секция достигает предела размера хранилища, а в данных секции находится один и тот же ключ секции, Azure Cosmos DB возвращает сообщение *Partition key reached maximum size of 10 GB* (Ключ секции достиг максимального размера — 10 ГБ). При этом секция не разделяется. Поэтому выбор ключа секции — очень важное решение.

> [!NOTE]
> Мы рекомендуем иметь ключ секции с большим количеством уникальных значений (т. е. сотнями и тысячами). Это позволяет равномерно распределять рабочую нагрузку по этим значениям. Идеальный ключ секции — это тот, который часто отображается в качестве фильтра в запросах и обеспечивает достаточную кратность, чтобы гарантировать масштабируемость решения.
>

Контейнеры Azure Cosmos DB могут быть созданы на портале Azure как *фиксированные* или *неограниченные*. Контейнеры фиксированного размера имеют максимальный размер в 10 ГБ и пропускную способность в 10 000 ЕЗ в секунду. Чтобы создать контейнер неограниченного размера, необходимо указать ключ секции и минимальную пропускную способность в 1000 ЕЗ в секунду. 

Хорошая идея — проверять распределение данных в секциях. Чтобы сделать это на портале, перейдите к учетной записи Azure Cosmos DB и щелкните **Метрики** в разделе **Мониторинг**, а затем щелкните вкладку **Хранилище**, чтобы увидеть, как данные секционированы в разных физических секциях.

![Секционирование ресурсов](./media/partition-data/partitionkey-example.png)

На рисунке слева вверху показан результат неэффективного ключа секции, а на рисунке справа вверху — когда был выбран результат эффективного ключа секции. На рисунке слева видно, что данные неравномерно распределены между секциями. Постарайтесь выбрать ключ секции, который распределяет данные так, чтобы они выглядели примерно, как на изображении справа.

<a name="prerequisites"></a>
## <a name="prerequisites-for-partitioning"></a>Предварительные требования для секционирования

Для автоматического разделения физических секций на **p1** и **p2**, как описано в разделе [выше](#how-does-partitioning-work), необходим контейнер с пропускной способностью 1000 ЕЗ/с или больше и ключ секции. Чтобы воспользоваться преимуществами неограниченного масштабирования, при создании контейнера (коллекции, графа или таблицы) на портале Azure для емкости хранилища выберите значение **Без ограничений**. 

Если вы создали контейнер на портале Azure или программно, а начальная пропуская способность составляет 1000 ЕЗ в секунду или больше и предоставили ключ секции, вы можете использовать неограниченное масштабирование без каких-либо изменений в вашем контейнере. Сюда входят **фиксированные** контейнеры при условии, что начальный контейнер был создан с пропускной способностью не менее 1000 ЕЗ в секунду и ключ секции указан.

Если вы создали **фиксированный** контейнер без ключа секции или с пропускной способностью менее 1000 ЕЗ в секунду, он не будет автоматически масштабироваться, как описано в этой статье. Чтобы перенести данные из подобного контейнера в контейнер неограниченного размера (с ключом секции и пропускной способностью не менее 1000 ЕЗ в секунду), вам нужно использовать [средство миграции данных](import-data.md) или [библиотеку канала изменений](change-feed.md). 

## <a name="partitioning-and-provisioned-throughput"></a>Секционирование и подготовленная пропускная способность
Azure Cosmos DB предназначен для обеспечения прогнозируемой производительности. Создавая контейнер, вы резервируете пропускную способность в *[единицах запросов](request-units.md) (ЕЗ) в секунду*. На каждый запрос расходуется определенное число единиц запроса, пропорциональное объему системных ресурсов, например ЦП, память, и операций ввода-вывода, потребляемых операцией. Чтение документа размером 1 КБ с согласованностью сеанса потребляет 1 единицу запроса. На операцию чтения требуется 1 единица запроса вне зависимости от числа хранящихся элементов или количества параллельных запросов, выполняемых одновременно. Элементы большего размера требуют больше единиц запроса. Если вы знаете размер сущностей и количество операций чтения, необходимых для работы вашего приложения, то можете подготовить точную величину пропускной способности, необходимую приложению. 

> [!NOTE]
> Чтобы полностью использовать пропускную способность, выделенную для контейнера, необходимо выбрать ключ секции, который позволяет равномерно распределять запросы по нескольким разным значениям ключа секции.
> 
> 

<a name="designing-for-partitioning"></a>
## <a name="work-with-the-azure-cosmos-db-apis"></a>Работа с API Azure Cosmos DB
Вы можете использовать портал Azure или Azure CLI для создания контейнеров и их масштабирования в любое время. В этом разделе показано, как создать контейнеры и указать подготовленную пропускную способность и ключ секции в каждом API.


### <a name="sql-api"></a>API-интерфейс SQL
В следующем примере показано, как создать контейнер (коллекцию) с помощью API SQL. 

```csharp
DocumentClient client = new DocumentClient(new Uri(endpoint), authKey);
await client.CreateDatabaseAsync(new Database { Id = "db" });

DocumentCollection myCollection = new DocumentCollection();
myCollection.Id = "coll";
myCollection.PartitionKey.Paths.Add("/deviceId");

await client.CreateDocumentCollectionAsync(
    UriFactory.CreateDatabaseUri("db"),
    myCollection,
    new RequestOptions { OfferThroughput = 20000 });
```

Вы можете считать элемент (документ) с помощью метода `GET` в REST API или `ReadDocumentAsync` в одном из пакетов SDK.

```csharp
// Read document. Needs the partition key and the ID to be specified
DeviceReading document = await client.ReadDocumentAsync<DeviceReading>(
  UriFactory.CreateDocumentUri("db", "coll", "XMS-001-FE24C"), 
  new RequestOptions { PartitionKey = new PartitionKey("XMS-0001") });
```

Дополнительные сведения см. в статье [Секционирование в Azure Cosmos DB с помощью API SQL](sql-api-partition-data.md).

### <a name="mongodb-api"></a>API MongoDB
С помощью API MongoDB вы можете создать сегментированную коллекцию, используя предпочитаемый инструмент, драйвер или пакет SDK. В этом примере для создания коллекции используется оболочка Mongo.

В оболочке Mongo:

```
db.runCommand( { shardCollection: "admin.people", key: { region: "hashed" } } )
```
    
Результат:

```JSON
{
    "_t" : "ShardCollectionResponse",
    "ok" : 1,
    "collectionsharded" : "admin.people"
}
```

### <a name="table-api"></a>API таблицы

Чтобы создать таблицу с помощью API таблицы, используйте метод `CreateIfNotExists`. 

```csharp
CloudTableClient tableClient = storageAccount.CreateCloudTableClient();

CloudTable table = tableClient.GetTableReference("people");
table.CreateIfNotExists(throughput: 800);
```

Подготовленная пропускная способность задается в качестве аргумента `CreateIfNotExists`. Ключ секции неявно создается как значение `PartitionKey`. 

Следующий код позволяет извлечь одну сущность:

```csharp
// Create a retrieve operation that takes a customer entity.
TableOperation retrieveOperation = TableOperation.Retrieve<CustomerEntity>("Smith", "Ben");

// Execute the retrieve operation.
TableResult retrievedResult = table.Execute(retrieveOperation);
```
Дополнительные сведения см. в статье [Разработка с помощью API таблицы базы данных Azure Cosmos DB на языке .NET](tutorial-develop-table-dotnet.md).

### <a name="gremlin-api"></a>API Gremlin

С помощью API Gremlin можно создать контейнер, представляющий граф, на портале Azure или через Azure CLI. Кроме того, так как Azure Cosmos DB многомодельна, можно выбрать другие API для создания и масштабирования контейнера графа.

Вы можете прочитать любую вершину или ребро, используя ключ секции и идентификатор в Gremlin. Например, для графа с регионом США в качестве ключа секции и Сиэтлом в качестве ключа строки вы можете найти вершину, используя следующий синтаксис:

```
g.V(['USA', 'Seattle'])
```

Вы можете ссылаться на ребро с помощью ключа секции и строки.

```
g.E(['USA', 'I5'])
```

Дополнительные сведения см. в статье [Using a partitioned graph in Azure Cosmos DB](graph-partitioning.md) (Использование секционированного графа в Azure Cosmos DB).


<a name="designing-for-scale"></a>
## <a name="design-for-scale"></a>Проектирование с учетом возможности масштабирования
Для эффективного масштабирования базы данных Azure Cosmos DB при создании контейнера необходимо выбрать подходящий ключ секции. Есть две основные рекомендации по выбору хорошего ключа секции:

* **Ограничение для запросов и транзакций**. Выбранный ключ секции должен сбалансировать необходимость использования транзакций и требование к распределению сущностей по нескольким ключам секции для реализации масштабируемого решения. С одной стороны, можно задать один ключ секции для всех элементов, но этот вариант может ограничить масштабируемость решения. С другой стороны, можно назначить уникальный ключ секции каждому элементу. Это обеспечит высокую масштабируемость, но не позволит использовать транзакции между документами с помощью хранимых процедур и триггеров. Идеальный ключ секции позволяет применять эффективные запросы и обеспечивает достаточную кратность, чтобы гарантировать масштабируемость решения. 
* **Нет узких мест для хранения и производительности.** Важно выбрать свойство, которое обеспечивает распределение записей между различными уникальными значениями. Запросы к тому же ключу секции не могут превышать подготовленную пропускную способность, выделенную для секции, и будут ограничены по скорости. Поэтому важно выбрать ключ секции, который не создает "горячие точки" в приложении. Так как все данные для ключа отдельной секции должны храниться в пределах секции, следует избегать использования ключей секций с большими объемами данных для одного значения. 

Давайте рассмотрим несколько реальных сценариев и подходящие ключи секции для каждого:
* Если вы реализуете серверную часть профиля пользователя, то в качестве ключа секции удобно выбрать *идентификатор пользователя*.
* Если вы храните данные Интернета вещей, например состояние устройства, то в качестве ключа секции удобно выбрать *идентификатор устройства*.
* Если Azure Cosmos DB используется для ведения журнала данных временных рядов, то в качестве ключа секции удобно выбрать *имя узла* или *идентификатор процесса*.
* При использовании мультитенантной архитектуры в качестве ключа секции удобно выбрать *идентификатор клиента*.

В некоторых случаях использования (например, Интернет вещей и профили пользователей) ключ секции может быть таким же, как и *идентификатор* (ключ документа). В других случаях, например для данных временных рядов, может потребоваться ключ секции, который отличается от этого *идентификатора*.

### <a name="partitioning-and-loggingtime-series-data"></a>Секционирование и ведение журнала (данные временных рядов)
Одним из распространенных вариантов использования Azure Cosmos DB является ведение журналов и телеметрия. В этом сценарии важно выбрать подходящий ключ секции, так как может понадобиться считывать или записывать огромные объемы данных. Выбор ключа секции зависит от количества операций чтения и записи, а также типов запросов, которые предполагается выполнять. Ниже приведены некоторые советы по выбору подходящего ключа секции:

* Если ваш вариант использования подразумевает небольшое количество операций записи, накапливаемых в течение длительного срока, а также необходимость запроса по диапазонам меток времени и другим фильтрам, то в качестве ключа секции будет уместно использовать свертку метки времени, например дату. При таком подходе можно запросить все данные для указанной даты из одной секции. 
* Если в рабочей нагрузке имеются интенсивные операции записи (что является очень распространенным в этом сценарии), используйте ключ секции, который не основан на метке времени. Таким образом, Azure Cosmos DB может равномерно распределять и масштабировать операции записи в нескольких секциях. В этом случае хорошим выбором станет *имя узла*, *идентификатор процесса*, *идентификатор действия* или другое свойство с большим количеством элементов. 
* Другой подход является гибридным. В нем предусмотрено несколько контейнеров — по одному на каждый день и месяц, а ключ секции является фрагментарным свойством, таким как *имя узла*. Данный подход имеет преимущество, так как можно задать разную пропускную способность для каждого контейнера, в зависимости от периода времени и потребностей масштабирования и производительности. Например, коллекция для текущего месяца подготавливается с более высокой пропускной способностью, так как она обслуживает операции как чтения, так и записи, при этом коллекции за предыдущие месяцы имеют сниженную пропускную способность, так как обслуживают только чтение.

### <a name="partitioning-and-multitenancy"></a>Секционирование и мультитенантность
При реализации мультитенантного приложения с помощью Azure Cosmos DB существуют две популярные схемы — *один ключ секции на клиент* и *один контейнер на клиент*. Ниже приведены преимущества и недостатки каждого из методов.

* **Один ключ секции на клиент**. В этой модели клиенты совместно размещены в одном контейнере. Запросы и операции вставки для одного клиента можно выполнить с одной секцией. Кроме того, можно реализовать логику транзакций для всех элементов, относящихся к клиенту. Так как несколько клиентов совместно используют один контейнер, можно эффективнее использовать хранилище и подготовленную пропускную способность, организовав пул ресурсов для клиентов в пределах одного контейнера, а не подготавливая дополнительный запас для каждого клиента. Недостатком является отсутствие изоляции производительности каждого клиента. Увеличенная пропускная способность для обеспечения высокой производительности будет применяться ко всему контейнеру со всеми клиентами, а не для отдельного клиента.
* **Один контейнер на клиент**. В этой модели каждый клиент имеет собственный контейнер, а пропускную способность с гарантированной производительностью можно зарезервировать для каждого клиента. Эта модель является более экономичной для мультитенантных приложений с небольшим числом клиентов.

Можно использовать также гибридный подход, при котором маленькие клиенты размещаются совместно, а большие изолируются в своих собственных контейнерах.

## <a name="next-steps"></a>Дополнительная информация
В этой статье мы предоставили обзор концепций и рекомендации для масштабирования и секционирования в Azure Cosmos DB. 

* Дополнительные сведения о подготовленной пропускной способности в базе данных Azure Cosmos DB см. в [этой статье](request-units.md).
* Дополнительные сведения о глобальном распределении в базе данных Azure Cosmos DB см. в [этой статье](distribute-data-globally.md).



