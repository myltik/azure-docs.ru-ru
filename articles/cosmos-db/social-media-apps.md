---
title: 'Конструктивный шаблон Azure Cosmos DB: приложения социальных сетей | Документация Майкрософт'
description: Узнайте о конструктивном шаблоне для социальных сетей, используя гибкие возможности хранения данных Azure Cosmos DB и другие службы Azure.
keywords: Приложения социальных сетей
services: cosmos-db
author: ealsur
manager: kfile
documentationcenter: ''
ms.assetid: 2dbf83a7-512a-4993-bf1b-ea7d72e095d9
ms.service: cosmos-db
ms.workload: data-services
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 05/29/2017
ms.author: maquaran
ms.openlocfilehash: 53abefd4f3dd1f8da60b8b8efed1e7070b471383
ms.sourcegitcommit: 5b2ac9e6d8539c11ab0891b686b8afa12441a8f3
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/06/2018
---
# <a name="going-social-with-azure-cosmos-db"></a>Использование социальных сетей с помощью Azure Cosmos DB
Жизнь в сильно взаимосвязанном обществе означает, что в определенный момент вы присоединяетесь к **социальной сети**. Мы используем социальные сети, чтобы поддерживать связь с друзьями, коллегами и родными, а иногда — чтобы делиться увлечением с теми, кто разделяет ваши интересы.

Как специалисты и разработчики, мы могли задаваться вопросом, как эти сети хранят и связывают наши данные, или даже самостоятельно участвовать в создании или проектировании новой социальной сети для какой-нибудь специфической ниши рынка. Именно тогда возникает главный вопрос: как хранятся все эти данные?

Предположим, что мы создаем новую яркую социальную сеть, где наши пользователи могут публиковать статьи с сопутствующими материалами, например изображениями, видео или даже музыкой. Пользователи могут комментировать записи и оценивать их с помощью очков. В сети будет веб-канал записей, которые пользователи смогут видеть, также они смогут взаимодействовать с целевой страницей основного веб-сайта. Все выглядит не очень сложным (сначала), но для простоты давайте остановимся на этом (можно углубиться в настраиваемые пользовательские веб-каналы, на которые влияют связи, но это не входит в задачи этой статьи).

Итак, как все это хранить и где?

Многие из вас могут иметь опыт работы с базами данных SQL или хотя бы иметь понятие о [реляционном моделировании данных](https://en.wikipedia.org/wiki/Relational_model) , и вам не терпится начать рисовать примерно следующее.

![Схема, иллюстрирующая относительную реляционную модель](./media/social-media-apps/social-media-apps-sql.png) 

Идеально нормализованная и аккуратная структура данных… которая не масштабируется. 

Не поймите меня неправильно, я всю жизнь работал с базами данных SQL. Они удобны, но, как и в случае с любой методикой, практикой и программной платформой, они не подходят идеально для всех сценариев.

Почему SQL — не наилучший вариант для этого сценария? Рассмотрим структуру одной записи. Чтобы показать эту запись на веб-сайте или в приложения, мне потребовалось бы сделать запрос с… 8 соединениями таблиц (!) только для того, чтобы показать одну запись. Теперь представьте поток записей, которые динамически загружаются и отображаются на экране, и вы поймете, о чем я.

Конечно, мы могли бы использовать огромный экземпляр SQL с вычислительной мощностью, достаточной для обработки тысяч запросов с этим количеством соединений, чтобы обслуживать наше содержимое, но для чего тогда существует более простое решение?

## <a name="the-nosql-road"></a>Путь NoSQL
Эта статья содержит рекомендации по экономичному моделированию данных социальной платформы с помощью базы данных NoSQL Azure, [Azure Cosmos DB](https://azure.microsoft.com/services/cosmos-db/), и использованию других возможностей базы данных Azure Cosmos DB, таких как [API Gremlin Graph](../cosmos-db/graph-introduction.md). Используя [NoSQL](https://en.wikipedia.org/wiki/NoSQL), храня данные в формате JSON и применяя [денормализацию](https://en.wikipedia.org/wiki/Denormalization), нашу запись, которая ранее представлялась сложной, можно преобразовать в один [документ](https://en.wikipedia.org/wiki/Document-oriented_database).


    {
        "id":"ew12-res2-234e-544f",
        "title":"post title",
        "date":"2016-01-01",
        "body":"this is an awesome post stored on NoSQL",
        "createdBy":User,
        "images":["http://myfirstimage.png","http://mysecondimage.png"],
        "videos":[
            {"url":"http://myfirstvideo.mp4", "title":"The first video"},
            {"url":"http://mysecondvideo.mp4", "title":"The second video"}
        ],
        "audios":[
            {"url":"http://myfirstaudio.mp3", "title":"The first audio"},
            {"url":"http://mysecondaudio.mp3", "title":"The second audio"}
        ]
    }

И его можно получить с помощью одного запроса без каких-либо операций соединения. Это намного проще, эффективнее и экономнее, и для достижения наилучшего результата требуется меньше ресурсов.

Azure Cosmos DB обеспечивает индексирование всех свойств с помощью автоматического индексирования, которое даже можно [настроить](indexing-policies.md). Эта методика без использования схемы позволяет хранить документы с различными динамическими структурами. Возможно, завтра нам понадобятся записи со списком категорий или хэштегами, связанными с ними. Cosmos DB будет обрабатывать новые документы с помощью добавленных атрибутов, и для этого нам не придется ничего делать дополнительно.

Комментарии к записи можно считать такими же записями, но со свойством родительской записи (это упрощает сопоставление объектов). 

    {
        "id":"1234-asd3-54ts-199a",
        "title":"Awesome post!",
        "date":"2016-01-02",
        "createdBy":User2,
        "parent":"ew12-res2-234e-544f"
    }

    {
        "id":"asd2-fee4-23gc-jh67",
        "title":"Ditto!",
        "date":"2016-01-03",
        "createdBy":User3,
        "parent":"ew12-res2-234e-544f"
    }

И все взаимодействия в социальной сети могут храниться в отдельном объекте как счетчики.

    {
        "id":"dfe3-thf5-232s-dse4",
        "post":"ew12-res2-234e-544f",
        "comments":2,
        "likes":10,
        "points":200
    }

Создание веб-каналов — это просто создание документов, которые могут содержать список идентификаторов записей в указанном порядке релевантности.

    [
        {"relevance":9, "post":"ew12-res2-234e-544f"},
        {"relevance":8, "post":"fer7-mnb6-fgh9-2344"},
        {"relevance":7, "post":"w34r-qeg6-ref6-8565"}
    ]

Мы можем создать поток "Последние" с сообщениями, упорядоченными по дате создания, а также поток "Популярные" с записями, которые понравились наибольшему числу пользователей за последние 24 часа. Мы даже можем реализовать настраиваемый поток для каждого пользователя, например, основанный на логике, учитывающей число подписчиков и интересы, и все равно это будет список записей. Важно то, как создаются эти списки, а производительность чтения остается неизменной. Получив один из этих списков, мы выполним один запрос к Cosmos DB с помощью [оператора IN](sql-api-sql-query.md#WhereClause), чтобы получить сразу несколько страниц записей.

Потоки веб-канала можно создать с использованием фоновых процессов [служб приложений Azure](https://azure.microsoft.com/services/app-service/) — [веб-заданий](../app-service/web-sites-create-web-jobs.md). После создания записи фоновую обработку можно активировать с помощью [очередей](https://azure.microsoft.com/services/storage/) [службы хранилища Azure](../storage/queues/storage-dotnet-how-to-use-queues.md), а веб-задания можно активировать с помощью [пакета SDK веб-заданий](https://github.com/Azure/azure-webjobs-sdk/wiki), реализовав распространение записей в потоках на основе собственной настраиваемой логики. 

Очки и отметки "Нравится" записи могут обрабатываться с отсрочкой, этот же подход применяется для создания согласованной среды.

С читателями все сложнее. В Cosmos DB действует ограничение максимального размера документа, и операции чтения или записи с большими документами могут повлиять на масштабируемость приложения. Поэтому можно рассмотреть хранение читателей в документе со следующей структурой.

    {
        "id":"234d-sd23-rrf2-552d",
        "followersOf": "dse4-qwe2-ert4-aad2",
        "followers":[
            "ewr5-232d-tyrg-iuo2",
            "qejh-2345-sdf1-ytg5",
            //...
            "uie0-4tyg-3456-rwjh"
        ]
    }

Это может подойти для пользователя с несколькими тысячами читателей, но если к нам присоединится какая-либо знаменитость, то при данном подходе размер документа увеличится и мы все равно натолкнемся на ограничение размера.

Чтобы решить эту задачу, мы используем смешанный подход. В документе статистики пользователей мы можем хранить количество читателей.

    {
        "id":"234d-sd23-rrf2-552d",
        "user": "dse4-qwe2-ert4-aad2",
        "followers":55230,
        "totalPosts":452,
        "totalPoints":11342
    }

Фактический граф подписчиков можно хранить с помощью [API Gremlin Graph](../cosmos-db/graph-introduction.md) базы данных Azure Cosmos DB. При этом создаются [вершины](http://mathworld.wolfram.com/GraphVertex.html) для каждого пользователя и [грани](http://mathworld.wolfram.com/GraphEdge.html), поддерживающие отношения "А подписан на Б". API Graph позволяет вам не только получать подписчиков конкретного пользователя, но и создавать более сложные запросы, предлагающие пользователей с некоторыми общими характеристиками. Если добавить в граф категории содержимого, которые "нравятся" пользователям, мы сможем добавить возможности связывания, включая интеллектуальное обнаружение содержимого, предложение содержимого, интересующего пользователей, на которых мы подписаны, или поиск людей, с которыми мы можем иметь общие интересы.

С помощью документа "Статистика пользователей" также можно создавать карточки в пользовательском интерфейсе или просматривать краткие профили.

## <a name="the-ladder-pattern-and-data-duplication"></a>Дублирование данных и шаблон "Лестница"
Как можно заметить, в документе JSON, на который ссылается запись, существует несколько вхождений данных пользователя. Как вы уже догадались, это означает, что данные, представляющие пользователя (с учетом денормализации), могут находиться в нескольких местах.

Чтобы ускорить обработку запросов, мы применяем дублирование данных. Побочный эффект состоит в том, что если какое-либо действие меняет данные пользователя, нам нужно найти все действия, которые он когда-либо выполнил, и обновить их. Звучит не слишком практично, верно?

Мы решим эту проблему, определив ключевые атрибуты пользователя, которые отображаются в нашем приложении для каждого действия. Если мы показываем запись в приложении только с именем и изображением автора, зачем хранить в атрибуте createdBy все данные пользователя? Если для каждого комментария мы показываем только изображение пользователя, остальные его данные не нужны. Вот когда нам пригодится то, что я называю шаблоном "Лестница".

Для примера рассмотрим информацию о пользователе.

    {
        "id":"dse4-qwe2-ert4-aad2",
        "name":"John",
        "surname":"Doe",
        "address":"742 Evergreen Terrace",
        "birthday":"1983-05-07",
        "email":"john@doe.com",
        "twitterHandle":"@john",
        "username":"johndoe",
        "password":"some_encrypted_phrase",
        "totalPoints":100,
        "totalPosts":24
    }

Посмотрев на эту информацию, мы можем быстро определить, какая информация важна, а какая — нет, тем самым строя "лестницу".

![Схема шаблона "Лестница"](./media/social-media-apps/social-media-apps-ladder.png)

Наименьший объект называется блоком пользователя, это минимальный объем информации, идентифицирующий пользователя и используемый для дублирования данных. Уменьшая размер дублируемых данных только до "видимой" информации, мы снизим вероятность масштабных обновлений.

Средний объект называется пользователем, это полные данные, которые будут использоваться в большинстве зависящих от производительности запросов в Cosmos DB. Это наиболее используемые и важные данные. Пользователь содержит информацию, представленную в блоке пользователя.

Самый большой объект — расширенный пользователь. Он содержит все критически важные данные пользователя, а также другие данные, которые не требуется очень быстро считывать или которые используются при определенных условиях (например, при входе в систему). Эти данные могут храниться за пределами Cosmos DB, в базе данных SQL Azure или таблицах хранилища Azure.

Зачем разделять данные пользователя и хранить эту информацию в разных местах? Это необходимо, поскольку с точки зрения производительности, чем больше документы, тем дороже обходятся запросы. Используйте небольшие документы, содержащие только данные, необходимые для выполнения всех зависящих от производительности запросов для социальной сети, и храните отдельно дополнительные данные, которые используются при определенных условиях, например для полного изменения профилей, входа в систему и даже интеллектуального анализа данных для получения аналитики по использованию и инициатив по большим данным. Нам действительно не важно, если сбор данных для интеллектуального анализа данных идет медленнее, так как выполняется в базе данных SQL Azure. Зато нам важно обеспечить быстрое и удобное взаимодействие с пользователями. Данные пользователя, хранящиеся в Cosmos DB, будут выглядеть следующим образом.

    {
        "id":"dse4-qwe2-ert4-aad2",
        "name":"John",
        "surname":"Doe",
        "username":"johndoe"
        "email":"john@doe.com",
        "twitterHandle":"@john"
    }

И запрос POST будет выглядеть следующим образом.

    {
        "id":"1234-asd3-54ts-199a",
        "title":"Awesome post!",
        "date":"2016-01-02",
        "createdBy":{
            "id":"dse4-qwe2-ert4-aad2",
            "username":"johndoe"
        }
    }

И в случае изменения, затрагивающего один из атрибутов блока, несложно найти требуемые документы с помощью запросов, которые указывают на индексированные атрибуты (SELECT * FROM posts p WHERE p.createdBy.id == “edited_user_id”), и затем обновить эти блоки.

## <a name="the-search-box"></a>Поле поиска
К счастью, пользователи будут формировать много содержимого. И мы должны дать возможность искать и находить содержимое, которое может отсутствовать непосредственно в их потоках содержимого, возможно, потому, что они не подписались на их авторов или просто пытаются найти старую запись, созданную 6 месяцев назад.

Благодаря тому, что мы используем Azure Cosmos DB, мы можем всего за несколько минут легко реализовать механизм поиска с помощью [Поиска Azure](https://azure.microsoft.com/services/search/), не вводя ни одной строки кода (кроме, разумеется, процесса поиска и пользовательского интерфейса).

Почему это так просто?

Поиск Azure реализует так называемые [индексаторы](https://msdn.microsoft.com/library/azure/dn946891.aspx), фоновые процессы, которые привязываются к репозиториям данных и автоматически добавляют, обновляют или удаляют объекты в индексах. Они поддерживают [индексаторы базы данных SQL Azure](https://blogs.msdn.microsoft.com/kaevans/2015/03/06/indexing-azure-sql-database-with-azure-search/), [индексаторы больших двоичных объектов Azure](../search/search-howto-indexing-azure-blob-storage.md) и, к счастью, [индексаторы Azure Cosmos DB](../search/search-howto-index-documentdb.md). Переместить информацию из Cosmos DB в службу поиска Azure просто, так как и там, и там она хранится в формате JSON, и нам нужно просто [создать индекс](../search/search-create-index-portal.md) и сопоставить атрибуты из документов, которые мы хотим индексировать. Через нескольких минут (зависит от размера данных) все наше содержимое будет доступно для поиска с использованием лучшего решения "поиска как услуги" в облачной инфраструктуре. 

Дополнительные сведения о Поиске Azure см. в статье [Hitchhiker’s Guide to Search](https://blogs.msdn.microsoft.com/mvpawardprogram/2016/02/02/a-hitchhikers-guide-to-search/) (Автостопом по поиску).

## <a name="the-underlying-knowledge"></a>Базовый набор знаний
Храня все это содержимое, которое ежедневно увеличивается, мы можем задуматься: что делать с потоком информации, поступающей от моих пользователей?

Ответ прост: включить его в работу и учиться.

Но как мы можем учиться? Из простых примеров можно привести [анализ тональности](https://en.wikipedia.org/wiki/Sentiment_analysis), т. е. рекомендации содержимого на основе предпочтений пользователя, или даже автоматический модератор содержимого, который гарантирует, что все содержимое, публикуемое в нашей социальной сети, безопасно для семьи.

Теперь, когда я заинтересовал вас, скорее всего вы думаете, что нужна кандидатская степень по математике, чтобы извлечь эти шаблоны и информацию из простых баз данных и файлов, но это не так.

[Машинное обучение Azure](https://azure.microsoft.com/services/machine-learning/), являющееся частью [Cortana Intelligence Suite](https://www.microsoft.com/en/server-cloud/cortana-analytics-suite/overview.aspx), — это полностью управляемая облачная служба, которая позволяет создавать рабочие процессы с помощью алгоритмов, используя простой интерфейс с перетаскиванием, а также позволяет программировать собственные алгоритмы на [R](https://en.wikipedia.org/wiki/R_\(programming_language\)) или использовать некоторые встроенные и готовые к использованию API, например API [текстовой аналитики](https://gallery.cortanaanalytics.com/MachineLearningAPI/Text-Analytics-2), API [модератора содержимого](https://www.microsoft.com/moderator) или API [рекомендаций](https://gallery.cortanaanalytics.com/MachineLearningAPI/Recommendations-2).

Чтобы реализовать любой из этих сценариев машинного обучения, можно использовать [Azure Data Lake](https://azure.microsoft.com/services/data-lake-store/) для приема информации из различных источников и [U-SQL](https://azure.microsoft.com/documentation/videos/data-lake-u-sql-query-execution/) — для обработки данных и формирования выходных данных, которые могут быть обработаны Машинным обучением Azure.

Другим доступным вариантом для анализа содержимого наших пользователей является использование [Microsoft Cognitive Services](https://www.microsoft.com/cognitive-services). Мы можем не только лучше понять их (анализируя с помощью [API текстовой аналитики](https://www.microsoft.com/cognitive-services/en-us/text-analytics-api), что они пишут), но и обнаружить нежелательное содержимое или содержимое для взрослых и действовать соответствующим образом, используя [API компьютерного зрения](https://www.microsoft.com/cognitive-services/en-us/computer-vision-api). Службы Cognitive Services включают в себя много готовых решений, для использования которых не требуется никаких знаний Машинного обучения.

## <a name="a-planet-scale-social-experience"></a>Глобально масштабируемое социальное взаимодействие
Последняя, но совсем не маловажная тема, которую необходимо рассмотреть, — **масштабируемость**. При разработке архитектуры очень важно обеспечить, чтобы каждый компонент мог масштабироваться самостоятельно. Нам это нужно, когда требуется обработать больше данных или когда требуется обеспечить большее географическое покрытие (или оба этих случая). К счастью, решение такой сложной задачи **уже заложено** в Cosmos DB.

Cosmos DB поддерживает заранее реализованное [динамическое секционирование](https://azure.microsoft.com/blog/10-things-to-know-about-documentdb-partitioned-collections/), автоматически создавая секции на основе заданного **ключа секции** (определяется как один из атрибутов в документах). Определение правильного ключа секции должно выполняться во время разработки и учитывать доступные [рекомендации](../cosmos-db/partition-data.md#designing-for-partitioning). При социальном взаимодействии ваша стратегия секционирования должна согласовываться с тем, как вы выполняете запросы (предпочтительно операции чтения в одной секции ) и записи (предотвращая формирование "активных областей" за счет распределения записей по нескольким секциям). Вот некоторые из параметров: секции, основанные на временном ключе (день/месяц/неделя), по категории содержимого, по географическому региону, по пользователю. Все действительно зависит от того, как вы запрашиваете данные и показываете их при социальном взаимодействии. 

Стоит обратить внимание на один интересный момент: Cosmos DB будет прозрачно выполнять ваши запросы (включая [статистические выражения](https://azure.microsoft.com/blog/planet-scale-aggregates-with-azure-documentdb/)) по всем секциям, и вам не нужно добавлять какую-либо логику по мере роста объема данных.

Со временем у вас, очевидно, увеличится трафик и потребление ресурсов (измеряемое в единицах запроса, [ЕЗ](request-units.md)). Операции чтения и записи станут более частыми по мере роста вашей базы пользователей и начнут создавать и потреблять больше содержимого. Поэтому возможность **масштабирования пропускной способности** крайне важна. Увеличить количество ЕЗ очень легко. Это можно сделать, нажав несколько кнопок на портале Azure или [выполнив команды через интерфейс API](https://docs.microsoft.com/rest/api/cosmos-db/replace-an-offer).

![Увеличение масштаба и определение ключа секции](./media/social-media-apps/social-media-apps-scaling.png)

Предположим, что ваши результаты улучшаются, и пользователи из другого региона, страны или континента обратили внимание на вашу платформу и начали ее использовать. Приятный сюрприз!

Но что произойдет дальше? Скоро вы понимаете, что их взаимодействие с вашей платформой не оптимально. Они находятся так далеко от вашего рабочего региона, что испытывают ужасные задержки. А вы, конечно, не хотите, чтобы они сменили вашу платформу на другую. Было бы очень удобно иметь возможность **охватить весь мир**... И такая возможность есть!

Cosmos DB позволяет [реплицировать данные глобально](../cosmos-db/tutorial-global-distribution-sql-api.md) и прозрачно всего парой щелчков мышью, а также автоматически выбирать из [клиентского кода](../cosmos-db/tutorial-global-distribution-sql-api.md) доступные регионы. Это также означает, что у вас может быть [несколько регионов отработки отказа](regional-failover.md). 

При глобальной репликации данных необходимо убедиться, что ваши клиенты могут этим воспользоваться. Если вы используете веб-интерфейс или получаете доступ к API с мобильных клиентов, то вы можете развернуть [диспетчер трафика Azure](https://azure.microsoft.com/services/traffic-manager/) и клонировать свою службу приложений Azure во всех необходимых регионах, используя конфигурацию производительности для поддержки расширенного глобального покрытия. При обращении ваших клиентов к интерфейсу или API они будут направляться в ближайшую службу приложений, которая, в свою очередь, будет подключаться к локальной реплике Cosmos DB.

![Добавление глобального покрытия в социальную платформу](./media/social-media-apps/social-media-apps-global-replicate.png)

## <a name="conclusion"></a>Заключение
В этой статье я попытался пролить свет на возможности создания социальных сетей полностью на платформе Azure с помощью недорогих служб, что дает превосходные результаты, поощряя к использованию решения для многоуровневого хранения данных и распределения данных, которое называется "Лестница".

![Схема взаимодействия между службами Azure для социальных сетей](./media/social-media-apps/social-media-apps-azure-solution.png)

Дело в том, что не существует единственно верного решения для таких сценариев. Это синергия отличных служб, обеспечивающих качественную работу: скорость и свобода Azure Cosmos DB для создания отличного приложения социальных сетей, интеллектуальность первоклассного решения для поиска (например, Поиска Azure), гибкость служб приложений Azure для размещения не только языконезависимых приложений, но и мощных фоновых процессов; расширяемая служба хранилища Azure и база данных SQL Azure для хранения больших объемов данных, большие аналитические возможности машинного обучения Azure для формирования знаний и аналитики, позволяющих получать отзывы о наших процессах и доставлять пользователям именно то содержимое, которое им нужно.

## <a name="next-steps"></a>Дополнительная информация
Дополнительные сведения о вариантах использования Cosmos DB см. в [этой статье](use-cases.md).