---
title: Как создать приложение, в которое может войти любой пользователь Azure AD
description: В статье показано, как создать мультитенантное приложение, в которое может войти пользователь c любого клиента Azure Active Directory.
services: active-directory
documentationcenter: ''
author: CelesteDG
manager: mtillman
editor: ''
ms.assetid: 35af95cb-ced3-46ad-b01d-5d2f6fd064a3
ms.service: active-directory
ms.component: develop
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: identity
ms.date: 04/27/2018
ms.author: celested
ms.reviewer: elisol
ms.custom: aaddev
ms.openlocfilehash: fd02cde6327cb929d1b4c0c2e3d430d64645ca26
ms.sourcegitcommit: e14229bb94d61172046335972cfb1a708c8a97a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/14/2018
ms.locfileid: "34157379"
---
# <a name="how-to-sign-in-any-azure-active-directory-user-using-the-multi-tenant-application-pattern"></a>Как реализовать вход любого пользователя Azure Active Directory с помощью шаблона мультитенантного приложения
Если вы предлагаете приложение "программное обеспечение как сервис" для многих организаций, то можете настроить приложение таким образом, чтобы оно поддерживало вход из любого клиента Azure AD (AD). Это и называется "сделать приложение мультитенантным". Пользователи из любого клиента Azure AD смогут входить в приложение после того, как согласятся использовать свою учетную запись с вашим приложением. 

Если у вас есть приложение, которое имеет собственную систему учетных записей или поддерживает вход с помощью других поставщиков облачных служб, добавить вход в Azure AD с любого клиента не составит труда. Просто зарегистрируйте свое приложение, добавьте код входа через OAuth2, OpenID Connect или SAML и поместите [кнопку "Вход с учетной записью Майкрософт"][AAD-App-Branding] в свое приложение.

> [!NOTE] 
> В этой статье предполагается, что вы уже знакомы с процессом создания однотенантного приложения для Azure AD. Если у вас нет приложения, начните с одного из шаблонов запуска, представленных на [домашней странице руководства для разработчиков][AAD-Dev-Guide].

Преобразовать приложение в мультитенантное приложение Azure AD можно с помощью четырех простых шагов:

1. [Измените тип регистрации вашего приложения на мультитенантную.](#update-registration-to-be-multi-tenant)
2. [Обновите код для отправки запросов в конечную точку /common.](#update-your-code-to-send-requests-to-common)
3. [Обновите код для обработки нескольких значений издателя.](#update-your-code-to-handle-multiple-issuer-values)
4. [Изучите особенности получения согласия пользователя и администратора и внесите соответствующие изменения в код.](#understanding-user-and-admin-consent)

Давайте рассмотрим каждый из этих шагов подробнее. Вы также можете сразу перейти к [этому списку примеров кода для мультитенантных приложений][AAD-Samples-MT].

## <a name="update-registration-to-be-multi-tenant"></a>Обновление регистрации с изменением ее на мультитенантную
По умолчанию регистрация веб-приложения или API в Azure AD предусматривает работу только с одним клиентом, то есть является однотенантной. Чтобы сделать регистрацию мультитенантной, на [портале Azure][AZURE-portal] на панели **свойств** регистрации приложения найдите переключатель **Мультитенантное** и установите его в положение **Да**.

Прежде чем сделать приложение мультитенантным, убедитесь, что URI идентификатора приложения глобально уникальный согласно требованию Azure AD. URI кода приложения является одним из способов идентификации приложения в сообщениях протокола. Для приложения с одним клиентом достаточно, чтобы URI кода приложения был уникальным в рамках клиента. Для мультитенантного приложения он должен быть глобально уникальным, чтобы служба Azure AD могла найти приложение по всем клиентам. Глобальная уникальность обеспечивается за счет требования, чтобы URI кода приложения имел имя узла, соответствующее проверенному домену клиента Azure AD. По умолчанию при создании приложений с помощью портала Azure им присваивается глобальный уникальный URI идентификатор приложения, но позже это значение можно изменить.

Например, если имя клиента — contoso.onmicrosoft.com, то допустимым URI кода приложения будет `https://contoso.onmicrosoft.com/myapp`. Если проверенный домен клиента — `contoso.com`, то допустимым URI кода приложения тоже будет `https://contoso.com/myapp`. Если URI идентификатора приложения не соответствует этому шаблону, вы не сможете сделать приложение мультитенантным.

> [!NOTE] 
> Регистрации на собственных клиентах, так же как в [приложениях v2](./active-directory-appmodel-v2-overview.md), являются мультитенантными по умолчанию. Не нужно предпринимать никаких действий, чтобы зарегистрировать приложение как мультитенантное.

## <a name="update-your-code-to-send-requests-to-common"></a>Обновление кода для отправки запросов в конечную точку "/common"
В приложении с одним клиентом запросы на вход отправляются в конечную точку входа клиента. Например для contoso.onmicrosoft.com конечная точка имела бы следующий вид: `https://login.microsoftonline.com/contoso.onmicrosoft.com`

Запросы, отправленные в конечную точку клиента, могут выполнять вход пользователей (или гостей) этого клиента в приложения этого клиента. Если используется мультитенантное приложение, то оно не знает заранее, из какого клиента тот или иной пользователь, поэтому невозможно отправить запрос в конечную точку клиента. Вместо этого запросы отправляются в конечную точку, которая мультиплексируется по всем клиентам Azure AD: `https://login.microsoftonline.com/common`

Когда служба Azure AD получает запрос в конечной точке /common, она выполняет вход пользователя и, как следствие, выясняет, из какого клиента этот пользователь. Конечная точка /common работает со всеми протоколами проверки подлинности, поддерживаемыми Azure AD: OpenID Connect, OAuth 2.0, SAML 2.0 и WS-Federation.

Ответ приложению на вход содержит маркер, представляющий пользователя. Значение издателя в маркере сообщает приложению, из какого клиента этот пользователь. Когда из конечной точки "/common" возвращается ответ, значение издателя в маркере соответствует клиенту пользователя. 

> [!IMPORTANT]
> Конечная точка /common — это просто мультиплексор, а не клиент или издатель. Учитывая этот факт, при использовании "/common" логику проверки маркеров в приложении необходимо обновить. 

## <a name="update-your-code-to-handle-multiple-issuer-values"></a>Обновите код для обработки нескольких значений издателя.
Веб-приложения и веб-API получают маркеры из Azure AD и там же выполняют их проверку. 

> [!NOTE]
> А собственные клиентские приложения запрашивают и получают маркеры из Azure AD, чтобы затем отправить их в API, где они проходят проверку. Собственные приложения не проверяют маркеры и воспринимают их как непрозрачные.

Давайте посмотрим, как приложение проверяет маркеры, полученные из Azure AD. Однотенантное приложение обычно принимает такое значение конечной точки:

    https://login.microsoftonline.com/contoso.onmicrosoft.com

Оно используется для формирования URL-адреса метаданных (в данном случае — OpenID Connect), например:

    https://login.microsoftonline.com/contoso.onmicrosoft.com/.well-known/openid-configuration

С его помощью скачиваются два критически важных фрагмента данных, используемые для проверки маркеров: значение издателя и ключи подписи клиента. Каждый клиент Azure AD имеет уникальное значение издателя, которое можно представить в такой форме:

    https://sts.windows.net/31537af4-6d77-4bb9-a681-d2394888ea26/

где значение GUID — это версия кода клиента, защищенная от переименования. Если щелкнуть указанную выше ссылку на метаданные для `contoso.onmicrosoft.com`, вы увидите это значение издателя в документе.

Когда приложение с одним клиентом проверяет токен, оно сверяет подпись токена с ключами подписи из документа метаданных. Эта проверка позволяет убедиться, что значение издателя в маркере соответствует значению в документе метаданных.

Так как конечная точка /common не соответствует клиенту и не является издателем, при проверке значения издателя в метаданных для точки /common вместо фактического значения отображается шаблон URL-адреса:

    https://sts.windows.net/{tenantid}/

Таким образом, мультитенантное приложение не может проверить маркеры, просто сопоставив значение издателя в метаданных со значением `issuer` в маркере. Мультитенантному приложению требуется логика, чтобы решить, какие значения издателя являются допустимыми, а какие не являются, исходя из части значения издателя, в которой указан идентификатор клиента. 

Например, если мультитенантное приложение разрешает вход только из определенных клиентов, которые зарегистрировались в службе, то оно должно проверить значение издателя или значение утверждения `tid` в токене, чтобы убедиться, что этот клиент внесен в его список подписчиков. Если мультитенантное приложение работает только с отдельными пользователями и не принимает решений о доступе на основе данных клиентов, то оно может полностью игнорировать значение издателя.

В [примерах мультитенантных приложений][AAD-Samples-MT] проверка издателя отключена, чтобы можно было включить возможность входа для любого клиента Azure AD.

## <a name="understanding-user-and-admin-consent"></a>Получение согласия пользователя и администратора
Чтобы пользователь мог войти в приложение в Azure AD, это приложение должно быть представлено в клиенте пользователя. Это дает возможность организации применять уникальные политики входа в приложение пользователей из клиента. Регистрацию для однотенантного приложения легко выполнить. Это та же самая процедура, которая выполняется при регистрации приложения на [портале Azure][AZURE-portal].

Для мультитенантного приложения его начальная регистрация находится в клиенте Azure AD, используемом разработчиком. При первом входе в приложение пользователя из другого клиента Azure AD предлагает принять разрешения, запрошенные приложением. Если пользователь соглашается, то в его клиенте создается представление приложения, называемое *субъектом-службой*, после чего можно продолжить вход. В каталоге также создается делегирование, которое записывает согласие пользователя в приложение. Дополнительные сведения об объектах приложений и субъектов-служб и их взаимосвязи см. в статье [Объекты приложения и субъекта-службы в Azure Active Directory (Azure AD)][AAD-App-SP-Objects].

![Разрешения для одноуровневого приложения][Consent-Single-Tier] 

Для получения согласия используются разрешения, запрашиваемые приложением. Azure AD поддерживает два типа разрешений: делегированные и только для приложения.

* Делегированное разрешение предоставляет приложению возможность выступать в качестве выполнившего вход пользователя и выполнять ряд действий, доступных пользователю. Например, можно предоставить приложению делегированное разрешение на чтение календаря выполнившего вход пользователя.
* Разрешение "только для приложения" предоставляется непосредственно удостоверению приложения. Например, если предоставить приложению разрешение "только для приложения" на чтение списка пользователей в клиенте, независимо от того, кто выполнил вход в приложение.

Некоторые разрешения могут быть приняты обычным пользователем, а для других требуется согласие администратора клиента. 

### <a name="admin-consent"></a>Согласие администратора
Для разрешений "только для приложения" всегда требуется согласие администратора клиента. Если приложение запрашивает разрешение "только для приложения" и пользователь пытается войти в приложение, появится сообщение об ошибке. Это сообщение говорит о том, что пользователь не может принять это разрешение.

Для некоторых делегированных разрешений также требуется согласие администратора клиента. Например, оно требуется для возможности обратной записи в Azure AD в качестве выполнившего вход пользователя. Как и в случае с разрешениями "только для приложения", если обычный пользователь пытается войти в приложение, запрашивающее делегированное разрешение, для которого требуется согласие администратора, в приложении появится сообщение об ошибке. Требует ли разрешение согласия администратора, определяет разработчик, опубликовавший ресурс. Эти сведения можно найти в документации по данному ресурсу. В документации по разрешениям [Azure AD Graph API][AAD-Graph-Perm-Scopes] и [Microsoft Graph API][MSFT-Graph-permision-scopes] указывается, для каких разрешений требуется согласие администратора.

Если приложение использует разрешения, требующие согласия администратора, то в приложении должен быть элемент, такой как кнопка или ссылка, с помощью которого администратор может инициировать действие. Запрос, отправляемый приложением для этого действия, является обычным запросом авторизации OAuth2 или OpenID Connect, но он также включает в себя параметр строки запроса `prompt=admin_consent`. После того как администратор предоставит свое согласие, а в клиенте пользователя будет создан субъект-служба, в последующих запросах входа не нужно будет указывать параметр `prompt=admin_consent`. После того как администратор решил, что запрошенные разрешения являются приемлемыми, у других пользователей клиента согласие запрашиваться не будет.

Администратор клиента может отключить возможность обычным пользователям предоставлять согласие для приложений. Если эта возможность отключена, то для использования приложения в клиенте всегда требуется согласие администратора. Чтобы протестировать приложение, в котором отключена возможность предоставления согласия для конечных пользователей, найдите соответствующий параметр на [портале Azure][AZURE-portal], открыв раздел **Корпоративные приложения** и выбрав **[Параметры пользователя](https://portal.azure.com/#blade/Microsoft_AAD_IAM/StartboardApplicationsMenuBlade/UserSettings/menuId/)**.

Параметр `prompt=admin_consent` может использоваться приложениями, запрашивающими разрешения, которые не требуют согласия администратора. Это делается, например, в тех случаях, когда приложению требуется возможность одноразовой регистрации администратора клиента, после которой у других пользователей согласие не запрашивается.

Если приложению требуется разрешение администратора и администратор выполняет вход, но параметр `prompt=admin_consent` не передается, администратор предоставит приложению согласие **только для своей учетной записи пользователя**. Обычные пользователи по-прежнему не смогут выполнять вход и давать свое согласие приложению. Это удобно в тех случаях, когда администратору клиента нужно просмотреть приложение, прежде чем предоставлять доступ к приложению другим пользователям.

> [!NOTE]
> В некоторых приложениях применяется следующая практика: сначала свое согласие имеют возможность предоставить обычные пользователи, а затем приложение может привлечь администратора и запросить разрешения, для которых требуется его согласие. При регистрации приложения версии 1 такая возможность в Azure AD в данный момент отсутствует, однако благодаря использованию конечных точек версии 2 приложения могут запрашивать разрешения в процессе выполнения, а не во время регистрации. Это позволит реализовать указанный выше сценарий. Дополнительные сведения см. в статье [Настройка входа пользователей с помощью учетной записи Майкрософт и Azure Active Directory в одном приложении][AAD-V2-Dev-Guide].

### <a name="consent-and-multi-tier-applications"></a>Согласие и многоуровневые приложения
Приложение может иметь несколько уровней, каждый из которых представлен в Azure AD собственной регистрацией. Например, собственное приложение, выполняющее вызовы веб-API, или веб-приложение, выполняющее вызовы веб-API. В обоих случаях клиент (собственное приложение или веб-приложение) запрашивает разрешения на вызов ресурса (веб-API). Чтобы клиент мог получить согласие от клиента пользователя, все ресурсы, к которым он запрашивает разрешения, должны существовать в клиенте пользователя. Если это условие не выполняется, Azure AD выдаст ошибку и сообщит, что сначала необходимо добавить ресурс.

**Несколько уровней в одном клиенте**

Это может быть проблемой, если ваше логические приложение состоит из двух или более регистраций приложения, например, отдельно для клиента и ресурса. Как сначала поместить ресурс в клиент пользователя? На этот случай в Azure AD предусмотрена возможность получения согласия для клиента и ресурса за один шаг. Пользователь видит общее число разрешений, запрошенных клиентом и ресурсом на странице получения согласия. Чтобы активировать такое поведение, регистрация приложения ресурса должна включать в себя идентификатор приложения клиента как `knownClientApplications` в [манифесте соответствующего приложения][AAD-App-Manifest]. Например: 

    knownClientApplications": ["94da0930-763f-45c7-8d26-04d5938baab2"]

Это демонстрируется в примере многоуровневого собственного клиента, выполняющего вызов веб-API, в разделе [Связанная информация](#related-content) в конце этой статьи. На следующей схеме представлен обзор согласия для многоуровневого приложения, зарегистрированного в одном клиенте:

![Разрешения для известного многоуровневого приложения][Consent-Multi-Tier-Known-Client] 

**Несколько уровней в нескольких клиентах**

Аналогичная ситуация складывается, когда различные уровни приложения регистрируются в разных клиентах. Например, рассмотрим случай создания собственного клиентского приложения, выполняющего вызов API Office 365 Exchange Online. Для разработки собственного приложения, а затем и для его запуска в клиенте пользователя необходимо наличие субъекта-службы Exchange Online. В этом случае разработчик и пользователь должен приобрести Exchange Online, чтобы в их клиентах был создан субъект-служба. 

Если используется API, созданный не Майкрософт, а иной организацией, то разработчик API должен предоставить пользователям возможность получать согласие на связь своего приложения с клиентом пользователя. Рекомендуемая конфигурация предназначена для стороннего разработчика для создания API, который мог бы также выполнять роль веб-клиента для реализации регистрации: Для этого:

1. Выполните действия из предыдущих разделов, чтобы убедиться, что API реализует требования к регистрации и коду мультитенантного приложения.
2. Указав области и роли API, убедитесь, что регистрация включает в себя разрешение Azure AD "Вход и чтение профиля пользователя" (предоставляется по умолчанию).
3. Создайте страницу входа и регистрации в веб-клиенте, следуя инструкциям рассмотренного ранее руководства по [согласию администратора](#admin-consent).
4. После того как пользователь предоставит свое согласие в приложении, в клиенте создаются субъект-служба и ссылки на делегирование согласия, а собственное приложение может получать маркеры для API.

На следующей схеме представлен обзор согласия для многоуровневого приложения, зарегистрированного в разных клиентах:

![Разрешения для многоуровневого приложения c несколькими участниками][Consent-Multi-Tier-Multi-Party] 

### <a name="revoking-consent"></a>Отзыв согласия
Пользователи и администраторы в любой момент могут отозвать свое согласие, предоставленное приложению.

* Чтобы отозвать доступ к отдельным приложениям, пользователям необходимо удалить их из списка [Приложения панели доступа][AAD-Access-Panel].
* Администраторы могут отозвать доступ к приложениям, удалив их из Azure AD с помощью раздела [Корпоративные приложения](https://portal.azure.com/#blade/Microsoft_AAD_IAM/StartboardApplicationsMenuBlade/AllApps) на [портале Azure][AZURE-portal].

Если администратор дает свое согласие на доступ к приложению для всех пользователей в клиенте, то пользователи не могут отзывать доступ индивидуально. В этом случае отозвать доступ может только администратор и только для всего приложения.

## <a name="multi-tenant-applications-and-caching-access-tokens"></a>Мультитенантные приложения и кэширование маркеров доступа
Мультитенантные приложения также могут получать маркеры доступа для вызова API, защищенных службой Azure AD. Распространенной ошибкой при использовании библиотеки проверки подлинности Active Directory (ADAL) с мультитенантным приложением является начальный запрос маркера для пользователя с помощью конечной точки /common, получение ответа, а затем запрос последующего маркера для того же пользователя с помощью той же точки /common. Так как ответ от Azure AD приходит из клиента, а не из точки /common, то ADAL кэширует маркер как полученный из клиента. Последующий вызов точки "/common" для получения маркера доступа для пользователя не записывается в кэш (происходит промах кэша), и пользователю предлагается выполнить вход повторно. Во избежание промахов кэша убедитесь, что последующие вызовы для выполнившего вход пользователя осуществляются в конечную точку клиента.

## <a name="next-steps"></a>Дополнительная информация
В этой статье было показано, как создать приложение, поддерживающее вход пользователя с любого клиента Azure AD. После включения единого входа между своим приложением и Azure AD вы также можете обновить приложение для доступа к API, которые предоставляются ресурсами Майкрософт, например Office 365. Это позволит вам предлагать своим пользователям персонализированные возможности при работе с приложением, например отображать контекстную информацию — такую, как изображение профиля или следующая встреча из календаря. Дополнительные сведения о вызовах API к службам Azure AD и Office 365 (например, Exchange, SharePoint, OneDrive, OneNote, Планировщик, Excel и др.) см. в статье, посвященной [API Microsoft Graph][MSFT-Graph-overview].

## <a name="related-content"></a>Связанная информация
* [Примеры мультитенантных приложений][AAD-Samples-MT]
* [Рекомендации по фирменной символике для приложений][AAD-App-Branding]
* [Объекты приложения и субъекта-службы в Azure Active Directory (Azure AD)][AAD-App-SP-Objects]
* [Интеграция приложений с Azure Active Directory][AAD-Integrating-Apps]
* [Обзор платформы согласия][AAD-Consent-Overview]
* [Справочник по разрешениям Microsoft Graph][MSFT-Graph-permision-scopes]
* [Области разрешений | Основные понятия API Graph][AAD-Graph-Perm-Scopes]

<!--Reference style links IN USE -->
[AAD-Access-Panel]:  https://myapps.microsoft.com
[AAD-App-Branding]: ./active-directory-branding-guidelines.md
[AAD-App-Manifest]: ./active-directory-application-manifest.md
[AAD-App-SP-Objects]: ./active-directory-application-objects.md
[AAD-Auth-Scenarios]: ./active-directory-authentication-scenarios.md
[AAD-Consent-Overview]: ./active-directory-integrating-applications.md#overview-of-the-consent-framework
[AAD-Dev-Guide]: ./active-directory-developers-guide.md
[AAD-Graph-Overview]: https://azure.microsoft.com/documentation/articles/active-directory-graph-api/
[AAD-Graph-Perm-Scopes]: https://msdn.microsoft.com/library/azure/ad/graph/howto/azure-ad-graph-api-permission-scopes
[AAD-Integrating-Apps]: ./active-directory-integrating-applications.md
[AAD-Samples-MT]: https://azure.microsoft.com/documentation/samples/?service=active-directory&term=multitenant
[AAD-Why-To-Integrate]: ./active-directory-how-to-integrate.md
[AZURE-portal]: https://portal.azure.com
[MSFT-Graph-overview]: https://graph.microsoft.io/en-us/docs/overview/overview
[MSFT-Graph-permision-scopes]: https://developer.microsoft.com/en-us/graph/docs/concepts/permissions_reference

<!--Image references-->
[AAD-Sign-In]: ./media/active-directory-devhowto-multi-tenant-overview/sign-in-with-microsoft-light.png
[Consent-Single-Tier]: ./media/active-directory-devhowto-multi-tenant-overview/consent-flow-single-tier.png
[Consent-Multi-Tier-Known-Client]: ./media/active-directory-devhowto-multi-tenant-overview/consent-flow-multi-tier-known-clients.png
[Consent-Multi-Tier-Multi-Party]: ./media/active-directory-devhowto-multi-tenant-overview/consent-flow-multi-tier-multi-party.png

<!--Reference style links -->
[AAD-App-Manifest]: ./active-directory-application-manifest.md
[AAD-App-SP-Objects]: ./active-directory-application-objects.md
[AAD-Auth-Scenarios]: ./active-directory-authentication-scenarios.md
[AAD-Integrating-Apps]: ./active-directory-integrating-applications.md
[AAD-Dev-Guide]: ./active-directory-developers-guide.md
[AAD-Graph-Perm-Scopes]: https://msdn.microsoft.com/library/azure/ad/graph/howto/azure-ad-graph-api-permission-scopes
[AAD-Graph-App-Entity]: https://msdn.microsoft.com/Library/Azure/Ad/Graph/api/entity-and-complex-type-reference#application-entity
[AAD-Graph-Sp-Entity]: https://msdn.microsoft.com/Library/Azure/Ad/Graph/api/entity-and-complex-type-reference#serviceprincipal-entity
[AAD-Graph-User-Entity]: https://msdn.microsoft.com/Library/Azure/Ad/Graph/api/entity-and-complex-type-reference#user-entity
[AAD-How-To-Integrate]: ./active-directory-how-to-integrate.md
[AAD-Security-Token-Claims]: ./active-directory-authentication-scenarios/#claims-in-azure-ad-security-tokens
[AAD-Tokens-Claims]: ./active-directory-token-and-claims.md
[AAD-V2-Dev-Guide]: ../active-directory-appmodel-v2-overview.md
[AZURE-portal]: https://portal.azure.com
[Duyshant-Role-Blog]: http://www.dushyantgill.com/blog/2014/12/10/roles-based-access-control-in-cloud-applications-using-azure-ad/
[JWT]: https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32
[O365-Perm-Ref]: https://msdn.microsoft.com/office/office365/howto/application-manifest
[OAuth2-Access-Token-Scopes]: https://tools.ietf.org/html/rfc6749#section-3.3
[OAuth2-AuthZ-Code-Grant-Flow]: https://msdn.microsoft.com/library/azure/dn645542.aspx
[OAuth2-AuthZ-Grant-Types]: https://tools.ietf.org/html/rfc6749#section-1.3 
[OAuth2-Client-Types]: https://tools.ietf.org/html/rfc6749#section-2.1
[OAuth2-Role-Def]: https://tools.ietf.org/html/rfc6749#page-6
[OpenIDConnect]: http://openid.net/specs/openid-connect-core-1_0.html
[OpenIDConnect-ID-Token]: http://openid.net/specs/openid-connect-core-1_0.html#IDToken














