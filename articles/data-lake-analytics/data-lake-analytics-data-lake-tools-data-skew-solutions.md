---
title: Решение проблем неравномерного распределения данных с помощью средств Azure Data Lake для Visual Studio
description: Сведения об устранении проблем неравномерного распределения данных с помощью средств Azure Data Lake для Visual Studio.
services: data-lake-analytics
author: yanancai
ms.author: yanacai
manager: kfile
editor: jasonwhowell
ms.service: data-lake-analytics
ms.topic: conceptual
ms.date: 12/16/2016
ms.openlocfilehash: 43a050251a6945d6886930a2a76fcb9f833b78f0
ms.sourcegitcommit: 266fe4c2216c0420e415d733cd3abbf94994533d
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/01/2018
ms.locfileid: "34623389"
---
# <a name="resolve-data-skew-problems-by-using-azure-data-lake-tools-for-visual-studio"></a>Решение проблем неравномерного распределения данных с помощью средств Azure Data Lake для Visual Studio

## <a name="what-is-data-skew"></a>Что такое неравномерное распределение данных?

Коротко говоря, неравномерное распределение данных — это чрезмерно представленное значение. Предположим, вы назначили 50 инспекторов, которые выполняют аудит финансовой отчетности об уплате налогов, по одному человеку для каждого штата. Аудитор из Вайоминга не будет загружен работой, так как этот штат не является густонаселенным, а инспекторы из Калифорнии будут работать допоздна, так как в этом штате многочисленное население.
    ![Пример проблемы неравномерного распределения данных](./media/data-lake-analytics-data-lake-tools-data-skew-solutions/data-skew-problem.png)

В нашем примере данные между всеми инспекторами распределены неравномерно, а это значит, что у них будет разный объем работы. Нам часто приходится сталкиваться со случаями, подобными приведенному здесь примеру с проверяющими налоговых деклараций. Говоря техническим языком, одна вершина получает гораздо больше данных по сравнению с другими. Это приводит к тому, что она обрабатывается дольше других, и в конечном счете это замедляет выполнение всего задания. Более того, задание может завершиться ошибкой, так как вершины, к примеру, могут иметь ограничение времени выполнения в 5 часов и ограничение памяти в 6 ГБ.

## <a name="resolving-data-skew-problems"></a>Устранение неравномерного распределения данных

Средства Azure Data Lake для Visual Studio помогают обнаружить проблемы неравномерного распределения данных в задании. Если такая проблема будет обнаружена, ее можно устранить с помощью решений, описанных в данном разделе.

## <a name="solution-1-improve-table-partitioning"></a>Решение 1. Улучшение секционирования таблиц

### <a name="option-1-filter-the-skewed-key-value-in-advance"></a>Вариант 1. Отфильтруйте неравномерное значение ключа заранее

Если это не влияет на вашу бизнес-логику, вы можете отфильтровать самое часто встречаемое значение заранее. Например, если в колонке GUID много значений 000-000-000, вы не станете выполнять статистическое вычисление на основе этого значения. Прежде чем выполнять статистическое вычисление, можно написать "WHERE GUID != "000-000-000"", чтобы отфильтровать значение, которое часто встречается.

### <a name="option-2-pick-a-different-partition-or-distribution-key"></a>Вариант 2. Выберите другой ключ секции или распределения

В примере выше, если все, что вам необходимо сделать, — это проверить налоги во всей стране, вы можете выбрать номер идентификатора в качестве ключа, чтобы улучшить распределение данных. Иногда, выбрав другой ключ секции или распределения, можно распределить данные более равномерно, однако следует убедиться, что это не повлияет на бизнес-логику. Например, если необходимо вычислить сумму налогов для каждого штата, лучше выбрать _штат_ в качестве ключа секции. Если проблема не будет устранена, обратитесь к третьему варианту.

### <a name="option-3-add-more-partition-or-distribution-keys"></a>Вариант 3. Добавьте дополнительные ключи секции или распределения

Помимо использования одного _штата_ можно использовать несколько ключей для секционирования. Например, добавьте в качестве дополнительного ключа секции _Почтовый индекс_, чтобы уменьшить размеры секций данных и распределить данные более равномерно.

### <a name="option-4-use-round-robin-distribution"></a>Вариант 4. Используйте распределение путем циклического перебора

Если не удается найти подходящий ключ для секции и распределения, попробуйте использовать распределение путем циклического перебора. При распределении путем циклического перебора все строки обрабатываются одинаково и случайным образом помещаются в соответствующий контейнер. Данные распределяются равномерно, но при этом теряются сведения о размещении, что также снижает производительность выполнения задания для некоторых операций. Кроме того, если вы выполняете статистическую обработку для неравномерного ключа, проблема неравномерного распределения данных никуда не исчезнет. Дополнительные сведения о распределении путем циклического перебора см. в разделе о распределениях таблицы U-SQL в статье [CREATE TABLE (U-SQL): Creating a Table with Schema](https://msdn.microsoft.com/library/mt706196.aspx#dis_sch) (CREATE TABLE (U-SQL). Создание таблицы с использованием схемы).

## <a name="solution-2-improve-the-query-plan"></a>Решение 2. Улучшение плана запроса

### <a name="option-1-use-the-create-statistics-statement"></a>Вариант 1. Используйте инструкцию CREATE STATISTICS

В U-SQL предусмотрена инструкция CREATE STATISTICS для таблиц. Она предоставляет оптимизатору запросов дополнительные сведения о характеристиках данных, хранящихся в таблице, например распределение значений и т. д. Для большинства запросов оптимизатор создает необходимую статистику для плана запроса высокого качества. В некоторых случаях необходимо создать дополнительную статистику с помощью инструкции CREATE STATISTICS или изменить структуру запроса, чтобы повысить производительность запросов. Дополнительные сведения см. в статье [CREATE STATISTICS (U-SQL)](https://msdn.microsoft.com/library/azure/mt771898.aspx).

Пример кода:

    CREATE STATISTICS IF NOT EXISTS stats_SampleTable_date ON SampleDB.dbo.SampleTable(date) WITH FULLSCAN;

>[!NOTE]
>Статистика не обновляется автоматически. При обновлении данных в таблице без повторного создания статистики производительность запросов может заметно ухудшиться.

### <a name="option-2-use-skewfactor"></a>Вариант 2. Используйте SKEWFACTOR

Чтобы посчитать сумму налогов для каждого штата, необходимо использовать группировку по штатам (с помощью выражения GROUP BY), что приведет к неравномерному распределению данных. Тем не менее в запросе можно указать подсказку данных, чтобы идентифицировать неравномерное распределение данных в ключах, благодаря чему оптимизатор сможет подготовить план выполнения.

Как правило, для параметра можно установить значение 0.5 и 1, где 0.5 — это незначительное смещение данных, а 1 — интенсивное. Так как подсказка влияет на оптимизацию плана выполнения для текущей инструкции и всех подчиненных инструкций, добавьте подсказку перед статистической обработкой неравномерно распределенных ключей.

    SKEWFACTOR (columns) = x

    Provides a hint that the given columns have a skew factor x from 0 (no skew) through 1 (very heavy skew).

Пример кода:

    //Add a SKEWFACTOR hint.
    @Impressions =
        SELECT * FROM
        searchDM.SML.PageView(@start, @end) AS PageView
        OPTION(SKEWFACTOR(Query)=0.5)
        ;

    //Query 1 for key: Query, ClientId
    @Sessions =
        SELECT
            ClientId,
            Query,
            SUM(PageClicks) AS Clicks
        FROM
            @Impressions
        GROUP BY
            Query, ClientId
        ;

    //Query 2 for Key: Query
    @Display =
        SELECT * FROM @Sessions
            INNER JOIN @Campaigns
                ON @Sessions.Query == @Campaigns.Query
        ;   

### <a name="option-3-use-rowcount"></a>Вариант 3. Использование ROWCOUNT  
Помимо SKEWFACTOR для объединения неравномерно распределенных ключей в случае, когда один из наборов объединенных строк имеет небольшой размер, в инструкцию U-SQL можно добавить подсказку ROWCOUNT перед инструкцией JOIN, чтобы сообщить оптимизатору о наличии маленького набора строк. В результате этого оптимизатор выберет стратегию присоединения для повышения производительности. Имейте в виду, что подсказка ROWCOUNT не решает проблему неравномерного распределения данных, но позволяет несколько уменьшить степень проблемы.

    OPTION(ROWCOUNT = n)

    Identify a small row set before JOIN by providing an estimated integer row count.

Пример кода:

    //Unstructured (24-hour daily log impressions)
    @Huge   = EXTRACT ClientId int, ...
                FROM @"wasb://ads@wcentralus/2015/10/30/{*}.nif"
                ;

    //Small subset (that is, ForgetMe opt out)
    @Small  = SELECT * FROM @Huge
                WHERE Bing.ForgetMe(x,y,z)
                OPTION(ROWCOUNT=500)
                ;

    //Result (not enough information to determine simple broadcast JOIN)
    @Remove = SELECT * FROM Bing.Sessions
                INNER JOIN @Small ON Sessions.Client == @Small.Client
                ;

## <a name="solution-3-improve-the-user-defined-reducer-and-combiner"></a>Вариант 3. Усовершенствуйте определяемые пользователем редуктор и средства объединения

Иногда при работе с логикой сложных процессов вы используете пользовательский оператор, а хорошо написанный редуктор и средство объединения в некоторых случаях могут устранить проблему неравномерного распределения данных.

### <a name="option-1-use-a-recursive-reducer-if-possible"></a>Вариант 1. По возможности используйте рекурсивный редуктор

По умолчанию определяемый пользователем редуктор выполняется в нерекурсивном режиме, а это означает, что уменьшенный объем работы для ключа распределяется в одну вершину. Но если данные распределены неравномерно, крупные наборы данных могут обрабатываться в одной вершине, что занимает много времени.

Для улучшения производительности в код можно добавить атрибут, чтобы определить выполнение редуктора в рекурсивном режиме. После этого крупные наборы данных можно распределить по нескольким вершинам и выполнять параллельно, что ускорит вашу работу.

Чтобы изменить нерекурсивный редуктор на рекурсивный, ваш алгоритм должен быть ассоциативным. Например, сумма является ассоциативной, а медиана — нет. Кроме того, во входных и выходных данных для редуктора должна храниться одна и та же схема.

Атрибут для рекурсивного редуктора:

    [SqlUserDefinedReducer(IsRecursive = true)]

Пример кода:

    [SqlUserDefinedReducer(IsRecursive = true)]
    public class TopNReducer : IReducer
    {
        public override IEnumerable<IRow>
            Reduce(IRowset input, IUpdatableRow output)
        {
            //Your reducer code goes here.
        }
    }

### <a name="option-2-use-row-level-combiner-mode-if-possible"></a>Вариант 2. По возможности используйте режим средства объединения на уровне строк

Как и в случае с подсказкой ROWCOUNT для определенных случаев объединения неравномерно распределенных ключей, режим средства объединения пытается распределить огромные наборы неравномерно распределенных значений ключей по нескольким вершинам, чтобы операции могли выполняться одновременно. Режим средства объединения не устранит проблему неравномерного распределения данных, но может дополнительно помочь с обработкой массивных наборов неравномерно распределенных значений ключей.

По умолчанию режим средства объединения является полным, а это означает, что левый и правый наборы разделить невозможно. Установка режимов "Левый", "Правый" и "Внутренний" позволяет выполнять соединение на уровне строк. Система разделяет соответствующие наборы строк и распределяет их между несколькими вершинами, которые выполняются параллельно. Однако прежде чем настроить режим средства объединения, убедитесь в том, что соответствующие наборы строк могут быть разделены.

В примере ниже показан разделенный левый набор строк. Каждая строка выходных данных зависит от одной входной строки из левого входа и потенциально зависит от всех строк из правого входа с тем же значением ключа. Если установить режим средства объединения как левый вход, система разделяет большой левый набор строк на небольшие и назначает их нескольким вершинам.

![Иллюстрация режима средства объединения](./media/data-lake-analytics-data-lake-tools-data-skew-solutions/combiner-mode-illustration.png)

>[!NOTE]
>Если вы установите неправильный режим средства объединения, комбинация будет менее эффективной, а результаты неверными.

Атрибуты режима средства объединения:

- [SqlUserDefinedCombiner(Mode=CombinerMode.Full)]: Every output row potentially depends on all the input rows from left and right with the same key value.

- SqlUserDefinedCombiner(Mode=CombinerMode.Left) — каждая строка выходных данных зависит от одной входной строки из левого входа (и потенциально от всех строк из правого входа с тем же значением ключа).

- qlUserDefinedCombiner(Mode=CombinerMode.Right) — каждая строка выходных данных зависит от одной входной строки из правого входа (и потенциально от всех строк из левого входа с тем же значением ключа).

- SqlUserDefinedCombiner(Mode=CombinerMode.Inner) — каждая строка выходных данных зависит от одной входной строки из левого и правого входа с тем же значением.

Пример кода:

    [SqlUserDefinedCombiner(Mode = CombinerMode.Right)]
    public class WatsonDedupCombiner : ICombiner
    {
        public override IEnumerable<IRow>
            Combine(IRowset left, IRowset right, IUpdatableRow output)
        {
        //Your combiner code goes here.
        }
    }
