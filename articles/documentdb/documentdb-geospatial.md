---
title: "Работа с геопространственными данными в Azure DocumentDB | Документация Майкрософт"
description: "Узнайте, как создать, индексировать и запрашивать пространственные объекты в Azure DocumentDB."
services: documentdb
documentationcenter: 
author: arramac
manager: jhubbard
editor: monicar
ms.assetid: 82ce2898-a9f9-4acf-af4d-8ca4ba9c7b8f
ms.service: documentdb
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: data-services
ms.date: 11/16/2016
ms.author: arramac
translationtype: Human Translation
ms.sourcegitcommit: 2d833a559b72569983340972ba3b905b9e42e61d
ms.openlocfilehash: f78c0fc1959f72164508af9d8945744b67fac68b


---
# <a name="working-with-geospatial-data-in-azure-documentdb"></a>Работа с геопространственными данными в Azure DocumentDB
Эта статья содержит вводную информацию о геопространственной функциональности [Azure DocumentDB](https://azure.microsoft.com/services/documentdb/). После прочтения этой статьи вы сможете ответить на следующие вопросы:

* Как хранить пространственные данные в Azure DocumentDB?
* Как запрашивать геопространственные данные в Azure DocumentDB с помощью SQL и LINQ?
* Как включить или отключить пространственное индексирование в DocumentDB?

Примеры кода можно найти в [следующем проекте Github](https://github.com/Azure/azure-documentdb-dotnet/blob/master/samples/code-samples/Geospatial/Program.cs) .

## <a name="introduction-to-spatial-data"></a>Общие сведения о пространственных данных
Пространственные данные описывают положение и форму объектов в пространстве. В большинстве приложений они соответствуют объектам на поверхности Земли, т. е. геопространственным данным. Пространственные данные могут использоваться для представления местонахождения человека, мест, представляющих интерес, или границ города или озера. Наиболее распространенные случаи часто включают запросы близости, например "найти все кафе рядом с моим текущим местоположением". 

### <a name="geojson"></a>GeoJSON
DocumentDB поддерживает индексацию и запросы к геопространственным данным точки, представляемым [спецификацией GeoJSON](http://geojson.org/geojson-spec.html). Структуры данных GeoJSON всегда являются действительными объектами JSON, поэтому их можно сохранять и опрашивать с помощью DocumentDB без специальных средств или библиотек. Пакеты SDK DocumentDB предоставляют вспомогательные классы и методы, которые позволяют легко работать с пространственными данными. 

### <a name="points-linestrings-and-polygons"></a>Точки, объекты LineString и многоугольники
**Точка** обозначает одно положение в пространстве. В геопространственных данных точка представляет точное расположение, которое может быть адресом продуктового магазина, киоска, точкой расположения автомобиля или города.  В GeoJSON (и DocumentDB) точка представляется в виде пары координат или широты и долготы. Ниже приведен пример JSON для точки.

**Точки в DocumentDB**

    {
       "type":"Point",
       "coordinates":[ 31.9, -4.8 ]
    }

> [!NOTE]
> В спецификации GeoJSON сначала указывается широта, затем долгота. Как и в других картах, широта и долгота представляют собой углы и выражаются в градусах. Значение долготы отсчитывается от нулевого меридиана и находится в диапазоне от -180 до 180.0 градусов, а значение широты отсчитывается от экватора и находится в диапазоне от-90.0 до 90.0 градусов. 
> 
> В DocumentDB координаты интерпретируются в соответствии с системой координат WGS-84. Дополнительные сведения о системах координат см. ниже.
> 
> 

Их можно включить в документ DocumentDB, как показано в следующем примере профиля пользователя, содержащего данные о местоположении:

**Использование профиля с данными о местоположении, которые хранятся в DocumentDB**

    {
       "id":"documentdb-profile",
       "screen_name":"@DocumentDB",
       "city":"Redmond",
       "topics":[ "NoSQL", "Javascript" ],
       "location":{
          "type":"Point",
          "coordinates":[ 31.9, -4.8 ]
       }
    }

Наряду с точками GeoJSON также поддерживает объекты LineString и многоугольники. **Объект LineString** представляет собой последовательность из двух или более точек в пространстве и отрезков, которые их соединяют. В геопространственных данных объекты LineString обычно используются для представления автомагистралей или рек. **Многоугольник** представляет собой область, ограниченную соединенными друг с другом точками, которая образует замкнутый объект LineString. Многоугольники обычно используются для представления естественных природных образований, таких как озера, или географических единиц, таких как города и области. Ниже приведен пример многоугольника в DocumentDB. 

**Многоугольники в DocumentDB**

    {
       "type":"Polygon",
       "coordinates":[
           [ 31.8, -5 ],
           [ 31.8, -4.7 ],
           [ 32, -4.7 ],
           [ 32, -5 ],
           [ 31.8, -5 ]
       ]
    }

> [!NOTE]
> По спецификации GeoJSON для действительного многоугольника последняя пара координат должна совпадать с первой, чтобы фигура стала замкнутой.
> 
> Точки внутри многоугольника должны указываться в порядке против часовой стрелки. Если точки указаны в порядке по часовой стрелке, то многоугольник представляет регион, расположенный снаружи от него.
> 
> 

Наряду с точками, объектами LineString и многоугольниками в GeoJSON также определяется способ группировки нескольких геопространственных местоположений, а также способ задания произвольных свойств географического положения в качестве **Функций**. Поскольку эти объекты являются действительными объектами JSON, их можно хранить и обрабатывать в DocumentDB. Однако DocumentDB поддерживает только автоматическую индексацию точек.

### <a name="coordinate-reference-systems"></a>Системы координат
Поскольку Земля имеет неправильную форму, координаты геопространственных данных представляются во многих системах координат, каждая из которых имеет собственные границы отсчета и единицы измерения. Например, "Национальная система координат Великобритании" (National Grid of Britain) обладает высокой точностью в Великобритании, но не за ее пределами. 

Самой популярной системой координат на данный момент является [WGS-84](http://earth-info.nga.mil/GandG/wgs84/). WGS-84 используют устройства GPS и многие службы географических карт, в том числе Карты Google и API-интерфейсы Карт Bing. DocumentDB поддерживает индексирование и опрашивание геопространственных данных только с использованием WGS-84. 

## <a name="creating-documents-with-spatial-data"></a>Создание документов с пространственными данными
При создании документов, содержащих значения GeoJSON, они автоматически индексируются с пространственным индексом в соответствии с политикой индексирования коллекции. При работе с пакетом SDK DocumentDB в динамически типизированных языках программирования, таких как Python или Node.js, необходимо создавать действительные объекты GeoJSON.

**Создание документа с геопространственными данными в Node.js**

    var userProfileDocument = {
       "name":"documentdb",
       "location":{
          "type":"Point",
          "coordinates":[ -122.12, 47.66 ]
       }
    };

    client.createDocument(`dbs/${databaseName}/colls/${collectionName}`, userProfileDocument, (err, created) => {
        // additional code within the callback
    });

Если вы работаете с пакетами SDK .NET (или Java), то можете использовать новые классы Point и Polygon в пространстве имен Microsoft.Azure.Documents.Spatial для включения информации о местоположении в свои объекты приложения. Эти классы помогают упростить сериализацию и десериализацию пространственных данных в GeoJSON.

**Создание документа с геопространственными данными в .NET**

    using Microsoft.Azure.Documents.Spatial;

    public class UserProfile
    {
        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("location")]
        public Point Location { get; set; }

        // More properties
    }

    await client.CreateDocumentAsync(
        UriFactory.CreateDocumentCollectionUri("db", "profiles"), 
        new UserProfile 
        { 
            Name = "documentdb", 
            Location = new Point (-122.12, 47.66) 
        });

Если у вас нет информации о широте и долготе, но есть физический адрес или название местоположения, например название города или страны, то фактические координаты можно определить с помощью службы геокодирования, такой как служба REST Карт Bing. Дополнительные сведения о геокодировании в Картах Bing можно найти [здесь](https://msdn.microsoft.com/library/ff701713.aspx).

## <a name="querying-spatial-types"></a>Типы запросов к пространственным данным
Теперь, когда мы рассмотрели способы внедрения геопространственных данных, обратимся к тому, как запрашивать эти данные в DocumentDB с помощью SQL и LINQ.

### <a name="spatial-sql-built-in-functions"></a>Встроенные функции для обработки пространственных данных в SQL
DocumentDB поддерживает следующие встроенные функции Открытого геопространственного консорциума (OGC) для выполнения запросов к геопространственным данным. Дополнительные сведения о всех встроенных функциях SQL см. в разделе [Запросы в DocumentDB](documentdb-sql-query.md).

<table>
<tr>
  <td><strong>Использование</strong></td>
  <td><strong>Описание</strong></td>
</tr>
<tr>
  <td>ST_DISTANCE (spatial_expr, spatial_expr)</td>
  <td>Возвращает расстояние между двумя выражениями точек GeoJSON, многоугольников или объектов LineString.</td>
</tr>
<tr>
  <td>ST_WITHIN (spatial_expr, spatial_expr)</td>
  <td>Возвращает логическое выражение, указывающее, располагается ли первый объект GeoJSON (точка, многоугольник или LineString) внутри второго объекта GeoJSON (точка, многоугольник или LineString).</td>
</tr>
<tr>
  <td>ST_INTERSECTS (spatial_expr, spatial_expr)</td>
  <td>Возвращает логическое выражение, указывающее, пересекаются ли два объекта GeoJSON (точка, многоугольник или LineString).</td>
</tr>
<tr>
  <td>ST_ISVALID</td>
  <td>Возвращает логическое значение, указывающее, является ли действительным выражение GeoJSON (точка, многоугольник или LineString).</td>
</tr>
<tr>
  <td>ST_ISVALIDDETAILED</td>
  <td>Возвращает значение JSON, содержащее логическое значение, указывающее, является ли выражение GeoJSON (точка, многоугольник или LineString) действительным. Если оно является недействительным, то возвращаемое значение также содержит строку с описанием причины.</td>
</tr>
</table>

Пространственные функции могут использоваться для выполнения запросов близости к пространственным данным. Например, ниже приведен запрос, возвращающий все документы семейств, которые находятся в пределах 30 км от заданного расположения, с помощью встроенной функции ST_DISTANCE. 

**Запрос**

    SELECT f.id 
    FROM Families f 
    WHERE ST_DISTANCE(f.location, {'type': 'Point', 'coordinates':[31.9, -4.8]}) < 30000

**Результат**

    [{
      "id": "WakefieldFamily"
    }]

При включении пространственного индексирования в политику индексирования "запросы для определения расстояния" будут эффективно обрабатываться с помощью индекса. Дополнительные сведения о пространственном индексировании см. в следующем разделе. При отсутствии пространственного индекса для указанных путей вы все равно сможете выполнять пространственные запросы, указывая заголовок запроса `x-ms-documentdb-query-enable-scan` со значением "true". В .NET это можно сделать, указав необязательный аргумент запроса **FeedOptions** со свойством [EnableScanInQuery](https://msdn.microsoft.com/library/microsoft.azure.documents.client.feedoptions.enablescaninquery.aspx#P:Microsoft.Azure.Documents.Client.FeedOptions.EnableScanInQuery), имеющим значение true. 

С помощью ST_WITHIN можно проверить, находится ли точка внутри многоугольника. Многоугольники обычно используются для представления границ, например почтовых зон, границ штатов или границ природных образований. При включении пространственного индексирования в политику индексирования "запросы нахождения внутри" будут эффективно обрабатываться с помощью индекса. 

Аргументы многоугольника в ST_WITHIN могут содержать только одно кольцо, т. е. в многоугольниках не должно быть "дыр". 

**Запрос**

    SELECT * 
    FROM Families f 
    WHERE ST_WITHIN(f.location, {
        'type':'Polygon', 
        'coordinates': [[[31.8, -5], [32, -5], [32, -4.7], [31.8, -4.7], [31.8, -5]]]
    })

**Результаты**

    [{
      "id": "WakefieldFamily",
    }]

> [!NOTE]
> По аналогии с несоответствием типов в запросе DocumentDB: если значение местоположения, указанное в любом из аргументов, имеет неправильный формат или является недопустимым, то оно приравнивается к значению **не определено** и соответствующий документ исключается из результатов запроса. Если запрос не возвращает результатов, выполните запрос ST_ISVALIDDETAILED для выяснения причин, по которым тип пространственных данных является недействительным.     
> 
> 

DocumentDB поддерживает также выполнение обратных запросов, т. е. можно индексировать многоугольники или линии в DocumentDB, а затем выполнять запросы к областям, которые содержат указанную точку. Этот шаблон часто используется в логистике, например, чтобы определить, когда грузовик прибывает в указанную область или выезжает из нее. 

**Запрос**

    SELECT * 
    FROM Areas a 
    WHERE ST_WITHIN({'type': 'Point', 'coordinates':[31.9, -4.8]}, a.location)


**Результат**

    [{
      "id": "MyDesignatedLocation",
      "location": {
        "type":"Polygon", 
        "coordinates": [[[31.8, -5], [32, -5], [32, -4.7], [31.8, -4.7], [31.8, -5]]]
      }
    }]

Чтобы проверить, является ли пространственный объект действительным, можно воспользоваться ST_ISVALID и ST_ISVALIDDETAILED. Например, следующий запрос проверяет действительность точки, значение широты для которой выходит за пределы допустимого диапазона (-132.8). ST_ISVALID возвращает логическое значение, а ST_ISVALIDDETAILED возвращает логическое значение и строку, содержащую причину, по которой значение считается недействительным.

** Запрос **

    SELECT ST_ISVALID({ "type": "Point", "coordinates": [31.9, -132.8] })

**Результаты**

    [{
      "$1": false
    }]

Эти функции также могут использоваться для проверки многоугольников. Например, здесь мы используем ST_ISVALIDDETAILED для того, чтобы проверить, что многоугольник не является замкнутым. 

**Запрос**

    SELECT ST_ISVALIDDETAILED({ "type": "Polygon", "coordinates": [[ 
        [ 31.8, -5 ], [ 31.8, -4.7 ], [ 32, -4.7 ], [ 32, -5 ] 
        ]]})

**Результаты**

    [{
       "$1": { 
            "valid": false, 
            "reason": "The Polygon input is not valid because the start and end points of the ring number 1 are not the same. Each ring of a Polygon must have the same start and end points." 
          }
    }]

### <a name="linq-querying-in-the-net-sdk"></a>Запросы LINQ в пакете SDK для .NET
В пакете SDK для .NET DocumentDB также содержатся заглушки методов `Distance()` и `Within()` для использования с помощью выражений LINQ. Поставщик LINQ DocumentDB преобразует эти вызовы методов в эквивалентные вызовы встроенных функций SQL (ST_DISTANCE и ST_WITHIN соответственно). 

Ниже приведен пример запроса LINQ, который находит все документы в коллекции DocumentDB с "местоположением" в радиусе 30 км от указанной точки.

**Запросы LINQ для определения расстояния**

    foreach (UserProfile user in client.CreateDocumentQuery<UserProfile>(UriFactory.CreateDocumentCollectionUri("db", "profiles"))
        .Where(u => u.ProfileType == "Public" && a.Location.Distance(new Point(32.33, -4.66)) < 30000))
    {
        Console.WriteLine("\t" + user);
    }

Ниже приведен аналогичный запрос для поиска всех документов с "местоположением" в пределах указанного прямоугольника или многоугольника. 

**Запросы LINQ для определения принадлежности**

    Polygon rectangularArea = new Polygon(
        new[]
        {
            new LinearRing(new [] {
                new Position(31.8, -5),
                new Position(32, -5),
                new Position(32, -4.7),
                new Position(31.8, -4.7),
                new Position(31.8, -5)
            })
        });

    foreach (UserProfile user in client.CreateDocumentQuery<UserProfile>(UriFactory.CreateDocumentCollectionUri("db", "profiles"))
        .Where(a => a.Location.Within(rectangularArea)))
    {
        Console.WriteLine("\t" + user);
    }


Теперь, когда мы познакомились с запросами к документам с помощью LINQ и SQL, рассмотрим способы настройки DocumentDB для пространственного индексирования.

## <a name="indexing"></a>Индексация
Как было описано в документе [Схемонезависимое индексирование с помощью Azure DocumentDB](http://www.vldb.org/pvldb/vol8/p1668-shukla.pdf) , СУБД DocumentDB является по-настоящему схемонезависимой и обеспечивает превосходную поддержку JSON. В СУБД DocumentDB с оптимизацией записи также реализована поддержка пространственных данных (точек, многоугольников и линий), представленных в стандарте GeoJSON.

По сути, геометрия формируется путем проецирования геодезических координат на двумерную плоскость, которая затем постепенно разделяется на ячейки с помощью **дерева квадрантов**. Эти ячейки связываются с одномерным пространством на основе расположения ячейки на **кривой заполнения гильбертова пространства**, что позволяет сохранить расположение точек. Кроме того, при индексировании данных расположения ячейки проходят так называемый процесс **тесселяции**, т. е. все ячейки, которые пересекают расположение, обнаруживаются и сохраняются в виде ключей в индексе DocumentDB. Во время обработки запроса такие аргументы, как точки и многоугольники, также тесселируются для извлечения диапазонов идентификаторов соответствующих ячеек, а затем используются для получения данных из индекса.

При указании политики индексирования, которая включает пространственный индекс для /* (все пути), все точки, обнаруженные внутри коллекции, индексируются для эффективного выполнения пространственных запросов (ST_WITHIN и ST_DISTANCE). Пространственные индексы не имеют значения точности и всегда используют значение точности по умолчанию.

> [!NOTE]
> DocumentDB поддерживает автоматическое индексирование данных типа Point, Polygon и LineString.
> 
> 

Следующий фрагмент JSON демонстрирует политику индексирования с включенным пространственным индексированием, т. е. индексированием любой точки GeoJSON, обнаруженной в документах, для пространственных запросов. При изменении политики индексирования с помощью портала Azure можно указать следующий JSON политики индексирования для включения в коллекции пространственного индексирования.

**JSON политики пространственного индексирования коллекций для точек и многоугольников**

    {
       "automatic":true,
       "indexingMode":"Consistent",
       "includedPaths":[
          {
             "path":"/*",
             "indexes":[
                {
                   "kind":"Range",
                   "dataType":"String",
                   "precision":-1
                },
                {
                   "kind":"Range",
                   "dataType":"Number",
                   "precision":-1
                },
                {
                   "kind":"Spatial",
                   "dataType":"Point"
                },
                {
                   "kind":"Spatial",
                   "dataType":"Polygon"
                }                
             ]
          }
       ],
       "excludedPaths":[
       ]
    }

Ниже приведен фрагмент кода .NET, который показывает, как создать коллекцию со включенным пространственным индексированием для всех путей, содержащих точки. 

**Создание коллекции с пространственным индексированием**

    DocumentCollection spatialData = new DocumentCollection()
    spatialData.IndexingPolicy = new IndexingPolicy(new SpatialIndex(DataType.Point)); //override to turn spatial on by default
    collection = await client.CreateDocumentCollectionAsync(UriFactory.CreateDatabaseUri("db"), spatialData);

А вот как можно изменить существующую коллекцию, чтобы воспользоваться преимуществами пространственного индексирования всех точек, которые хранятся в документах.

**Изменение коллекции с пространственным индексированием**

    Console.WriteLine("Updating collection with spatial indexing enabled in indexing policy...");
    collection.IndexingPolicy = new IndexingPolicy(new SpatialIndex(DataType.Point));
    await client.ReplaceDocumentCollectionAsync(collection);

    Console.WriteLine("Waiting for indexing to complete...");
    long indexTransformationProgress = 0;
    while (indexTransformationProgress < 100)
    {
        ResourceResponse<DocumentCollection> response = await client.ReadDocumentCollectionAsync(UriFactory.CreateDocumentCollectionUri("db", "coll"));
        indexTransformationProgress = response.IndexTransformationProgress;

        await Task.Delay(TimeSpan.FromSeconds(1));
    }

> [!NOTE]
> Если значение расположения GeoJSON в документе сформировано неверно или является недействительным, оно не будет индексироваться для пространственных запросов. Проверить значение расположения можно с помощью ST_ISVALID и ST_ISVALIDDETAILED.
> 
> Если определение коллекции включает ключ секции, информация о ходе выполнения преобразования индекса не предоставляется. 
> 
> 

## <a name="next-steps"></a>Дальнейшие действия
Теперь, когда вы ознакомились с предварительными сведениями о поддержке геопространственных данных в DocumentDB, вы можете сделать следующее.

* Начните программировать с помощью [примеров кода для работы с геопространственными данными посредством .NET, доступных на сайте GitHub](https://github.com/Azure/azure-documentdb-dotnet/blob/fcf23d134fc5019397dcf7ab97d8d6456cd94820/samples/code-samples/Geospatial/Program.cs).
* Освойте геопространственные запросы на [Игровой площадке запросов DocumentDB](http://www.documentdb.com/sql/demo#geospatial)
* Узнайте подробнее о [Запросах в DocumentDB](documentdb-sql-query.md)
* Узнайте подробнее о [Политиках индексирования DocumentDB](documentdb-indexing-policies.md)




<!--HONumber=Nov16_HO3-->


