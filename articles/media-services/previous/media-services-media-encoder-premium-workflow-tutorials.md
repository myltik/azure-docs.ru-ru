---
title: Руководства по расширенному рабочему процессу кодировщика мультимедиа
description: Этот документ содержит пошаговые инструкции, показывающие, как выполнять расширенные задачи с рабочим процессом кодировщика мультимедиа ценовой категории "Премиум", а также как создавать сложные рабочие процессы в конструкторе рабочих процессов.
services: media-services
documentationcenter: ''
author: xstof
manager: cfowler
editor: ''
ms.assetid: 1ba52865-b4a8-4ca0-ac96-920d55b9d15b
ms.service: media-services
ms.workload: media
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 07/19/2017
ms.author: christoc;xpouyat;juliako
ms.openlocfilehash: 3cba7a6a8bf6fbe199664b738b68ceca3a7746f8
ms.sourcegitcommit: e221d1a2e0fb245610a6dd886e7e74c362f06467
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/07/2018
ms.locfileid: "33783953"
---
# <a name="advanced-media-encoder-premium-workflow-tutorials"></a>Руководства по расширенному рабочему процессу кодировщика мультимедиа
## <a name="overview"></a>Обзор
Этот документ содержит пошаговые инструкции, описывающие способы настройки рабочих процессов с помощью **конструктора рабочих процессов**. Файлы фактического рабочего процесса можно найти [здесь](https://github.com/Azure/azure-media-services-samples/tree/master/Encoding%20Presets/VoD/MediaEncoderPremiumWorkfows/PremiumEncoderWorkflowSamples).  

## <a name="toc"></a>ОГЛАВЛЕНИЕ
В этой статье содержатся следующие разделы.

* [Кодирование MXF в файл MP4 с одной скоростью](media-services-media-encoder-premium-workflow-tutorials.md#MXF_to_MP4)
  * [Запуск нового рабочего процесса](media-services-media-encoder-premium-workflow-tutorials.md#MXF_to_MP4_start_new)
  * [Добавление входного файла мультимедиа](media-services-media-encoder-premium-workflow-tutorials.md#MXF_to_MP4_with_file_input)
  * [Проверка потоков мультимедиа](media-services-media-encoder-premium-workflow-tutorials.md#MXF_to_MP4_streams)
  * [Добавление видеокодировщика для создания файла MP4](media-services-media-encoder-premium-workflow-tutorials.md#MXF_to_MP4_file_generation)
  * [Кодирование аудиопотока](media-services-media-encoder-premium-workflow-tutorials.md#MXF_to_MP4_audio)
  * [Мультиплексирование аудио- и видеопотоков в контейнер MP4](media-services-media-encoder-premium-workflow-tutorials.md#MXF_to_MP4_audio_and_fideo)
  * [Запись файла MP4](media-services-media-encoder-premium-workflow-tutorials.md#MXF_to_MP4_writing_mp4)
  * [Создание ресурса-контейнера служб мультимедиа из выходного файла](media-services-media-encoder-premium-workflow-tutorials.md#MXF_to_MP4_asset_from_output)
  * [Локальное тестирование завершенного рабочего процесса](media-services-media-encoder-premium-workflow-tutorials.md#MXF_to_MP4_test)
* [Кодирование MXF в файлы MP4 с несколькими скоростями со включенной динамической упаковкой](media-services-media-encoder-premium-workflow-tutorials.md#MXF_to_MP4_with_dyn_packaging)
  * [Добавление одного или нескольких дополнительных выходных файлов MP4](media-services-media-encoder-premium-workflow-tutorials.md#MXF_to_MP4_with_dyn_packaging_more_outputs)
  * [Настройка имен для выходных файлов](media-services-media-encoder-premium-workflow-tutorials.md#MXF_to_MP4_with_dyn_packaging_conf_output_names)
  * [Добавление отдельной звуковой дорожки](media-services-media-encoder-premium-workflow-tutorials.md#MXF_to_MP4_with_dyn_packaging_audio_tracks)
  * [Добавление ISM-файла SMIL](media-services-media-encoder-premium-workflow-tutorials.md#MXF_to_MP4_with_dyn_packaging_ism_file)
* [Расширенная схема кодирования файла MXF в файл MP4 с несколькими скоростями](media-services-media-encoder-premium-workflow-tutorials.md#MXF_to__multibitrate_MP4)
  * [Обзор улучшаемого рабочего процесса](#workflow-overview-to-enhance)
  * [Соглашения об именовании файлов](media-services-media-encoder-premium-workflow-tutorials.md#MXF_to__multibitrate_MP4_file_naming)
  * [Публикация свойств компонентов в корне рабочего процесса](media-services-media-encoder-premium-workflow-tutorials.md#MXF_to__multibitrate_MP4_publishing)
  * [Создание зависимости имен созданных выходных файлов от значений опубликованных свойств](media-services-media-encoder-premium-workflow-tutorials.md#MXF_to__multibitrate_MP4_output_files)
* [Добавление эскизов к выходным файлам MP4 с несколькими скоростями](media-services-media-encoder-premium-workflow-tutorials.md#thumbnails_to__multibitrate_MP4)
  * [Обзор рабочего процесса, в котором добавляются эскизы](#workflow-overview-to-add-thumbnails-to)
  * [Добавление кодировки JPG](media-services-media-encoder-premium-workflow-tutorials.md#thumbnails_to__multibitrate_MP4__with_jpg)
  * [Работа с преобразованием цветового пространства](media-services-media-encoder-premium-workflow-tutorials.md#thumbnails_to__multibitrate_MP4_color_space)
  * [Создание эскизов](media-services-media-encoder-premium-workflow-tutorials.md#thumbnails_to__multibitrate_MP4_writing_thumbnails)
  * [Обнаружение ошибок в рабочем процессе](media-services-media-encoder-premium-workflow-tutorials.md#thumbnails_to__multibitrate_MP4_errors)
  * [Завершенный рабочий процесс](media-services-media-encoder-premium-workflow-tutorials.md#thumbnails_to__multibitrate_MP4_finish)
* [Обрезка выходных файлов MP4 с несколькими скоростями по времени](media-services-media-encoder-premium-workflow-tutorials.md#time_based_trim)
  * [Обзор рабочего процесса, в котором будет выполняться обрезка](media-services-media-encoder-premium-workflow-tutorials.md#time_based_trim_start)
  * [Использование компонента обрезки потока](media-services-media-encoder-premium-workflow-tutorials.md#time_based_trim_use_stream_trimmer)
  * [Завершенный рабочий процесс](media-services-media-encoder-premium-workflow-tutorials.md#time_based_trim_finish)
* [Добавление компонента сценариев](media-services-media-encoder-premium-workflow-tutorials.md#scripting)
  * [Создание сценариев в рабочем процессе: hello world](media-services-media-encoder-premium-workflow-tutorials.md#scripting_hello_world)
* [Обрезка выходных файлов MP4 с несколькими скоростями по кадрам](media-services-media-encoder-premium-workflow-tutorials.md#frame_based_trim)
  * [Обзор схемы, в которой будет выполняться обрезка](media-services-media-encoder-premium-workflow-tutorials.md#frame_based_trim_start)
  * [Использование XML-файла со списком клипов](media-services-media-encoder-premium-workflow-tutorials.md#frame_based_trim_clip_list)
  * [Изменение списка клипов в компоненте сценариев](media-services-media-encoder-premium-workflow-tutorials.md#frame_based_trim_modify_clip_list)
  * [Добавление удобного свойства ClippingEnabled](media-services-media-encoder-premium-workflow-tutorials.md#frame_based_trim_clippingenabled_prop)

## <a id="MXF_to_MP4"></a>Кодирование MXF в файл MP4 с одной скоростью
В этом разделе показано, как из входного файла MXF создать аудиофайл MP4 с одной скоростью, используя кодирование AAC-HE.

### <a id="MXF_to_MP4_start_new"></a>Запуск нового рабочего процесса
Откройте конструктор рабочих процессов и последовательно щелкните "File" > "New Workspace" > "Transcode Blueprint" (Файл > Создать рабочую область > Схема перекодирования).

В новом рабочем процессе отобразятся три элемента:

* основной исходный файл;
* XML-файл списка клипов;
* выходной файл и ресурс-контейнер.  

![Новый рабочий процесс кодирования](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-transcode-blueprint.png)

*Новый рабочий процесс кодирования*

### <a id="MXF_to_MP4_with_file_input"></a>Добавление входного файла мультимедиа
Чтобы добавить входной файл мультимедиа, в соответствующую область нужно добавить необходимый компонент. Чтобы добавить компонент в рабочий процесс, найдите его в репозитории и перетащите нужную запись в соответствующую область конструктора. Перетащите запись в область входных файлов мультимедиа и соедините компонент основного исходного файла с входной точкой области "Media File Input" (Входные файлы мультимедиа).

![Соединение области "Входные файлы мультимедиа"](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-file-input.png)

*Соединение области "Входные файлы мультимедиа"*

Сначала укажите подходящий пример файла для использования при проектировании пользовательского рабочего процесса. Для этого щелкните фон области конструктора и найдите свойство основного исходного файла на панели свойств справа. Щелкните значок папки и выберите нужный файл для тестирования рабочего процесса. После этого компонент входного файла мультимедиа проверит файл и создаст для него выходные точки с учетом сведений проверяемого примера файла.

![Заполненная область "Входные файлы мультимедиа"](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-populated-media-file-input.png)

*Заполненная область "Входные файлы мультимедиа"*

Теперь, когда область входных файлов заполнена, настройте параметры кодирования выходных данных. Так же как мы указали основной исходный файл, укажите в поле ниже свойство "Переменная папки выходных данных".

![Указанные свойства входных и выходных данных](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-configured-io-properties.png)

*Указанные свойства входных и выходных данных*

### <a id="MXF_to_MP4_streams"></a>Проверка потоков мультимедиа
Часто нам необходимо знать, как выглядит поток, выполняемый в рабочем процессе. Чтобы проверить поток в любой точке рабочего процесса, просто щелкните входную или выходную точку в любом компоненте. В этом случае в области "Media File Input" (Входные файлы мультимедиа) щелкните выходную точку компонента "Uncompressed Video" (Видео без сжатия). Откроется диалоговое окно, в котором можно просмотреть информацию о конечном видеофайле.

![Просмотр сведений о конечном видеофайле потока "Видео без сжатия"](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-inspecting-uncompressed-video-output.png)

*Просмотр сведений о конечном видеофайле потока "Видео без сжатия"*

На рисунке выше показано, что входной видеофайл имеет разрешение 1920 x 1080, скорость 24 кадра в секунду, формат выборки 4:2:2 и продолжительность почти 2 минуты.

### <a id="MXF_to_MP4_file_generation"></a>Добавление видеокодировщика для создания файла MP4
Теперь в области входных файлов мультимедиа есть несколько точек выходных соединений: одна для компонента "Uncompressed Video" (Видео без сжатия) и по одной для каждого компонента "Uncompressed Audio" (Аудио без сжатия). Для кодирования входящего видеопотока нужно добавить компонент кодирования. В нашем примере этот компонент нужен для создания файлов MP4.

Для кодирования видеопотока в стандарте H.264 добавьте в рабочую область конструктора компонент видеокодировщика AVC. Этот компонент преобразовывает видеопоток без сжатия в сжатый видеопоток AVC в соответствующей выходной точке.

![Несоединенный кодировщик AVC](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-unconnected-avc-encoder.png)

*Несоединенный кодировщик AVC*

Свойства компонента определяют, как именно происходит кодирование. Давайте рассмотрим некоторые более важные параметры.

* Ширина и высота выходного файла. Определяет разрешение кодированного видео. В этом случае подходящее значение параметра — 640 x 360.
* Частота кадров. Если для этого параметра установлена сквозная передача значения, он примет значение исходной частоты кадров. Значение можно изменять. Такое преобразование частоты кадров не предусматривает компенсацию движения.
* Профиль и уровень. Определяет профиль и уровень AVC. Чтобы получить дополнительные сведения о разных уровнях и профилях, щелкните значок с вопросительным знаком в компоненте видеокодировщика AVC. На странице справки отобразится подробная информация о каждом уровне. В нашем примере используйте основной профиль с уровнем 3.2 (значение по умолчанию).
* Режим управления скоростью и скорость (Кбит/с). В этом сценарии для выходного файла выберите постоянную скоростью (CBR) 1200 Кбит/с.
* Формат видео. Представляет информацию о практическом использовании видео, которая записывается в поток H.264 (дополнительные сведения, которые может использовать декодер для улучшения отображения; они необязательны для правильного декодирования):
* NTSC (формат для США и Японии, используется скорость 30 кадров/с);
* PAL (формат для Европы, используется скорость 25 кадров/с).
* Режим размера группы изображений (GOP). Для наших целей задайте фиксированный размер групп GOP, интервал опорных кадров в 2 секунды и закрытые группы GOP. Такой интервал обеспечивает совместимость с динамической упаковкой, предоставляемой Службами мультимедиа Azure.

Чтобы передать поток в кодировщик AVC, соедините выходную точку видео без сжатия в компоненте "Media File Input" (Входные файлы мультимедиа) с входной точкой видео без сжатия в компоненте "AVC Encoder" (Видеокодировщик AVC).

![Соединенный кодировщик AVC](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-connected-avc-encoder.png)

*Соединение основного кодировщика AVC*

### <a id="MXF_to_MP4_audio"></a>Кодирование аудиопотока
На этом этапе нам осталось сжать исходный аудиопоток. Для этого добавьте компонент кодировщика AAC (Dolby) в рабочий процесс.

![Несоединенный кодировщик AVC](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-unconnected-aac-encoder.png)

*Несоединенный кодировщик AAC*

Получается неувязка: в кодировщике AAC есть только одна входная точка несжатого аудиопотока, тогда как во входном файле мультимедиа, скорее всего, будет два несжатых аудиопотока (по одному для левого и правого аудиоканалов). Если речь идет об объемном звучании, каналов будет шесть. Таким образом, мы не можем напрямую соединить аудио из исходного файла мультимедиа с аудиокодировщиком AAC. Для компонента AAC требуется так называемый "чередующийся" аудиопоток, т. е. один поток, в котором чередуются левый и правый каналы. Когда мы узнаем позицию звуковых дорожек в исходном файле мультимедиа, мы сможем создать чередующийся аудиопоток, в котором будут правильно назначены правый и левый динамики.

Сначала нужно создать чередующийся поток из необходимых исходных аудиоканалов. Для этого можно использовать компонент чередования аудиопотоков. Добавьте его в рабочий процесс и соедините с ним аудиопотоки из входного файла мультимедиа.

![Соединение компонента чередования аудиопотоков](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-connected-audio-stream-interleaver.png)

*Соединение компонента чередования аудиопотоков*

Теперь у нас есть чередующийся аудиопоток, но мы так и не указали положение для левого и правого динамиков. Для этого можно использовать компонент "Назначение положения динамиков".

![Добавление компонента "Назначение положения динамиков"](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-adding-speaker-position-assigner.png)

*Добавление компонента "Назначение положения динамиков"*

В компоненте "Speaker Position Assigner" (Назначение положения динамиков) укажите, что используется входной стереопоток. Для этого выберите предустановленный фильтр кодировщика "Пользовательский" и предустановленную настройку каналов "2.0 (L, R)". В результате для левого динамика будет назначен канал 1, а для правого — канал 2.

Соедините выходную точку в компоненте "Назначение положения динамика" со входной точкой в компоненте аудиокодировщика AAC. Затем укажите, что кодировщик AAC должен использовать предустановленную настройку каналов "2.0 (L, R)". Таким образом он будет обрабатывать стереозвук как входной поток.

### <a id="MXF_to_MP4_audio_and_fideo"></a>Мультиплексирование аудио- и видеопотоков в контейнер MP4
Видеопоток в кодировке AVC и аудиопоток в кодировке AAC можно объединить в контейнере MP4. Совмещение различных потоков в один называется мультиплексированием. В нашем случае мы чередуем аудио- и видеопотоки в одном согласованном пакете MP4. Компонент, который координирует этот процесс для контейнера MP4, называется мультиплексором ISO MPEG-4. Добавьте этот компонент в рабочую область конструктора и соедините кодировщики AVC и AAC с его входными точками.

![Соединение мультиплексора MPEG4](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-connected-mpeg4-multiplexer.png)

*Соединение мультиплексора MPEG4*

### <a id="MXF_to_MP4_writing_mp4"></a>Запись файла MP4
Для записи выходного файла используется компонент "Вывод файла". Если соединить этот компонент с выходом мультиплексора ISO MPEG-4, конечный файл будет записан на диск. Чтобы сделать это, соедините выходную точку контейнера (MPEG-4) со входной точкой компонента "Вывод файла".

![Соединение компонента "Вывод файла"](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-connected-file-output.png)

*Соединение компонента "Вывод файла"*

Используемое имя файла определяется свойством "File" (Файл). Хотя конкретное значение этого свойства может быть указано в коде, пользователь, вероятно, захочет определить его с помощью выражения.

Чтобы рабочий процесс автоматически определял свойство имени выходного файла с помощью выражения, нажмите кнопку рядом с именем файла (рядом со значком папки). В раскрывающемся меню выберите пункт "Expression" (Выражение). Откроется редактор выражений. Сначала очистите содержимое редактора.

![Пустой редактор выражений](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-empty-expression-editor.png)

*Пустой редактор выражений*

В редакторе выражений можно ввести любое литеральное значение вместе с одной или несколькими переменными. Переменные начинаются со знака доллара. При нажатии клавиши $ в редакторе отобразится раскрывающийся список с доступными переменными. В нашем примере мы используем сочетание переменной для конечного каталога и переменной для имени основного входного файла.

    ${ROOT_outputWriteDirectory}\\${ROOT_sourceFileBaseName}.MP4

![Редактор выражений с указанным значением](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-expression-editor.png)

*Редактор выражений с указанным значением*

> [!NOTE]
> Чтобы увидеть выходной файл задания кодирования в Azure, в редакторе выражений необходимо ввести значение.
>
>

Подтвердив выражение нажатием кнопки "OK" (OК), в окне свойств вы увидите, каким будет имя выходного файла.

![Полученный из выражения конечный каталог](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-file-expression-resolves-output-dir.png)

*Полученный из выражения конечный каталог*

### <a id="MXF_to_MP4_asset_from_output"></a>Создание ресурса-контейнера служб мультимедиа из выходного файла
Мы уже записали выходной файл MP4, но нам еще нужно указать, что этот файл относится к конечному ресурсу-контейнеру, которые службы мультимедиа создадут в ходе этого рабочего процесса. Для этого в окне конструктора рабочих процессов используется узел "Выходной файл и ресурс-контейнер". Все входящие файлы в этом узле станут частью ресурса-контейнера Служб мультимедиа Azure.

Подключите компонент "Вывод файла" к компоненту "Выходной файл и ресурс-контейнер", чтобы завершить рабочий процесс.

![Завершенный рабочий процесс](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-finished-workflow.png)

*Завершенный рабочий процесс*

### <a id="MXF_to_MP4_test"></a>Локальное тестирование завершенного рабочего процесса
Чтобы локально протестировать рабочий процесс, нажмите кнопку воспроизведения на панели инструментов вверху. Когда рабочий процесс завершится, проверьте полученный результат в заданной папке выходных данных. В ней будет находится готовый выходной файл MP4, созданный из исходного входного файла MXF.

## <a id="MXF_to_MP4_with_dyn_packaging"></a>Кодирование файлов MXF в файлы MP4 с разными скоростями со включенной динамической упаковкой
В этом разделе мы создадим из одного входного файла MXF набор файлов MP4 с несколькими скоростями и аудиокодированием AAC.

Если для конечного ресурса-контейнера с несколькими скоростями вы хотите использовать возможности динамической упаковки (функция службы мультимедиа Azure), вам нужно создать несколько файлов MP4 с одинаковыми группами GOP, но с разной скоростью и разрешением. В качестве отправной точки используйте пошаговую инструкцию по [кодированию файла MXF в файл MP4 с одной скоростью](media-services-media-encoder-premium-workflow-tutorials.md#MXF_to_MP4).

![Запуск рабочего процесса](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-starting-workflow.png)

*Запуск рабочего процесса*

### <a id="MXF_to_MP4_with_dyn_packaging_more_outputs"></a>Добавление одного или нескольких дополнительных выходных файлов MP4
Каждый файл MP4 в конечном ресурсе-контейнере Служб мультимедиа Azure поддерживает разные скорость и разрешение. Давайте добавим в рабочий процесс один или несколько выходных файлов MP4.

Чтобы у всех видеокодировщиков были одинаковые параметры, лучше всего создать дубликат уже существующего видеокодировщика AVC и настроить другие разрешение и скорость. Давайте добавим кодировщик с такими параметрами: 960 x 540, 25 кадров/с и 2,5 Мбит/с. Чтобы создать дубликат существующего кодировщика, скопируйте и вставьте его в рабочую область конструктора.

Соедините выходную точку "Видео без сжатия" в компоненте "Входные файлы мультимедиа" с новым компонентом AVC.

![Соединение со вторым кодировщиком AVC](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-second-avc-encoder-connected.png)

*Соединение со вторым кодировщиком AVC*

Теперь настройте в новом кодировщике AVC параметры выходного файла: 960 x 540 и 2,5 Мбит/с. Эти параметры указываются в свойствах "Ширина выходного файла", "Высота выходного файла" и "Скорость (Кбит/с)".

Так как получившийся ресурс-контейнер будет использоваться с динамической упаковкой (функция служб мультимедиа Azure), передающая конечная точка должна создавать из этих MP4-файлов фрагменты MP4/DASH с поддержкой HLS, которые будут точно согласованы между собой. Так клиенты, переключающиеся между различными скоростями, смогут получать один непрерывный аудио- и видеопоток. Для этого необходимо, чтобы в свойствах обоих кодировщиков AVC размер группы GOP в каждом MP4-файле был равен 2 секундам. Это можно настроить так:

* установите для режима размера GOP фиксированный размер;
* для интервала опорных кадров укажите 2 секунды;
* для управления IDR GOP установите значение "Closed GOP" (Закрытая группа GOP), чтобы все группы GOP были самостоятельными (без зависимостей).

Чтобы вам легче было разобраться в этом рабочем процессе, переименуйте первый кодировщик AVC в "Видеокодировщик AVC 640 x 360 1200 Кбит/с", а второй — в "Видеокодировщик AVC 960 x 540 2500 Кбит/с".

Теперь добавьте второй компонент "Мультиплексор ISO MPEG-4" и второй компонент "Вывод файла". Соедините мультиплексор с новым кодировщиком AVC. Выход мультиплексора должен быть соединен с компонентом "Вывод файла". Соедините также выход аудиокодировщика AAC со входом нового мультиплексора. Затем соедините компонент "Вывод файла" с узлом "Выходной файл и ресурс-контейнер", чтобы добавить выходной файл в создаваемый ресурс-контейнер служб мультимедиа.

![Соединение второго мультиплексора с компонентом "Вывод файла"](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-second-muxer-file-output-connected.png)

*Соединение второго мультиплексора с компонентом "Вывод файла"*

Чтобы обеспечить совместимость с динамической упаковкой служб мультимедиа Azure, установите в мультиплексоре для режима фрагментирования значение "Количество или длительность GOP" и задайте для количества GOP в фрагменте значение 1. (Эти параметры должно быть указаны по умолчанию.)

![Режимы фрагментирования в мультиплексоре](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-muxer-chunk-modes.png)

*Режимы фрагментирования в мультиплексоре*

Примечание: эти действия необходимо повторить для всех файлов с различными комбинациями скорости и разрешения, которые будут добавлены в ресурс-контейнер.

### <a id="MXF_to_MP4_with_dyn_packaging_conf_output_names"></a>Настройка имен для выходных файлов
Мы добавили в конечный ресурс-контейнер несколько файлов. И теперь нам нужно, чтобы имя каждого выходного файла отличалось от имен других файлов. Возможно, нам даже стоит использовать соглашение об именовании, чтобы из имени файла было понятно, с чем мы имеем дело.

Именованием выходных файлов можно управлять с помощью выражений в конструкторе. Откройте панель свойств для одного из компонентов "Вывод файла" и откройте редактор выражений для свойства "Файл". Первый выходной файл был настроен с помощью следующего выражения (см. инструкции по преобразованию [файла MXF в файл MP4 с одной скоростью](media-services-media-encoder-premium-workflow-tutorials.md#MXF_to_MP4)):

    ${ROOT_outputWriteDirectory}\${ROOT_sourceFileBaseName}.MP4

Это означает, что имя файла определяется двумя переменными: конечным каталогом, в который записывается файл, и основным именем исходного файла. Первая переменная выражена свойством в корне рабочего процесса, а вторая зависит от входящего файла. В качестве конечного каталога выступает каталог, используемый для локального тестирования. Это свойство будет переопределено обработчиком рабочего процесса при его выполнении облачным обработчиком мультимедиа в Службах мультимедиа Azure.
Для согласованного присвоения имен обоим выходным файлам измените выражение именования первого файла на такое:

    ${ROOT_outputWriteDirectory}\${ROOT_sourceFileBaseName}_640x360_1.MP4

Для второго файла укажите такое выражение:

    ${ROOT_outputWriteDirectory}\${ROOT_sourceFileBaseName}_960x540_2.MP4

Выполните промежуточный тестовый запуск, чтобы убедиться, что оба выходных файла MP4 создаются должным образом.

### <a id="MXF_to_MP4_with_dyn_packaging_audio_tracks"></a>Добавление отдельной звуковой дорожки
Как будет показано дальше, при создании файла ISM для создаваемых выходных файлов MP4 также потребуется отдельный аудиофайл MP4. Он понадобится в качестве звуковой дорожки для адаптивной потоковой передачи. Чтобы создать этот файл, добавьте в рабочий процесс дополнительный мультиплексор (мультиплексор ISO-MPEG-4) и соедините выходную точку кодировщика AAC со входной точкой дорожки 1.

![Добавление мультиплексора звука](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-audio-muxer-added.png)

*Добавление мультиплексора звука*

Создайте третий компонент "Вывод файла" для вывода потока из мультиплексора и настройте выражение именования файла таким образом:

    ${ROOT_outputWriteDirectory}\${ROOT_sourceFileBaseName}_128kbps_audio.MP4

![Мультиплексор звука создает выходной файл](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-audio-muxer-creating-file-output.png)

*Мультиплексор звука создает выходной файл*

### <a id="MXF_to_MP4_with_dyn_packaging_ism_file"></a>Добавление ISM-файла SMIL
Чтобы обеспечить работу динамической упаковки в сочетании с обоими файлами MP4 (и отдельным аудиофайлом MP4) в ресурсе-контейнере служб мультимедиа, нам также потребуется файл манифеста. Его еще называют файлом SMIL (Synchronized Multimedia Integration Language — язык интеграции синхронизированных мультимедийных данных). Этот файл указывает службам мультимедиа Azure, какие файлы MP4 доступны для динамической упаковки и какие из них необходимо использовать для потоковой передачи звука. Типичный файл манифеста для набора файлов MP4 с одним звуковым потоком выглядит так:

```xml
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>
    <smil xmlns="http://www.w3.org/2001/SMIL20/Language">
      <head>
        <meta name="formats" content="mp4" />
      </head>
      <body>
        <switch>
          <video src="H264_1900kbps_AAC_und_ch2_96kbps.mp4" />
          <video src="H264_1300kbps_AAC_und_ch2_96kbps.mp4" />
          <video src="H264_900kbps_AAC_und_ch2_96kbps.mp4" />
          <audio src="AAC_ch2_96kbps.mp4" title="AAC_und_ch2_96kbps" />
        </switch>
      </body>
    </smil>
```

Файл ISM содержит внутри инструкции switch ссылку на каждый отдельный видеофайл MP4, а также одну или несколько ссылок на айдиофайлы MP4.

Файл манифеста для набора файлов MP4 можно создать с помощью компонента модуля записи манифеста AMS. Чтобы использовать этот компонент, перетащите его в область конструктора и соедините выходную точку "Запись завершена" от трех компонентов вывода файлов со входной точкой "Модуль записи манифеста AMS". Затем соедините выходную точку "Модуль записи манифеста AMS" со входной точкой "Выходной файл и ресурс-контейнер".

Как и для других компонентов вывода файлов, задайте имя выходного ISM-файла с помощью выражения:

    ${ROOT_outputWriteDirectory}\\${ROOT_sourceFileBaseName}_manifest.ism

Завершенный рабочий процесс выглядит так:

![Завершенный рабочий процесс кодирования файла MXF в файл MP4 с несколькими скоростями](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-finished-mxf-to-multibitrate-mp4-workflow.png)

*Завершенный рабочий процесс кодирования файла MXF в файл MP4 с несколькими скоростями*

## <a id="MXF_to__multibitrate_MP4"></a>Расширенная схема кодирования файла MXF в файл MP4 с несколькими скоростями
[Ранее](media-services-media-encoder-premium-workflow-tutorials.md#MXF_to_MP4_with_dyn_packaging) мы рассмотрели, как один входной ресурс-контейнер MXF можно преобразовать в выходной ресурс-контейнер с файлами MP4 с несколькими скоростями, один аудиофайл MP4 и файл манифеста для использования в сочетании с динамической упаковкой в Службах мультимедиа Azure.

В этом разделе показано, как можно улучшить некоторые аспекты и сделать работу более удобной.

### <a id="MXF_to_multibitrate_MP4_overview"></a>Обзор улучшаемого рабочего процесса
![Улучшаемый рабочий процесс для файлов MP4 с несколькими скоростями](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-multibitrate-mp4-workflow-to-enhance.png)

*Улучшаемый рабочий процесс для файлов MP4 с несколькими скоростями*

### <a id="MXF_to__multibitrate_MP4_file_naming"></a>Соглашения об именовании файлов
В предыдущем рабочем процессе в качестве основы для создания имен выходных файлов мы указали простое выражение. Но это влечет повторы — такое выражение используется во всех отдельных компонентах выходных файлов.

Например, в компоненте вывода файла для первого видеофайла используется такое выражение:

    ${ROOT_outputWriteDirectory}\${ROOT_sourceFileBaseName}_640x360_1.MP4

А для второго выходного видеофайла используется такое выражение:

    ${ROOT_outputWriteDirectory}\\${ROOT_sourceFileBaseName}_960x540_2.MP4

Если бы мы могли удалить некоторые повторы, мы бы сделали настройку более гибкой, аккуратной и удобной, не так ли? Кроме того, это позволило бы снизить вероятность возникновения ошибок. К счастью, это возможно. Возможности конструктора в плане выражений и возможность создания пользовательских свойств в корне рабочего процесса позволяют более уверенно работать с именами.

Предположим, что для создания имен файлов будут использоваться скорости отдельных файлов MP4. Эти скорости будут настраиваться в одном месте (в корне нашей диаграммы), откуда они будут считываться при настройке и создании имен файлов. Для этого мы сначала опубликуем свойство скорости из обоих кодировщиков AVC в корне нашего рабочего процесса. Таким образом это свойство будет доступно как из корня, так и из кодировщиков AVC. (Даже при отображении в двух разных местах существует только одно базовое значение.)

### <a id="MXF_to__multibitrate_MP4_publishing"></a>Публикация свойств компонентов в корне рабочего процесса
Откройте первый кодировщик AVC, откройте свойство "Скорость (Кбит/с)" и в раскрывающемся списке выберите пункт "Опубликовать".

![Публикация свойства скорости](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-publishing-bitrate-property.png)

*Публикация свойства скорости*

Измените настройки в диалоговом окне так, чтобы публикация выполнялась в корне диаграммы рабочего процесса. Для опубликованного имени укажите значение "video1bitrate", а для отображаемого имени — "Video 1 Bitrate". Укажите для пользовательской группы имя "Streaming Bitrates" и нажмите кнопку "Опубликовать".

![Публикация свойства скорости](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-publishing-dialog-for-bitrate-property.png)

*Диалоговое окно публикации для свойства скорости*

Повторите эти действия для свойства скорости второго кодировщика AVC, используя имена "video2bitrate" и "Video 2 Bitrate". Используйте ту же пользовательскую группу — "Streaming Bitrates".

Если теперь проверить свойства корня рабочего процесса, мы увидим пользовательскую группу с двумя опубликованными свойствами. Оба свойства отражают значение соответствующей скорости кодировщика AVC.

![Опубликованные свойства скорости в корне рабочего процесса](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-published-bitrate-props-on-workflow-root.png)

Если нам понадобиться передать эти свойства в код или в выражение, это можно сделать:

* в коде компонента, который расположен прямо в корне: node.getPropertyAsString('../video1bitrate', null);
* в выражении: ${ROOT_video1bitrate}.

Давайте опубликуем в группе "Streaming Bitrates" скорость звуковой дорожки. В свойствах кодировщика AAC найдите параметр скорости и в раскрывающемся списке рядом с ним выберите команду "Опубликовать". Опубликуйте его в корне диаграммы с именем "audio1bitrate". Для отображаемого имени укажите значение "Audio 1 Bitrate". Для пользовательской группы задайте все то же имя — "Streaming Bitrates".

![Диалоговое окно публикации для скорости аудиопотока](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-publishing-dialog-for-audio-bitrate.png)

*Диалоговое окно публикации для скорости аудиопотока*

![Итоговые свойства видео и аудио в корне](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-resulting-video-and-audio-props-on-root.png)

*Итоговые свойства видео и аудио в корне*

При изменении любого из этих трех значений изменяются и значения в соответствующих компонентах, с которыми они связаны (и откуда выполняется публикация).

### <a id="MXF_to__multibitrate_MP4_output_files"></a>Создание зависимости имен созданных выходных файлов от значений опубликованных свойств
Вместо того, чтобы прямо указывать в коде имена создаваемых файлов, теперь мы можем изменить выражение имени файла в каждом компоненте вывода файла так, чтобы оно зависело от свойств скорости, опубликованных в корне диаграммы. В первом компоненте вывода файла найдите свойство "Файл" и измените выражение следующим образом:

    ${ROOT_outputWriteDirectory}\${ROOT_sourceFileBaseName}_${ROOT_video1bitrate}kbps.MP4

Чтобы получить доступ к параметрам этого выражения и внести изменения, нажмите знак доллара на клавиатуре, когда открыто окно выражения. Один из доступных параметров — опубликованное ранее свойство video1bitrate.

![Доступ к параметрам в редакторе выражений](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-accessing-parameters-within-an-expression.png)

*Доступ к параметрам в редакторе выражений*

Выполните это же действие в компоненте вывода файла для второго видео:

    ${ROOT_outputWriteDirectory}\${ROOT_sourceFileBaseName}_${ROOT_video2bitrate}kbps.MP4

Сделайте то же самое для аудиофайла:

    ${ROOT_outputWriteDirectory}\${ROOT_sourceFileBaseName}_${ROOT_audio1bitrate}bps_audio.MP4

Если теперь изменить скорость для любого аудио- или видеофайла, соответствующий кодировщик будет перенастроен автоматически, а файлу будет присвоено имя, исходя из значения скорости.

## <a id="thumbnails_to__multibitrate_MP4"></a>Добавление эскизов к выходным файлам MP4 с несколькими скоростями
Используя рабочий процесс, который создает [из входного файла MXF выходной файл MP4 с несколькими скоростями](media-services-media-encoder-premium-workflow-tutorials.md#MXF_to_MP4_with_dyn_packaging), давайте рассмотрим, как в выходной файл можно добавить эскизы.

### <a id="thumbnails_to__multibitrate_MP4_overview"></a>Обзор рабочего процесса, в котором добавляются эскизы
![Рабочий процесс, в котором в файлы MP4 с несколькими скоростями добавляются эскизы](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-multibitrate-mp4-workflow-to-start-from.png)

*Рабочий процесс, в котором в файлы MP4 с несколькими скоростями добавляются эскизы*

### <a id="thumbnails_to__multibitrate_MP4__with_jpg"></a>Добавление кодировки JPG
Центральным элементом создания эскиза будет кодировщик JPG, создающий файлы JPG.

![Кодировщик JPG](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-jpg-encoder.png)

*Кодировщик JPG*

Напрямую соединить поток видео без сжатия из компонента "Входные файлы мультимедиа" с кодировщиком JPG нельзя, так как кодировщик работает с отдельными кадрами. Поэтому мы будем использовать компонент "Шлюз видеокадров".

![Соединение шлюза кадров с кодировщиком JPG](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-connect-frame-gate-to-jpg-encoder.png)

*Соединение шлюза кадров с кодировщиком JPG*

Шлюз пропускает один кадр через каждые несколько секунд или через определенное количество кадров. Интервал и смещение времени для этого действия настраиваются в свойствах.

![Свойства шлюза видеокадров](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-video-frame-gate-properties.png)

*Свойства шлюза видеокадров*

Давайте настроим создание эскизов каждую минуту, установив для параметра "Режим" значение "Время (секунды)", а для параметра "Интервал" — значение 60.

### <a id="thumbnails_to__multibitrate_MP4_color_space"></a>Работа с преобразованием цветового пространства
На первый взгляд, мы можем соединить точки видео без сжатия из компонента "Шлюз видеокадров" и компонента "Входные файлы мультимедиа". Но если так сделать, отобразится предупреждение.

![Ошибка входного цветового пространства](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-input-color-space-error.png)

*Ошибка входного цветового пространства*

Это связано с тем, что способ представления информации о цветах в исходном необработанном видеопотоке без сжатия, поступающем из файла MXF, отличается от способа, необходимого для кодировщика JPG. В частности, в кодировщик JPG должно поступать цветовое пространство RGB или "Оттенки серого". Это означает, что сначала нам нужно преобразовать цветовое пространство видеопотока, поступающего в шлюз видеокадров.

Перетащите в рабочий процесс преобразователь цветового пространства Intel и соедините его со шлюзом кадров.

![Соединение преобразователя цветового пространства](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-connect-color-space-convertor.png)

*Соединение преобразователя цветового пространства*

В окне "Свойства" из списка предустановок выберите вариант BGR 24.

### <a id="thumbnails_to__multibitrate_MP4_writing_thumbnails"></a>Создание эскизов
В отличие от видеофайлов MP4 кодировщик JPG будет создавать несколько файлов. В этом сценарии можно использовать компонент записи файлов JPG для поиска сцен, который записывает эскизы JPG, добавляя к каждому имени файла суффикс с номером. (Номер обычно обозначает число секунд или единиц в потоке, когда был изъят эскиз.)

![Добавление компонента записи файлов JPG для поиска сцен](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-scene-search-jpg-file-writer.png)

*Добавление компонента записи файлов JPG для поиска сцен*

В поле свойства "Путь к папке выходных данных" укажите выражение ${ROOT_outputWriteDirectory}.

В поле свойства "Префикс имени файла" укажите такое выражение:

    ${ROOT_sourceFileBaseName}_thumb_

Префикс определяет правило именования файлов эскизов. В имя файла добавляется суффикс с числом, которое определяет положение эскиза в потоке.

![Свойства компонента записи файлов JPG для поиска сцен](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-scene-search-jpg-file-writer-properties.png)

*Свойства компонента записи файлов JPG для поиска сцен*

Соедините компонент записи файлов JPG для поиска сцен с узлом "Выходной файл и ресурс-контейнер".

### <a id="thumbnails_to__multibitrate_MP4_errors"></a>Обнаружение ошибок в рабочем процессе
Соедините входную точку преобразователя пространства цветов с выходной точкой необработанного видео без сжатия. Теперь локально запустите рабочий процесс, чтобы протестировать его. Есть вероятность, что рабочий процесс неожиданно остановится из-за ошибки. Компонент, в котором произошла ошибка, будет отмечен красным контуром.

![Ошибка преобразователя цветового пространства](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-color-space-converter-error.png)

*Ошибка преобразователя цветового пространства*

Чтобы узнать причину ошибки кодирования, щелкните красный значок с буквой "E" в правом верхнем углу преобразователя цветового пространства.

![Диалоговое окно с ошибкой преобразователя цветового пространства](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-color-space-converter-error-dialog.png)

*Диалоговое окно с ошибкой преобразователя цветового пространства*

Как видно из описания ошибки, стандарт входящего цветового пространства в преобразователе должен иметь значение rec601, чтобы преобразовать YUV в RGB, а в нашем потоке не указано, что он отвечает стандарту rec601. (Rec 601 — это стандарт кодирования чередующихся аналоговых видеосигналов в форме цифрового видео. Этот стандарт указывает активную область, охватывающую 720 отсчетов сигнала яркости и 360 цветовых отсчетов для каждой строки. Эта система кодирования цветов называется YCbCr 4:2:2.)

Чтобы исправить ошибку, в метаданных потока необходимо указать нужный стандарт содержимого (rec601). Для этого мы добавим между необработанным источником и компонентом преобразования цветового пространства компонент обновления типа видеоданных. Этот компонент позволяет вручную обновлять свойства некоторых типов видеоданных. Настройте в нем стандарт цветового пространства Rec 601. Если цветовое пространство ранее не было определено, компонент обновления типа видеоданных добавит для потока метку "Rec 601". (Существующие метаданные не будут переопределены, если не установлен соответствующий флажок.)

![Обновление стандарта цветового пространства в компоненте обновления типа данных](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-update-color-space-standard-on-data-type.png)

*Обновление стандарта цветового пространства в компоненте обновления типа данных*

### <a id="thumbnails_to__multibitrate_MP4_finish"></a>Завершенный рабочий процесс
Теперь, когда рабочий процесс завершен, выполните еще один тестовый запуск, чтобы проверить, все ли в порядке.

![Завершенный рабочий процесс для вывода нескольких файлов MP4 с эскизами](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-finished-workflow-for-multi-mp4-thumbnails.png)

*Завершенный рабочий процесс для вывода нескольких файлов MP4 с эскизами*

## <a id="time_based_trim"></a>Обрезка выходных файлов MP4 с несколькими скоростями по времени
Используя рабочий процесс, который создает [из файла MXF выходной файл MP4 с несколькими скоростями](media-services-media-encoder-premium-workflow-tutorials.md#MXF_to_MP4_with_dyn_packaging), давайте рассмотрим обрезку исходного видео по меткам времени.

### <a id="time_based_trim_start"></a>Обзор рабочего процесса, в котором будет выполняться обрезка
![Рабочий процесс, в котором будет выполняться обрезка](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-starting-workflow-to-add-trimming.png)

*Рабочий процесс, в котором будет выполняться обрезка*

### <a id="time_based_trim_use_stream_trimmer"></a>Использование компонента обрезки потока
Компонент обрезки потока позволяет обрезать начало и конец входного потока, используя информацию о времени (секунды, минуты и т. д.). Компонент не поддерживает обрезку потока по кадрам.

![Компонент обрезки потока](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-stream-trimmer.png)

*Компонент обрезки потока*

Вместо того, чтобы соединить кодировщики AVC и компонент "Назначение положения динамиков" непосредственно с компонентом "Входные файлы мультимедиа", мы поместим между ними компонент обрезки потока. (Один для видеосигнала и один для чередующегося аудиосигнала.)

![Добавление компонента обрезки потока](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-put-stream-trimmer-in-between.png)

*Добавление компонента обрезки потока*

Настроим компонент обрезки так, чтобы на выходе получить видео и аудио между 15 и 60 секундами видео.

Откройте свойства компонента обрезки видеопотока и укажите время начала (15 с) и время окончания (60 с). Чтобы компоненты обрезки аудио и видео всегда использовали одинаковые начальные и конечные точки, необходимо опубликовать эти свойства в корне рабочего процесса.

![Публикация свойства времени начала из компонента обрезки потока](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-publish-start-time-from-stream-trimmer.png)

*Публикация свойства времени начала из компонента обрезки потока*

![Диалоговое окно публикации свойства для времени начала](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-publish-dialog-for-start-time.png)

*Диалоговое окно публикации свойства для времени начала*

![Диалоговое окно публикации свойства для времени окончания](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-publish-dialog-for-end-time.png)

*Диалоговое окно публикации свойства для времени окончания*

Если теперь проверить свойства в корне рабочего процесса, мы увидим там оба наши свойства (их можно изменять).

![Опубликованные свойства, доступные в корне](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-published-properties-available-on-root.png)

*Опубликованные свойства, доступные в корне*

Теперь в компоненте обрезки аудио откройте свойства обрезки и настройте время начала и окончания с помощью выражения, которое ссылается на свойства, опубликованные в корне рабочего процесса.

Для времени начала обрезки аудио:

    ${ROOT_TrimmingStartTime}

Для времени окончания обрезки аудио:

    ${ROOT_TrimmingEndTime}

### <a id="time_based_trim_finish"></a>Завершенный рабочий процесс
![Завершенный рабочий процесс](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-finished-workflow-time-base-trimming.png)

*Завершенный рабочий процесс*

## <a id="scripting"></a>Добавление компонента сценариев
Компоненты сценариев могут выполнять разные сценарии на этапах выполнения рабочего процесса. Есть четыре сценария, которые можно выполнять. Каждый из них имеет определенные характеристики и занимает определенное место в жизненном цикле рабочего процесса:

* **commandScript**
* **realizeScript**
* **processInputScript**
* **lifeCycleScript**

Дополнительные сведения о каждом из указанных выше сценариев можно найти в документации по компоненту сценариев. В [следующем разделе](media-services-media-encoder-premium-workflow-tutorials.md#frame_based_trim)компонент сценария **realizeScript** используется для оперативного создания XML-файла со списком клипов при запуске рабочего процесса. Этот сценарий вызывается во время настройки компонента, что происходит только раз за весь его жизненный цикл.

### <a id="scripting_hello_world"></a>Создание сценариев в рабочем процессе: hello world
Перетащите компонент сценариев в рабочую область конструктора и переименуйте его (например, SetClipListXML).

![Добавление компонента сценариев](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-add-scripted-comp.png)

*Добавление компонента сценариев*

Если открыть свойства компонента сценариев, вы увидите четыре типа сценариев, каждый из которых можно настроить для разных сценариев.

![Свойства компонента сценариев](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-scripted-comp-properties.png)

*Свойства компонента сценариев*

Очистите поле processInputScript и откройте редактор для поля realizeScript. Теперь можно приступать к созданию сценария.

Для написания сценариев используется язык Groovy — динамически скомпилированный язык сценариев для платформы Java, который сохраняет совместимость с Java. Фактически, практически весь код Java можно использовать в качестве кода Groovy.

В контексте нашего сценария realizeScript давайте напишем простой сценарий на языке Groovy. Пусть это будет "hello world". В редакторе введите следующий код:

    node.log("hello world");

Теперь выполните локальный тестовый запуск. После этого проверьте свойство "Журналы" (на вкладке "Система" в компоненте сценариев).

![Запись "hello world" в журнале](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-log-output.png)

*Запись "hello world" в журнале*

Объект узла, для которого вызывается метод журнала, ссылается на текущий узел или компонент, в котором создается сценарий. Каждый компонент может выводить данные в журнал. Эти данные можно просмотреть на вкладке "Система". В нашем случае мы вывели в журнал строковый литерал "hello world". Важно понимать, что это может быть ценным средством отладки, которое предоставляет подробные сведения о том, какие действия фактически выполняет сценарий.

Среда написания сценариев может получить также свойства других компонентов. Попробуйте выполните следующее.

```java
    //inspect current node:
    def nodepath = node.getNodePath();
    node.log("this node path: " + nodepath);

    //walking up to other nodes:
    def parentnode = node.getParentNode();
    def parentnodepath = parentnode.getNodePath();
    node.log("parent node path: " + parentnodepath);

    //read properties from a node:
    def sourceFileExt = parentnode.getPropertyAsString( "sourceFileExtension", null );
    def sourceFileName = parentnode.getPropertyAsString("sourceFileBaseName", null);
    node.log("source file name with extension " + sourceFileExt + " is: " + sourceFileName);
```

В окне журнала отобразятся следующие сведения:

![Вывод журнала для доступа к путям узла](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-log-output2.png)

*Вывод журнала для доступа к путям узла*

## <a id="frame_based_trim"></a>Обрезка выходных файлов MP4 с несколькими скоростями по кадрам
Используя рабочий процесс, который создает [из файла MXF выходной файл MP4 с несколькими скоростями](media-services-media-encoder-premium-workflow-tutorials.md#MXF_to_MP4_with_dyn_packaging), давайте рассмотрим обрезку исходного видео по количеству кадров.

### <a id="frame_based_trim_start"></a>Обзор схемы, в которой будет выполняться обрезка
![Рабочий процесс, в котором будет выполняться обрезка](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-workflow-start-adding-trimming-to.png)

*Рабочий процесс, в котором будет выполняться обрезка*

### <a id="frame_based_trim_clip_list"></a>Использование XML-файла со списком клипов
Во всех предыдущих разделах мы использовали в качестве источника видео компонент "Входные файлы мультимедиа". Сейчас же мы будем использовать компонент "Источник списка клипов". Использовать источник списка клипов следует только тогда, когда для этого есть реальная причина (как в описанном ниже случае, когда используются возможности обрезки списка клипов).

Чтобы заменить компонент "Входные файлы мультимедиа" компонентом "Источник списка клипов", перетащите последний в рабочую область конструктора и соедините выходную точку компонента "XML-файл списка клипов" со входной точкой "XML-файл списка клипов" в компоненте "Источник списка клипов". В результате в компоненте источника списка клипов появятся выходные точки, соответствующие входному видео. Теперь соедините точки "Uncompressed Video" (Видео без сжатия) и "Uncompressed Audio" (Аудио без сжатия) в компоненте источника списка клипов с соответствующими точками кодировщика AVC и компонента чередования аудиопотоков. Затем удалите компонент "Входные файлы мультимедиа".

![Замена компонента "Входные файлы мультимедиа" компонентом "Источник списка клипов"](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-replaced-media-file-with-clip-source.png)

*Замена компонента "Входные файлы мультимедиа" компонентом "Источник списка клипов"*

В качестве входных данных компонент источника списка клипов принимает XML-файл со списком клипов. При выборе исходного файла для локального тестирования поле XML-файла заполняется автоматически.

![Автоматически заполненное свойство "XML-файл списка клипов"](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-auto-populated-clip-list-xml-property.png)

*Автоматически заполненное свойство "XML-файл списка клипов"*

Содержимое XML-файла выглядит так:

![Диалоговое окно изменения списка клипов](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-edit-clip-list-dialog.png)

*Диалоговое окно изменения списка клипов*

Однако это не отражает все возможности нашего XML-файла. Одной из таких возможностей является добавление элемента Trim под источником видео и аудио, как показано ниже:

![Добавление элемента Trim в список клипов](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-adding-trim-element-to-clip-list.png)

*Добавление элемента Trim в список клипов*

Если изменить XML-файл со списком клипов, как показано выше, и выполнить локальный тестовый запуск, вы увидите, что видео обрезалось точно между 10 и 20 секундами видео.

Если сравнивать с локальным запуском, этот же XML-файл со списком клипов будет работать иначе при использовании в рабочем процессе в Службах мультимедиа Azure. При запуске кодировщика Azure ценовой категории "Премиум" XML-файл со списком клипов каждый раз создается снова на основе входного файла, который был предоставлен для задания кодирования. Это означает, что любые изменения, внесенные в XML-файл, к сожалению, будут перезаписаны.

Чтобы решить эту проблему, мы можем повторно создать XML-файл сразу после начала рабочего процесса. Такие действия можно выполнять с помощью компонента сценариев. Дополнительные сведения см. в разделе [Добавление компонента сценариев](media-services-media-encoder-premium-workflow-tutorials.md#scripting).

Перетащите компонент сценариев в рабочую область конструктора и переименуйте его в SetClipListXML.

![Добавление компонента сценариев](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-add-scripted-comp.png)

*Добавление компонента сценариев*

Если открыть свойства компонента сценариев, вы увидите четыре типа сценариев, каждый из которых можно настроить для разных сценариев.

![Свойства компонента сценариев](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-scripted-comp-properties.png)

*Свойства компонента сценариев*

### <a id="frame_based_trim_modify_clip_list"></a>Изменение списка клипов в компоненте сценариев
Прежде чем повторно создавать XML-файл со списком клипов, который создается при запуске рабочего процесса, необходимо получить доступ к свойству и содержимому XML-файла. Это можно сделать следующим образом.

```java
    // get cliplist xml:
    def clipListXML = node.getProperty("../clipListXml");
    node.log("clip list xml coming in: " + clipListXML);
```

![Записи о входящем списке клипов в журнале](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-incoming-clip-list-logged.png)

*Записи о входящем списке клипов в журнале*

Сначала нам нужно понять, как мы будем определять точки, между которыми необходимо обрезать видео. Для удобства менее опытных пользователей рабочего процесса, мы опубликуем два свойства в корне схемы. Для этого щелкните правой кнопкой мыши рабочую область конструктора и выберите команду "Add Property" (Добавить свойство).

* Первое свойство — ClippingTimeStart. Тип — TIMECODE.
* Второе свойство — ClippingTimeEnd. Тип — TIMECODE.

![Диалоговое окно добавления свойства для времени начала обрезки](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-clip-start-time.png)

*Диалоговое окно добавления свойства для времени начала обрезки*

![Опубликованные свойства времени обрезки в корне рабочего процесса](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-clip-time-props.png)

*Опубликованные свойства времени обрезки в корне рабочего процесса*

Настройте для обоих свойств подходящие значения.

![Настройка свойств начала и окончания обрезки](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-configure-clip-start-end-prop.png)

*Настройка свойств начала и окончания обрезки*

Теперь оба свойства можно передать в сценарий.

```java
    // get start and end of clipping:
    def clipstart = node.getProperty("../ClippingTimeStart").toString();
    def clipend = node.getProperty("../ClippingTimeEnd").toString();

    node.log("clipping start: " + clipstart);
    node.log("clipping end: " + clipend);
```

![Окно журнала, показывающее начало и конец обрезки](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-show-start-end-clip.png)

*Окно журнала, показывающее начало и конец обрезки*

Давайте преобразуем строки с кодами времени в более простой и удобный для использования формат. Для этого мы воспользуемся простым регулярным выражением.

```java
    //parse the start timing:
    def startregresult = (~/(\d\d:\d\d:\d\d:\d\d)\/(\d\d)/).matcher(clipstart);
    startregresult.matches();
    def starttimecode = startregresult.group(1);
    node.log("timecode start is: " + starttimecode);
    def startframerate = startregresult.group(2);
    node.log("framerate start is: " + startframerate);

    //parse the end timing:
    def endregresult = (~/(\d\d:\d\d:\d\d:\d\d)\/(\d\d)/).matcher(clipend);
    endregresult.matches();
    def endtimecode = endregresult.group(1);
    node.log("timecode end is: " + endtimecode);
    def endframerate = endregresult.group(2);
    node.log("framerate end is: " + endframerate);
```

![Окно журнала с преобразованными кодами времени](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-output-parsed-timecode.png)

*Окно журнала с преобразованными кодами времени*

Имея эту информацию, мы можем точно изменить в XML-файле со списком клипов время начала и окончания кадров фильма.

![Сценарий для добавления элементов обрезки](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-add-trim-elements.png)

*Сценарий для добавления элементов обрезки*

Мы это сделали с помощью обычных операций по обработке строк. Получившийся измененный XML-файл со списком клипов записывается в свойство clipListXML в корне рабочего процесса с помощью метода setProperty. Окно журнала после еще одного тестового запуска будет показывать следующую информацию.

![Записи в журнале о полученном списке клипов](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-log-result-clip-list.png)

*Записи в журнале о полученном списке клипов*

Выполните тестовый запуск, чтобы проверить, как обрезаются потоки аудио и видео. Выполняя несколько тестовых запусков с различными значениями для точек обрезки, вы заметите, что они не учитываются. Причина заключается в том, что конструктор, в отличие от среды выполнения Azure, НЕ перезаписывает XML-файл при каждом выполнении. Это означает, что преобразование XML-файла будет происходить только при первой установке точек входа и выхода. После этого условие (if(clipListXML.indexOf("<trim>") == -1)) будет запрещать рабочему процессу добавлять другой элемент обрезки, если один элемент уже присутствует.

Чтобы нам было удобно тестировать рабочий процесс локально, мы добавим служебный код, проверяющий наличие элемента обрезки. Если элемент обрезки уже есть, прежде чем продолжить, мы можем удалить его, внеся в XML-файл новые значения. Чтобы не использовать простые операции со строками, безопаснее будет сделать это с помощью анализа модели реального объекта XML.

Перед добавлением такого кода нам нужно добавить несколько инструкций импорта в начало нашего сценария.

```java
    import javax.xml.parsers.*;
    import org.xml.sax.*;
    import org.w3c.dom.*;
    import javax.xml.*;
    import javax.xml.xpath.*;
    import javax.xml.transform.*;
    import javax.xml.transform.stream.*;
    import javax.xml.transform.dom.*;
```

После этого можно добавить необходимый код очистки.

```java
    //for local testing: delete any pre-existing trim elements from the clip list xml by parsing the xml into a DOM:
    DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
    DocumentBuilder builder=factory.newDocumentBuilder();
    InputSource is=new InputSource(new StringReader(clipListXML));
    Document dom=builder.parse(is);

    //find the trim element inside videoSource and audioSource and remove it if it exists already:
    XPath xpath = XPathFactory.newInstance().newXPath();
    String findAllTrimElements = "//trim";
    NodeList trimelems = xpath.evaluate(findAllTrimElements,dom,XPathConstants.NODESET);

    //copy trim nodes into a "to-be-deleted" collection
    Set<Element> elementsToDelete = new HashSet<Element>();
    for (int i = 0; i < trimelems.getLength(); i++) {
        Element e = (Element)trimelems.item(i);
        elementsToDelete.add(e);
    }

    node.log("about to delete any existing trim nodes");
     //delete the trim nodes:
    elementsToDelete.each{
        e -> e.getParentNode().removeChild(e);
    };
    node.log("deleted any existing trim nodes");

    //serialize the modified clip list xml dom into a string:
    def transformer = TransformerFactory.newInstance().newTransformer();
    StreamResult result = new StreamResult(new StringWriter());
    DOMSource source = new DOMSource(dom);
    transformer.transform(source, result);
    clipListXML = result.getWriter().toString();
```

Этот код добавляется точно перед местом, в котором мы добавляем в XML-файл элементы обрезки.

Теперь мы можем запускать и изменять рабочий процесс сколько угодно — и каждый раз новые значения будут учитываться.    

### <a id="frame_based_trim_clippingenabled_prop"></a>Добавление удобного свойства ClippingEnabled
Поскольку нам не всегда нужно обрезать поток, давайте завершим работу с нашим рабочим процессом, добавив удобный логический флаг, который указывает, нужно ли включать обрезку.

Как и раньше, опубликуйте в корень рабочего процесса новое свойство с именем ClippingEnabled типа BOOLEAN.

![Публикация свойства для включения обрезки](./media/media-services-media-encoder-premium-workflow-tutorials/media-services-enable-clip.png)

*Публикация свойства для включения обрезки*

С помощью приведенного ниже простого защитного предложение мы можем проверить, требуется ли обрезка, чтобы решить, нужно ли изменять список клипов.

```java
    //check if clipping is required:
    def clippingrequired = node.getProperty("../ClippingEnabled");
    node.log("clipping required: " + clippingrequired.toString());
    if(clippingrequired == null || clippingrequired == false)
    {
        node.setProperty("../clipListXml",clipListXML);
        node.log("no clipping required");
        return;
    }
```

### <a id="code"></a>Полный код

```java
    import javax.xml.parsers.*;
    import org.xml.sax.*;
    import org.w3c.dom.*;
    import javax.xml.*;
    import javax.xml.xpath.*;
    import javax.xml.transform.*;
    import javax.xml.transform.stream.*;
    import javax.xml.transform.dom.*;

    // get cliplist xml:
    def clipListXML = node.getProperty("../clipListXml");
    node.log("clip list xml coming in: \n" + clipListXML);
    // get start and end of clipping:
    def clipstart = node.getProperty("../ClippingTimeStart").toString();
    def clipend = node.getProperty("../ClippingTimeEnd").toString();

    //parse the start timing:
    def startregresult = (~/(\d\d:\d\d:\d\d:\d\d)\/(\d\d)/).matcher(clipstart);
    startregresult.matches();
    def starttimecode = startregresult.group(1);
    node.log("timecode start is: " + starttimecode);
    def startframerate = startregresult.group(2);
    node.log("framerate start is: " + startframerate);

    //parse the end timing:
    def endregresult = (~/(\d\d:\d\d:\d\d:\d\d)\/(\d\d)/).matcher(clipend);
    endregresult.matches();
    def endtimecode = endregresult.group(1);
    node.log("timecode end is: " + endtimecode);
    def endframerate = endregresult.group(2);

    node.log("framerate end is: " + endframerate);

    //for local testing: delete any pre-existing trim elements
    //from the clip list xml by parsing the xml into a DOM:

    DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
    DocumentBuilder builder=factory.newDocumentBuilder();
    InputSource is=new InputSource(new StringReader(clipListXML));
    Document dom=builder.parse(is);

    //find the trim element inside videoSource and audioSource and remove it if it exists already:
    XPath xpath = XPathFactory.newInstance().newXPath();
    String findAllTrimElements = "//trim";
    NodeList trimelems = xpath.evaluate(findAllTrimElements, dom, XPathConstants.NODESET);

    //copy trim nodes into a "to-be-deleted" collection
    Set<Element> elementsToDelete = new HashSet<Element>();
    for (int i = 0; i < trimelems.getLength(); i++) {
        Element e = (Element)trimelems.item(i);
        elementsToDelete.add(e);
    }

    node.log("about to delete any existing trim nodes");
    //delete the trim nodes:
    elementsToDelete.each{ e ->
        e.getParentNode().removeChild(e);
    };
    node.log("deleted any existing trim nodes");

    //serialize the modified clip list xml dom into a string:
    def transformer = TransformerFactory.newInstance().newTransformer();
    StreamResult result = new StreamResult(new StringWriter());
    DOMSource source = new DOMSource(dom);
    transformer.transform(source, result);
    clipListXML = result.getWriter().toString();

    //check if clipping is required:
    def clippingrequired = node.getProperty("../ClippingEnabled");
    node.log("clipping required: " + clippingrequired.toString());
    if(clippingrequired == null || clippingrequired == false)
    {
        node.setProperty("../clipListXml",clipListXML);
        node.log("no clipping required");
        return;
    }

    //add trim elements to cliplist xml
    if ( clipListXML.indexOf("<trim>") == -1 )
    {
        //trim video
        clipListXML = clipListXML.replace("<videoSource>","<videoSource>\n <trim>\n <inPoint fps=\""+
            startframerate +"\">" + starttimecode +
            "</inPoint>\n" + "<outPoint fps=\"" + endframerate +"\"> " + endtimecode +
            " </outPoint>\n </trim> \n");
        //trim audio
        clipListXML = clipListXML.replace("<audioSource>","<audioSource>\n <trim>\n <inPoint fps=\""+
            startframerate +"\">" + starttimecode +
            "</inPoint>\n" + "<outPoint fps=\""+ endframerate +"\">" +
            endtimecode + "</outPoint>\n </trim>\n");
        node.log( "clip list going out: \n" +clipListXML );
        node.setProperty("../clipListXml",clipListXML);
    }
```

## <a name="also-see"></a>См. также:
[Знакомство со Службой кодирования категории "Премиум" в службах мультимедиа Azure](http://azure.microsoft.com/blog/2015/03/05/introducing-premium-encoding-in-azure-media-services)

[Использование Службы кодирования категории "Премиум" в службах мультимедиа Azure](http://azure.microsoft.com/blog/2015/03/06/how-to-use-premium-encoding-in-azure-media-services)

[Обзор и сравнение кодировщиков мультимедиа Azure по запросу](media-services-encode-asset.md#media-encoder-premium-workflow)

[Форматы и кодеки рабочего процесса Premium Media Encoder](media-services-premium-workflow-encoder-formats.md)

[Примеры файлов рабочего процесса](http://github.com/Azure/azure-media-services-samples/tree/master/Encoding%20Presets/VoD/MediaEncoderPremiumWorkfows)

[Средство Explorer для служб мультимедиа Azure](http://aka.ms/amse)

## <a name="media-services-learning-paths"></a>Схемы обучения работе со службами мультимедиа
[!INCLUDE [media-services-learning-paths-include](../../../includes/media-services-learning-paths-include.md)]

## <a name="provide-feedback"></a>Отзывы
[!INCLUDE [media-services-user-voice-include](../../../includes/media-services-user-voice-include.md)]
