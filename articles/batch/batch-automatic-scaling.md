---
title: Автомасштабирование вычислительных узлов в пуле пакетной службы Azure | Документация Майкрософт
description: Включение автоматического масштабирования в облачном пуле для динамического изменения количества вычислительных узлов в пуле.
services: batch
documentationcenter: ''
author: dlepow
manager: jeconnoc
editor: ''
ms.assetid: c624cdfc-c5f2-4d13-a7d7-ae080833b779
ms.service: batch
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: ''
ms.workload: multiple
ms.date: 06/20/2017
ms.author: danlep
ms.custom: H1Hack27Feb2017
ms.openlocfilehash: 1114ea90ae6976a3bc3580ebae5fd853de0274a1
ms.sourcegitcommit: 6fcd9e220b9cd4cb2d4365de0299bf48fbb18c17
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/05/2018
ms.locfileid: "30317027"
---
# <a name="create-an-automatic-scaling-formula-for-scaling-compute-nodes-in-a-batch-pool"></a>Создание формулы автоматического масштабирования для масштабирования вычислительных узлов в пуле пакетной службы

Пакетная служба Azure может автоматически масштабировать пулы в зависимости от определенных вами параметров. Автоматическое масштабирование позволяет пакетной службе динамически добавлять узлы в пул при росте потребностей задачи, а также удалять вычислительные узлы при снижении нагрузки. Вы можете сэкономить время и деньги, используя автоматическую корректировку количества вычислительных узлов, используемых приложением пакетной службы. 

Чтобы включить автоматическое масштабирование для пула вычислительных узлов, определите и установите для него *формулу автомасштабирования*. Пакетная служба использует эту формулу автомасштабирования, чтобы определить количество вычислительных узлов, необходимых для выполнения рабочей нагрузки. Вычислительные узлы могут быть выделенными узлами или [узлами с низким приоритетом](batch-low-pri-vms.md). Пакетная служба реагирует на изменения метрик службы, данные о которых она регулярно собирает. Используя эти данные метрик, заданную вами формулу и настроенный период масштабирования, пакетная служба изменяет количество вычислительных узлов в пуле.

Автоматическое масштабирование можно включить во время создания пула или для существующего пула. Также можно изменить назначенную формулу для пула с настроенным автоматическим масштабированием. С помощью пакетной службы можно контролировать работу формул перед их применением к пулам, а также отслеживать состояние автоматического масштабирования.

В этой статье рассматриваются различные сущности, которые входят в формулы автоматического масштабирования, такие как переменные, операторы, операции и функции. Вы узнаете, как получить различные вычислительные ресурсы и метрики задач в пакетной службе. Эти метрики можно использовать для корректировки количества узлов в пуле на основе использования ресурсов и состояния задач. Затем описывается, как составлять формулы и включать автоматическое масштабирование в пуле с помощью REST API пакетной службы и API .NET. Наконец, мы рассмотрим несколько примеров формул.

> [!IMPORTANT]
> При создании учетной записи пакетной службы можно задать [конфигурацию учетной записи](batch-api-basics.md#account), которая определяет, выделяются ли пулы в подписке на пакетную службу (по умолчанию) или в вашей пользовательской подписке. Если учетная запись пакетной службы была создана с конфигурацией пакетной службы по умолчанию, то она имеет ограничение на максимальное количество ядер, которые могут использоваться для обработки. Пакетная служба будет создавать вычислительные узлы только до достижения этого предельного количества ядер. По этой причине пакетная служба может не достигать требуемого количества вычислительных узлов, определенного формулой автомасштабирования. Сведения о просмотре и увеличении квот для учетной записи приведены в статье [Квоты и ограничения пакетной службы Azure](batch-quota-limit.md) .
>
>Если вы создали учетную запись с конфигурацией пользовательской подписки, то она использует квоту ядер по подписке. Дополнительные сведения см. в разделе [Ограничения виртуальных машин](../azure-subscription-service-limits.md#virtual-machines-limits) в статье [Подписка Azure, границы, квоты и ограничения службы](../azure-subscription-service-limits.md).
>
>

## <a name="automatic-scaling-formulas"></a>Формулы автоматического масштабирования
Формула автоматического масштабирования представляет собой определяемое пользователем строковое значение, которое содержит один или несколько операторов. Формула автоматического масштабирования назначается элементу пула [autoScaleFormula][rest_autoscaleformula] (в REST пакетной службы) или свойству [CloudPool.AutoScaleFormula] [ net_cloudpool_autoscaleformula] (.NET пакетной службы). С помощью этой формулы пакетная служба определяет целевое количество вычислительных узлов в пуле для следующего интервала обработки. Размер строки формулы не может превышать 8 КБ, а сама строка может содержать до 100 операторов, разделенных точкой с запятой, а также разрывы строк и комментарии.

Вы можете представить, что формулы автоматического масштабирования — это язык автомасштабирования пакетной службы. Инструкции в формуле представляют собой выражения свободной формы, которые могут включать служебные (определяемые службой пакетной обработки) и пользовательские переменные (определяемые пользователем). С этими переменными могут выполняться различные операции с помощью встроенных типов, операторов и функций. Например, инструкция может принимать следующую форму:

```
$myNewVariable = function($ServiceDefinedVariable, $myCustomVariable);
```

Обычно формулы содержат несколько инструкций, выполняющих операции со значениями, полученными в предыдущих инструкциях. Например, сначала получим значение для `variable1`, а затем передадим его функции для заполнения `variable2`:

```
$variable1 = function1($ServiceDefinedVariable);
$variable2 = function2($OtherServiceDefinedVariable, $variable1);
```

Добавьте эти операторы в формулу автомасштабирования, чтобы получить целевое количество вычислительных узлов. Выделенные узлы и узлы с низким приоритетом имеют свои собственные целевые показатели, что позволяет определять целевое количество для каждого типа узла. Формула автомасштабирования может включать в себя целевое значение для выделенных узлов, целевое значение для узлов с низким приоритетом или и то, и другое.

Целевое количество узлов может быть меньше или больше текущего количества узлов данного типа в пуле либо быть равным ему. Пакетная служба вычисляет формулу автомасштабирования пула с указанным интервалом (см. раздел, посвященный [интервалам автоматического масштабирования](#automatic-scaling-interval)). Затем она изменяет целевое количество узлов каждого типа в пуле на новое значение, полученное по формуле автомасштабирования на момент оценки.

### <a name="sample-autoscale-formula"></a>Пример формулы автоматического масштабирования

Здесь представлен пример формулы автоматического масштабирования, который можно с некоторой корректировкой применить для большинства случаев. Переменные `startingNumberOfVMs` и `maxNumberofVMs` в этом примере формулы можно изменять так, как вам удобно. Эта формула масштабирует выделенные узлы, но ее можно изменить для масштабирования узлов с низким приоритетом. 

```
startingNumberOfVMs = 1;
maxNumberofVMs = 25;
pendingTaskSamplePercent = $PendingTasks.GetSamplePercent(180 * TimeInterval_Second);
pendingTaskSamples = pendingTaskSamplePercent < 70 ? startingNumberOfVMs : avg($PendingTasks.GetSample(180 * TimeInterval_Second));
$TargetDedicatedNodes=min(maxNumberofVMs, pendingTaskSamples);
```

Если используется эта формула автоматического масштабирования, пул создается с одной виртуальной машиной. Метрика `$PendingTasks` обозначает количество задач, находящихся в очереди или в состоянии выполнения. Формула находит среднее число ожидающих выполнения задач за последние 180 секунд и соответствующим образом задает значение переменной `$TargetDedicatedNodes`. Формула гарантирует, что целевое число выделенных узлов никогда не превысит значение 25. По мере добавления новых задач пул автоматически расширяется. При завершении задач виртуальные машины поочередно высвобождаются, и формула автомасштабирования сжимает размер пула.

## <a name="variables"></a>Переменные
В формуле автоматического масштабирования можно использовать как **служебные**, так и **пользовательские** переменные. Служебные переменные встроены в пакетную службу. Некоторые из них доступны для чтения и записи, а некоторые — только для чтения. Пользовательские переменные — это переменные, которые определяете вы. Формула, представленная в примере предыдущего раздела, содержит определяемые службой переменные `$TargetDedicatedNodes` и `$PendingTasks`. Переменные `startingNumberOfVMs` и `maxNumberofVMs` — это переменные, определяемые пользователем.

> [!NOTE]
> Служебные переменные всегда начинаются с символа доллара ($). Для определяемых пользователем переменных знак доллара является необязательным.
>
>

В таблицах ниже показаны переменные для чтения и записи и переменные только для чтения, определенные пакетной службой.

Вы можете получить и установить значения этих служебных переменных для управления количеством вычислительных узлов в пуле.

| Определяемые службой переменные для чтения и записи | ОПИСАНИЕ |
| --- | --- |
| $TargetDedicatedNodes |Целевое количество выделенных вычислительных узлов для пула. Количество выделенных узлов указывается как целевое, так как оно может остаться недостижимым для пула. Например, это может произойти, если целевое количество выделенных узлов изменяется после вычисления формулы автоматического масштабирования до того, как пул достигнет изначального целевого количества. <br /><br /> Целевое значение может оказаться недостижимым для пула в учетной записи, созданной с конфигурацией пакетной службы, если оно превышает квоту узлов или ядер в учетной записи пакетной службы. Целевое значение может оказаться недостижимым для пула в учетной записи, созданной с конфигурацией пользовательской подписки, если оно превышает общую квоту ядер по подписке.|
| $TargetLowPriorityNodes |Целевое количество вычислительных узлов с низким приоритетом для пула. Количество узлов с низким приоритетом указывается как целевое, так как оно может остаться недостижимым для пула. Например, это может произойти, если целевое количество узлов с низким приоритетом изменяется после вычисления формулы автоматического масштабирования до того, как пул достигнет изначального целевого количества. Это также может произойти, если целевое количество превышает квоту узлов или ядер в учетной записи пакетной службы. <br /><br /> Дополнительные сведения о вычислительных узлах с низким приоритетом см. в статье [Использование низкоприоритетных виртуальных машин в пакетной службе (предварительная версия)](batch-low-pri-vms.md). |
| $NodeDeallocationOption |Действие, выполняемое после удаления вычислительных узлов из пула. Возможные значения:<ul><li>**requeue** — немедленное завершение задач с перемещением в очередь заданий, чтобы запланировать их выполнение заново;<li>**terminate** — немедленное завершение задач с удалением из очереди заданий;<li>**taskcompletion** — ожидание завершения выполнения текущих задач с удалением узла из пула;<li>**retaineddata** — ожидание очистки всех сохраненных в узле данных локальных задач перед удалением узла из пула.</ul> |

Можно получить значения этих определяемых службой переменных, чтобы вносить изменения с учетом метрик из пакетной службы.

| Определяемые службой переменные только для чтения | ОПИСАНИЕ |
| --- | --- |
| $CPUPercent |Средний объем использования ЦП в процентах. |
| $WallClockSeconds |Затраченное время в секундах. |
| $MemoryBytes |Среднее количество используемых мегабайт. |
| $DiskBytes |Среднее количество гигабайт, используемых на локальных дисках. |
| $DiskReadBytes |Количество считанных байт. |
| $DiskWriteBytes |Количество записанных байт. |
| $DiskReadOps |Количество операций чтения с диска. |
| $DiskWriteOps |Количество операций записи на диск. |
| $NetworkInBytes |Количество входящих байт. |
| $NetworkOutBytes |Количество исходящих байт. |
| $SampleNodeCount |Количество вычислительных узлов. |
| $ActiveTasks |Количество задач, готовых к выполнению, но еще не выполняющихся. Значение $ActiveTasks включает все задачи в активном состоянии, зависимости которых выполнены. Задачи в активном состоянии, зависимости которых не выполнены, не включаются в значение $ActiveTasks.|
| $RunningTasks |Количество задач в состоянии выполнения. |
| $PendingTasks |Сумма $ActiveTasks и $RunningTasks. |
| $SucceededTasks |Количество успешно выполненных задач. |
| $FailedTasks |Количество задач, которые не удалось выполнить. |
| $CurrentDedicatedNodes |Текущее количество выделенных вычислительных узлов. |
| $CurrentLowPriorityNodes |Текущее количество вычислительных узлов с низким приоритетом, включая все узлы, которые были замещены. |
| $PreemptedNodeCount | Количество узлов в пуле, которые находятся в замещенном состоянии. |

> [!TIP]
> Приведенные в предыдущей таблице определяемые службой переменные только для чтения — это *объекты*, предоставляющие различные методы доступа к данным, связанным с каждым объектом. Дополнительные сведения см. в разделе [Получение выборки данных](#getsampledata) далее в этой статье.
>
>

## <a name="types"></a>Типы
В формуле поддерживаются следующие типы:

* Double
* doubleVec
* doubleVecList
* строка
* timestamp. timestamp является комплексной структурой, которая содержит следующие элементы:

  * year
  * month (1-12)
  * day (1-31)
  * weekday (в формате числа, например 1 — понедельник)
  * hour (час в 24-часовом формате, например 13 соответствует 13:00)
  * minute (00–59)
  * second (00–59)
* timeInterval

  * TimeInterval_Zero
  * TimeInterval_100ns
  * TimeInterval_Microsecond
  * TimeInterval_Millisecond
  * TimeInterval_Second
  * TimeInterval_Minute
  * TimeInterval_Hour
  * TimeInterval_Day
  * TimeInterval_Week
  * TimeInterval_Year

## <a name="operations"></a>Операции
Для перечисленных в предыдущем разделе типов разрешены перечисленные ниже операции.

| Операция | Поддерживаемые операторы | Тип результата |
| --- | --- | --- |
| double *оператор* double |+, -, *, / |Double |
| double *оператор* timeinterval |* |timeInterval |
| doubleVec *оператор* double |+, -, *, / |doubleVec |
| doubleVec *оператор* doubleVec |+, -, *, / |doubleVec |
| timeinterval *оператор* double |*, / |timeInterval |
| timeinterval *оператор* timeinterval |+, - |timeInterval |
| timeinterval *оператор* timestamp |+ |timestamp |
| timestamp *оператор* timeinterval |+ |timestamp |
| timestamp *оператор* timestamp |- |timeInterval |
| *оператор*double |-, ! |Double |
| *оператор*timeInterval |- |timeInterval |
| double *оператор* double |<, <=, ==, >=, >, != |Double |
| string *оператор* string |<, <=, ==, >=, >, != |Double |
| timestamp *оператор* timestamp |<, <=, ==, >=, >, != |Double |
| timeinterval *оператор* timeinterval |<, <=, ==, >=, >, != |Double |
| double *оператор* double |&&, &#124;&#124; |Double |

При тестировании double с тернарным оператором (`double ? statement1 : statement2`) ненулевое значение равно **true**, а нулевое — **false**.

## <a name="functions"></a>Functions
Для определения формулы автомасштабирования доступны следующие предопределенные **функции** .

| Функция | Тип возвращаемого значения | ОПИСАНИЕ |
| --- | --- | --- |
| avg(doubleVecList) |Double |Среднее значение для всех значений в doubleVecList. |
| len(doubleVecList) |Double |Возвращает длину вектора, созданного из doubleVecList. |
| lg(double) |Double |Возвращает логарифм double по основанию 2. |
| lg(doubleVecList) |doubleVec |Возвращает покомпонентный логарифм по основанию 2 от значения doubleVecList. В качестве параметра необходимо явно передать vec(double). В противном случае предполагается использование версии lg(double). |
| ln(double) |Double |Возвращает натуральный логарифм double. |
| ln(doubleVecList) |doubleVec |Возвращает покомпонентный логарифм по основанию 2 от значения doubleVecList. В качестве параметра необходимо явно передать vec(double). В противном случае предполагается использование версии lg(double). |
| log(double) |Double |Возвращает логарифм double по основанию 10. |
| log(doubleVecList) |doubleVec |Возвращает покомпонентный логарифм по основанию 10 от значения doubleVecList. В качестве одного параметра double необходимо явно передать vec(double). В противном случае предполагается использование версии log(double). |
| max(doubleVecList) |Double |Возвращает максимальное значение в doubleVecList. |
| min(doubleVecList) |Double |Возвращает минимальное значение в doubleVecList. |
| norm(doubleVecList) |Double |Возвращает 2-норму вектора, созданного из doubleVecList. |
| percentile(doubleVec v, double p) |Double |Возвращает элемент процентиля вектора v. |
| rand() |Double |Возвращает случайное значение от 0,0 до 1,0. |
| range(doubleVecList) |Double |Возвращает разницу между минимальным и максимальным значениями в doubleVecList. |
| std(doubleVecList) |Double |Возвращает среднеквадратичное отклонение выборки для значений в doubleVecList. |
| stop() | |Останавливает вычисление выражения автоматического масштабирования. |
| sum(doubleVecList) |Double |Возвращает сумму всех компонентов doubleVecList. |
| time(string dateTime="") |timestamp |Возвращает отметку времени для текущего времени, если параметр не передан, и отметку времени для строки dateTime, если параметр передан. Поддерживаемые форматы даты и времени: W3C-DTF и RFC 1123. |
| val(doubleVec v, double i) |Double |Возвращает значение элемента с индексом i в векторе v с начальным индексом 0. |

Некоторые функции, описанные в предыдущей таблице, могут принимать список в качестве аргумента. Список значений, разделенных запятыми, — это любая комбинация типов *double* и *doubleVec*. Например: 

`doubleVecList := ( (double | doubleVec)+(, (double | doubleVec) )* )?`

Значение *doubleVecList* перед оценкой преобразуется в одно значение *doubleVec*. Например, если `v = [1,2,3]`, то вызов `avg(v)` эквивалентен вызову `avg(1,2,3)`. Вызов `avg(v, 7)` эквивалентен вызову `avg(1,2,3,7)`.

## <a name="getsampledata"></a>Получение выборки данных
Формулы автоматического масштабирования работают с данными метрик (выборками), предоставленными пакетной службой. Формула увеличивает или уменьшает размер пула на основе значений, полученных от службы. Описанные выше служебные переменные только для чтения — это объекты, предоставляющие разные методы доступа к данным, связанным с объектом. Например, следующее выражение иллюстрирует запрос для получения данных об использовании ЦП за последние пять минут.

```
$CPUPercent.GetSample(TimeInterval_Minute * 5)
```

| Метод | ОПИСАНИЕ |
| --- | --- |
| GetSample() |Метод `GetSample()` возвращает вектор выборок данных.<br/><br/>Выборка — это данные метрики за 30 секунд. Другими словами, выборки делаются каждые 30 секунд. Но, как описано ниже, существует задержка между получением выборки и моментом, когда выборка станет доступна формуле. Таким образом, не все выборки за заданный период времени могут быть доступны для оценки формулой.<ul><li>`doubleVec GetSample(double count)`<br/>Указывает нужное количество выборок из числа самых свежих.<br/><br/>`GetSample(1)` возвращает последнюю доступную выборку. Этот метод не следует использовать для таких метрик, как `$CPUPercent`, так как нет возможности узнать, *когда* была получена эта выборка. Она может оказаться свежей, но может и устареть, если в системе возникли проблемы. Для таких параметров лучше использовать интервалы, как показано ниже.<li>`doubleVec GetSample((timestamp or timeinterval) startTime [, double samplePercent])`<br/>Задает интервал времени для данных выборки. Также можно указать долю выборок, которые должны быть доступны в течение запрошенного интервала времени.<br/><br/>`$CPUPercent.GetSample(TimeInterval_Minute * 10)` вернет 20 выборок, если в журнале CPUPercent присутствуют все выборки за последние 10 минут. Но если данные за последнюю минуту еще недоступны, этот метод вернет только 18 выборок. В данном случае:<br/><br/>Метод `$CPUPercent.GetSample(TimeInterval_Minute * 10, 95)` завершится сбоем, так как доступно только 90 процентов выборок.<br/><br/>Метод `$CPUPercent.GetSample(TimeInterval_Minute * 10, 80)` будет выполнен успешно.<li>`doubleVec GetSample((timestamp or timeinterval) startTime, (timestamp or timeinterval) endTime [, double samplePercent])`<br/>Задает интервал времени для сбора данных, т. е. начало и конец сбора.<br/><br/>Как упоминалось выше, полученный образец становится доступным для формулы с задержкой. Эту задержку следует учитывать при использовании метода `GetSample`. Ознакомьтесь с `GetSamplePercent` ниже. |
| GetSamplePeriod() |Возвращает период выборок, которые были получены в историческом наборе данных выборок. |
| Count() |Возвращает общее количество выборок в журнале метрик. |
| HistoryBeginTime() |Возвращает метку времени самой старой доступной выборки данных метрики. |
| GetSamplePercent() |Возвращает процент выборок, которые доступны для заданного интервала времени. Например: <br/><br/>`doubleVec GetSamplePercent( (timestamp or timeinterval) startTime [, (timestamp or timeinterval) endTime] )`<br/><br/>Так как метод `GetSample` завершается сбоем, то если процент возвращаемых выборок меньше указанного в параметре `samplePercent`, можно сначала воспользоваться методом `GetSamplePercent` для проверки. Затем при недостаточном количестве выборок можно выполнить другое действие без прерывания оценки автоматического масштабирования. |

### <a name="samples-sample-percentage-and-the-getsample-method"></a>Выборки, процент выборок и метод *GetSample()*
Основной операцией формулы автоматического масштабирования является получение данных метрик для задач и ресурсов и изменение размера пула на основе этих данных. Поэтому важно иметь четкое представление о том, как формулы автоматического масштабирования взаимодействуют с данными метрик (выборками).

**Примеры**

Пакетная служба периодически принимает выборки метрик задач и ресурсов, делая их доступными для формул автомасштабирования. Эти выборки записываются пакетной службой каждые 30 секунд. Однако обычно имеется задержка между временем записи этих выборок и временем, когда формулы автоматического масштабирования получают к ним доступ (и могут прочесть их). Кроме того, по тем или иным причинам (включая проблемы с сетью или другие проблемы инфраструктуры) для некоторых интервалов выборки могут не записаться.

**Процент выборок**

При передаче `samplePercent` в метод `GetSample()` или при вызове метода `GetSamplePercent()` знак _процента_ означает сравнение общего возможного количества выборок, записанных пакетной службой, и количества выборок, которые доступны для формулы автомасштабирования.

Для примера рассмотрим промежуток времени в 10 минут. Так как выборки записываются каждые 30 секунд, максимальное общее количество выборок, записанных пакетной службой в течение 10 минут, должно равняться 20 (по 2 в минуту). Однако из-за задержек, присущих механизму отчетности, или других проблем в Azure возможна ситуация, когда только 15 выборок будут доступны для формулы автоматического масштабирования. Поэтому, например, за этот 10-минутный период для формулы может быть доступно только 75 % от общего количества записанных выборок.

**Метод GetSample() и диапазоны выборок**

Формулы автоматического масштабирования будут увеличивать и уменьшать размер пулов &mdash;, добавляя или удаляя узлы. Поскольку узлы стоят денег, нужно гарантировать, что формулы используют метод интеллектуального анализа, который основан на достаточном объеме данных. Поэтому в формулах рекомендуется использовать анализ тенденций. С таким анализом пулы увеличиваются и уменьшаются на основе диапазона собранных выборок.

С этой целью используйте метод `GetSample(interval look-back start, interval look-back end)` для возврата вектора выборок.

```
$runningTasksSample = $RunningTasks.GetSample(1 * TimeInterval_Minute, 6 * TimeInterval_Minute);
```

Когда пакетная служба вычисляет приведенную выше строку, она возвращает диапазон выборок в виде вектора значений. Например: 

```
$runningTasksSample=[1,1,1,1,1,1,1,1,1,1];
```

Собрав вектор выборок, можно использовать функции, например `min()`, `max()` и `avg()`, чтобы извлечь из собранного диапазона информативные значения.

Для повышения безопасности можно настроить сбой вычисления формулы в случае, если процент выборок за определенный период окажется меньше заданного значения. Если для формулы настроен принудительный сбой вычисления, пакетная служба прекращает выполнение расчетов по формуле, когда недоступен заданный процент выборок. Размер пула при этом изменяться не будет. Чтобы указать необходимый процент выборок для успешного вычисления, укажите его как третий параметр в методе `GetSample()`. Здесь указано, что обязательный процент выборок равен 75 %:

```
$runningTasksSample = $RunningTasks.GetSample(60 * TimeInterval_Second, 120 * TimeInterval_Second, 75);
```

Поскольку иногда могут происходить задержки доступности выборок, для любого диапазона времени следует устанавливать время для предварительной оценки не меньше одной минуты. Передача выборок через систему занимает около минуты, поэтому примеры в диапазоне `(0 * TimeInterval_Second, 60 * TimeInterval_Second)` могут быть недоступны. Опять же, можно использовать параметр процента `GetSample()` для принудительного требования определенного процента выборок.

> [!IMPORTANT]
> Мы **настоятельно рекомендуем** **не полагаться *только* на метод `GetSample(1)` в формулах автомасштабирования**. Это объясняется тем, что метод `GetSample(1)` запрашивает у пакетной службы последнюю доступную выборку независимо от того, как давно она была получена. Поскольку это только одна выборка, которая к тому же может быть устаревшей, она может не давать общее представление о последнем состоянии задачи или ресурса. Если метод `GetSample(1)`все же используется, убедитесь, что он является частью большей инструкции, а не единственной точкой данных, от которой зависит ваша формула.
>
>

## <a name="metrics"></a>Метрики
При определении формулы можно использовать метрики ресурсов и задач. Целевое количество выделенных узлов в пуле определяется на основе данных метрики, которые были получены и оценены. Дополнительные сведения о каждой метрике см. в разделе [Переменные](#variables) выше.

<table>
  <tr>
    <th>Метрика</th>
    <th>ОПИСАНИЕ</th>
  </tr>
  <tr>
    <td><b>Ресурс</b></td>
    <td><p>Метрики ресурсов основаны на использовании ресурсов ЦП, памяти и пропускной способности вычислительных узлов, а также количестве узлов.</p>
        <p> Для внесения изменений с учетом количества узлов используются следующие служебные переменные:</p>
    <p><ul>
            <li>$TargetDedicatedNodes</li>
            <li>$TargetLowPriorityNodes</li>
            <li>$CurrentDedicatedNodes</li>
            <li>$CurrentLowPriorityNodes</li>
            <li>$preemptedNodeCount</li>
            <li>$SampleNodeCount</li>
    </ul></p>
    <p>Для внесения изменений с учетом потребляемых ресурсов используются следующие служебные переменные:</p>
    <p><ul>
      <li>$CPUPercent</li>
      <li>$WallClockSeconds</li>
      <li>$MemoryBytes</li>
      <li>$DiskBytes</li>
      <li>$DiskReadBytes</li>
      <li>$DiskWriteBytes</li>
      <li>$DiskReadOps</li>
      <li>$DiskWriteOps</li>
      <li>$NetworkInBytes</li>
      <li>$NetworkOutBytes</li></ul></p>
  </tr>
  <tr>
    <td><b>Задача.</b></td>
    <td><p>Метрики задач основаны на состоянии задач (активные, ожидающие и завершенные). Для внесения изменений в размер пула с учетом метрик задач используются следующие служебные переменные:</p>
    <p><ul>
      <li>$ActiveTasks</li>
      <li>$RunningTasks</li>
      <li>$PendingTasks</li>
      <li>$SucceededTasks</li>
            <li>$FailedTasks</li></ul></p>
        </td>
  </tr>
</table>

## <a name="write-an-autoscale-formula"></a>Написание формулы автомасштабирования
Формула автомасштабирования создается путем формирования инструкций с помощью указанных выше компонентов и объединения этих инструкций в полную формулу. В этом разделе мы создадим пример формулы автомасштабирования, с помощью которой можно выполнять некоторые задачи масштабирования из реальной жизни.

Сначала определим требования к новой формуле автомасштабирования. Формула должна выполнять следующее:

1. Увеличивать целевое количество выделенных вычислительных узлов в пуле при высокой загрузке ЦП.
2. Уменьшать целевое количество выделенных вычислительных узлов в пуле при низкой загрузке ЦП.
3. Всегда ограничивать максимальное количество выделенных узлов на уровне 400.

Для увеличения количества узлов в периоды высокой загрузки ЦП определите оператор, который присваивает пользовательской переменной (`$totalDedicatedNodes`) значение, равное 110 % от текущего целевого количества выделенных узлов, если минимальная средняя загрузка ЦП за последние 10 минут превышала 70 %. В противном случае используйте значение текущего количества выделенных узлов.

```
$totalDedicatedNodes =
    (min($CPUPercent.GetSample(TimeInterval_Minute * 10)) > 0.7) ?
    ($CurrentDedicatedNodes * 1.1) : $CurrentDedicatedNodes;
```

Для *уменьшения* количества выделенных узлов в периоды низкой загрузки ЦП следующий оператор в формуле присваивает той же переменной `$totalDedicatedNodes` значение, равное 90 % от текущего целевого количества выделенных узлов, если средняя загрузка ЦП за последние 60 минут была ниже 20 %. В противном случае будет использоваться текущее значение переменной `$totalDedicatedNodes`, заполненное в приведенной выше инструкции.

```
$totalDedicatedNodes =
    (avg($CPUPercent.GetSample(TimeInterval_Minute * 60)) < 0.2) ?
    ($CurrentDedicatedNodes * 0.9) : $totalDedicatedNodes;
```

Теперь мы ограничим целевое количество выделенных вычислительных узлов максимальным значением 400:

```
$TargetDedicatedNodes = min(400, $totalDedicatedNodes)
```

Вот полная формула:

```
$totalDedicatedNodes =
    (min($CPUPercent.GetSample(TimeInterval_Minute * 10)) > 0.7) ?
    ($CurrentDedicatedNodes * 1.1) : $CurrentDedicatedNodes;
$totalDedicatedNodes =
    (avg($CPUPercent.GetSample(TimeInterval_Minute * 60)) < 0.2) ?
    ($CurrentDedicatedNodes * 0.9) : $totalDedicatedNodes;
$TargetDedicatedNodes = min(400, $totalDedicatedNodes)
```

## <a name="create-an-autoscale-enabled-pool-with-net"></a>Создание пула с поддержкой автомасштабирования с помощью .NET

Чтобы создать пул с поддержкой автомасштабирования в .NET, выполните указанные ниже действия.

1. Создайте пул с помощью метода [BatchClient.PoolOperations.CreatePool](https://docs.microsoft.com/dotnet/api/microsoft.azure.batch.pooloperations.createpool).
2. Задайте для свойства [CloudPool.AutoScaleEnabled](https://docs.microsoft.com/dotnet/api/microsoft.azure.batch.cloudpool.autoscaleenabled) значение `true`.
3. Задайте свойство [CloudPool.AutoScaleFormula](https://docs.microsoft.com/dotnet/api/microsoft.azure.batch.cloudpool.autoscaleformula) с помощью формулы автомасштабирования.
4. (Необязательно.) Задайте свойство [CloudPool.AutoScaleEvaluationInterval](https://docs.microsoft.com/dotnet/api/microsoft.azure.batch.cloudpool.autoscaleevaluationinterval) (значение по умолчанию — 15 минут).
5. Зафиксируйте пул с помощью метода [CloudPool.Commit](https://docs.microsoft.com/dotnet/api/microsoft.azure.batch.cloudpool.commit) или [CommitAsync](https://docs.microsoft.com/dotnet/api/microsoft.azure.batch.cloudpool.commitasync).

В следующем фрагменте кода создается пул с поддержкой автомасштабирования в .NET. Формула автомасштабирования пула устанавливает целевое количество выделенных узлов равным 5 по понедельникам и равным 1 в остальные дни недели. [Интервал автомасштабирования](#automatic-scaling-interval) составляет 30 минут. В этом и других фрагментах кода C#, приведенных в этой статье, `myBatchClient` представляет собой правильно инициализированный экземпляр класса [BatchClient][net_batchclient].

```csharp
CloudPool pool = myBatchClient.PoolOperations.CreatePool(
                    poolId: "mypool",
                    virtualMachineSize: "small", // single-core, 1.75 GB memory, 225 GB disk
                    cloudServiceConfiguration: new CloudServiceConfiguration(osFamily: "5"));    
pool.AutoScaleEnabled = true;
pool.AutoScaleFormula = "$TargetDedicatedNodes = (time().weekday == 1 ? 5:1);";
pool.AutoScaleEvaluationInterval = TimeSpan.FromMinutes(30);
await pool.CommitAsync();
```

> [!IMPORTANT]
> При создании пула с поддержкой автомасштабирования не указывайте параметр _targetDedicatedComputeNodes_ или _targetLowPriorityComputeNodes_ в вызове **CreatePool**. Вместо этого укажите свойства **AutoScaleEnabled** и **AutoScaleFormula** для пула. Значения этих свойств определяют целевое количество каждого типа узлов. Кроме того, чтобы вручную изменить размер пула с включенным автомасштабированием (например, с помощью [BatchClient.PoolOperations.ResizePoolAsync][net_poolops_resizepoolasync]), сначала **отключите** автомасштабирование пула, а затем измените его размер.
>
>

Кроме библиотеки .NET пакетной службы, для настройки автомасштабирования можно использовать любые другие [пакеты SDK пакетной службы](batch-apis-tools.md#azure-accounts-for-batch-development), [Batch REST](https://docs.microsoft.com/rest/api/batchservice/), [командлеты PowerShell пакетной службы](batch-powershell-cmdlets-get-started.md) и [интерфейс командной строки пакетной службы](batch-cli-get-started.md).


### <a name="automatic-scaling-interval"></a>Интервал автоматического масштабирования
По умолчанию пакетная служба изменяет размер пула по указанной формуле автомасштабирования каждые 15 минут. Этот интервал можно настроить с помощью следующих свойств пула:

* [CloudPool.AutoScaleEvaluationInterval][net_cloudpool_autoscaleevalinterval] (.NET пакетной службы)
* [autoScaleEvaluationInterval][rest_autoscaleinterval] (REST API)

Минимальный интервал составляет пять минут, а максимальный — 168 часов. Если указан интервал за пределами этого диапазона, пакетная служба возвращает ошибку "Неправильный запрос (400)".

> [!NOTE]
> В настоящее время автоматическое масштабирование предназначено не для реагирования на изменения в течение нескольких секунд, а для постепенного изменения размера пула в ходе выполнения рабочей нагрузки.
>
>

## <a name="enable-autoscaling-on-an-existing-pool"></a>Включение автомасштабирования в имеющемся пуле

Каждый пакет SDK пакетной службы предоставляет способ включения автомасштабирования. Например: 

* [BatchClient.PoolOperations.EnableAutoScaleAsync][net_enableautoscaleasync] (библиотека .NET пакетной службы)
* [Включение автомасштабирования пула][rest_enableautoscale] (REST API)

При включении автомасштабирования в имеющемся пуле учитывайте указанные ниже условия.

* Если автомасштабирование в пуле отключено при выполнении запроса на включение автомасштабирования, необходимо указать допустимую формулу автомасштабирования. При необходимости можно указать интервал оценки автомасштабирования. Если интервал не указан, используется значение по умолчанию, равное 15 минутам.
* Если в пуле включено автомасштабирование, можно указать формулу автомасштабирования, интервал оценки либо и то, и другое. Необходимо указать по крайней мере одно из этих свойств.

  * Если указать новый интервал оценки автомасштабирования, имеющееся расписание оценки будет остановлено и запустится новое. Время начала нового расписания — это время подачи запроса на включение автомасштабирования.
  * Если опустить формулу автомасштабирования или интервал оценки, в пакетной службе и далее будет использоваться текущее значение этого параметра.

> [!NOTE]
> Если во время создания пула в .NET было указано значение параметра *targetDedicatedComputeNodes* или *targetLowPriorityComputeNodes* метода **CreatePool** либо аналогичных параметров в другом языке, эти значения игнорируются во время вычисления формулы автомасштабирования.
>
>

В этом фрагменте кода C# для включения автомасштабирования в имеющемся пуле используется библиотека [.NET пакетной службы][net_api].

```csharp
// Define the autoscaling formula. This formula sets the target number of nodes
// to 5 on Mondays, and 1 on every other day of the week
string myAutoScaleFormula = "$TargetDedicatedNodes = (time().weekday == 1 ? 5:1);";

// Set the autoscale formula on the existing pool
await myBatchClient.PoolOperations.EnableAutoScaleAsync(
    "myexistingpool",
    autoscaleFormula: myAutoScaleFormula);
```

### <a name="update-an-autoscale-formula"></a>Обновление формулы автомасштабирования

Чтобы обновить формулу для существующего пула с поддержкой автомасштабирования, вызовите операцию для включения автомасштабирования еще раз с новой формулой. Например, если при выполнении приведенного ниже кода .NET автомасштабирование уже включено в `myexistingpool`, формула автомасштабирования заменяется содержимым `myNewFormula`.

```csharp
await myBatchClient.PoolOperations.EnableAutoScaleAsync(
    "myexistingpool",
    autoscaleFormula: myNewFormula);
```

### <a name="update-the-autoscale-interval"></a>Обновление интервала автомасштабирования

Чтобы обновить интервал оценки автомасштабирования для существующего пула с поддержкой автомасштабирования, вызовите операцию для включения автомасштабирования еще раз с новым интервалом. Например, чтобы задать для интервала оценки автомасштабирования значение 60 минут в пуле с уже включенным автомасштабированием, необходимо сделать следующее:

```csharp
await myBatchClient.PoolOperations.EnableAutoScaleAsync(
    "myexistingpool",
    autoscaleEvaluationInterval: TimeSpan.FromMinutes(60));
```

## <a name="evaluate-an-autoscale-formula"></a>Оценка формулы автомасштабирования

Прежде чем применить формулу к пулу, ее можно оценить. Таким образом, можно протестировать формулу, чтобы увидеть, как ее операторы выполняют вычисления, до запуска формулы в рабочей среде.

Чтобы вычислить формулу автомасштабирования, сначала необходимо включить автомасштабирование в пуле с помощью допустимой формулы. Чтобы протестировать формулу в пуле, в котором еще не включено автомасштабирование, используйте формулу с одной строкой `$TargetDedicatedNodes = 0` при первом включении автомасштабирования. Затем для оценки формулы, которую требуется протестировать, выполните одно из следующих действий:

* Вызовите метод [BatchClient.PoolOperations.EvaluateAutoScale](https://docs.microsoft.com/dotnet/api/microsoft.azure.batch.pooloperations.evaluateautoscale) или [EvaluateAutoScaleAsync](https://docs.microsoft.com/dotnet/api/microsoft.azure.batch.pooloperations.evaluateautoscaleasync).

    Для выполнения оценки этим методам .NET пакетной службы требуется идентификатор имеющегося пула и строка, содержащая формулу автомасштабирования.

* [Оцените формулу автомасштабирования.](https://docs.microsoft.com/rest/api/batchservice/evaluate-an-automatic-scaling-formula)

    В этом запросе REST API укажите идентификатор пула в универсальном коде ресурса и формулу автомасштабирования в элементе *autoScaleFormula* текста запроса. Ответ операции содержит все сведения об ошибках, которые могут быть связаны с формулой.

В этом фрагменте кода [.NET пакетной службы][net_api] вычисляется формула автомасштабирования. Если в пуле не включено автомасштабирование, сначала необходимо его включить.

```csharp
// First obtain a reference to an existing pool
CloudPool pool = await batchClient.PoolOperations.GetPoolAsync("myExistingPool");

// If autoscaling isn't already enabled on the pool, enable it.
// You can't evaluate an autoscale formula on non-autoscale-enabled pool.
if (pool.AutoScaleEnabled == false)
{
    // We need a valid autoscale formula to enable autoscaling on the
    // pool. This formula is valid, but won't resize the pool:
    await pool.EnableAutoScaleAsync(
        autoscaleFormula: "$TargetDedicatedNodes = {pool.CurrentDedicatedNodes};",
        autoscaleEvaluationInterval: TimeSpan.FromMinutes(5));

    // Batch limits EnableAutoScaleAsync calls to once every 30 seconds.
    // Because we want to apply our new autoscale formula below if it
    // evaluates successfully, and we *just* enabled autoscaling on
    // this pool, we pause here to ensure we pass that threshold.
    Thread.Sleep(TimeSpan.FromSeconds(31));

    // Refresh the properties of the pool so that we've got the
    // latest value for AutoScaleEnabled
    await pool.RefreshAsync();
}

// We must ensure that autoscaling is enabled on the pool prior to
// evaluating a formula
if (pool.AutoScaleEnabled == true)
{
    // The formula to evaluate - adjusts target number of nodes based on
    // day of week and time of day
    string myFormula = @"
        $curTime = time();
        $workHours = $curTime.hour >= 8 && $curTime.hour < 18;
        $isWeekday = $curTime.weekday >= 1 && $curTime.weekday <= 5;
        $isWorkingWeekdayHour = $workHours && $isWeekday;
        $TargetDedicatedNodes = $isWorkingWeekdayHour ? 20:10;
    ";

    // Perform the autoscale formula evaluation. Note that this code does not
    // actually apply the formula to the pool.
    AutoScaleRun eval =
        await batchClient.PoolOperations.EvaluateAutoScaleAsync(pool.Id, myFormula);

    if (eval.Error == null)
    {
        // Evaluation success - print the results of the AutoScaleRun.
        // This will display the values of each variable as evaluated by the
        // autoscale formula.
        Console.WriteLine("AutoScaleRun.Results: " +
            eval.Results.Replace("$", "\n    $"));

        // Apply the formula to the pool since it evaluated successfully
        await batchClient.PoolOperations.EnableAutoScaleAsync(pool.Id, myFormula);
    }
    else
    {
        // Evaluation failed, output the message associated with the error
        Console.WriteLine("AutoScaleRun.Error.Message: " +
            eval.Error.Message);
    }
}
```

В случае успешного вычисления формулы, показанной в этом фрагменте, будет получен результат, подобный следующему:

```
AutoScaleRun.Results:
    $TargetDedicatedNodes=10;
    $NodeDeallocationOption=requeue;
    $curTime=2016-10-13T19:18:47.805Z;
    $isWeekday=1;
    $isWorkingWeekdayHour=0;
    $workHours=0
```

## <a name="get-information-about-autoscale-runs"></a>Получение сведений о выполнениях автомасштабирования

Чтобы убедиться в том, что формула работает правильно, мы рекомендуем периодически проверять результаты автомасштабирования, которое пакетная служба выполняет в пуле. Чтобы сделать это, получите (или обновите) ссылку на пул и проверьте свойства последнего выполнения автомасштабирования в этом пуле.

В .NET пакетной службы свойство [CloudPool.AutoScaleRun](https://docs.microsoft.com/dotnet/api/microsoft.azure.batch.cloudpool.autoscalerun) обладает несколькими свойствами, которые предоставляют сведения о последнем выполнении автомасштабирования в пуле.

* [AutoScaleRun.Timestamp.](https://docs.microsoft.com/dotnet/api/microsoft.azure.batch.autoscalerun.timestamp)
* [AutoScaleRun.Results;](https://docs.microsoft.com/dotnet/api/microsoft.azure.batch.autoscalerun.results)
* [AutoScaleRun.Error;](https://docs.microsoft.com/dotnet/api/microsoft.azure.batch.autoscalerun.error)

В REST API запрос [Получение сведений о пуле](https://docs.microsoft.com/rest/api/batchservice/get-information-about-a-pool) возвращает сведения о пуле, в том числе результаты последнего выполнения автомасштабирования, в свойстве [autoScaleRun](https://docs.microsoft.com/rest/api/batchservice/get-information-about-a-pool#bk_autrun).

В следующем фрагменте кода C# для вывода сведений о последнем выполнении автомасштабирования в пуле _myPool_ используется библиотека .NET пакетной службы:

```csharp
await Cloud pool = myBatchClient.PoolOperations.GetPoolAsync("myPool");
Console.WriteLine("Last execution: " + pool.AutoScaleRun.Timestamp);
Console.WriteLine("Result:" + pool.AutoScaleRun.Results.Replace("$", "\n  $"));
Console.WriteLine("Error: " + pool.AutoScaleRun.Error);
```

Пример выходных данных в результате выполнения предыдущего фрагмента:

```
Last execution: 10/14/2016 18:36:43
Result:
  $TargetDedicatedNodes=10;
  $NodeDeallocationOption=requeue;
  $curTime=2016-10-14T18:36:43.282Z;
  $isWeekday=1;
  $isWorkingWeekdayHour=0;
  $workHours=0
Error:
```

## <a name="example-autoscale-formulas"></a>Примеры формул автомасштабирования
Давайте рассмотрим некоторые формулы, которые демонстрируют различные способы настройки количества вычислительных ресурсов в пуле.

### <a name="example-1-time-based-adjustment"></a>Пример 1. Изменение с учетом времени
Предположим, вы хотите изменять размер пула в зависимости от дня недели и времени дня. В этом примере показано, как уменьшать и увеличивать количество узлов в пуле соответствующим образом.

Формула сначала получает значение текущего времени. В рабочие дни (1–5) и часы (8:00–18:00) целевой размер пула равен 20 узлам. В противном случае он равен 10 узлам.

```
$curTime = time();
$workHours = $curTime.hour >= 8 && $curTime.hour < 18;
$isWeekday = $curTime.weekday >= 1 && $curTime.weekday <= 5;
$isWorkingWeekdayHour = $workHours && $isWeekday;
$TargetDedicatedNodes = $isWorkingWeekdayHour ? 20:10;
```

### <a name="example-2-task-based-adjustment"></a>Пример 2. Изменение с учетом задачи
В этом примере размер пула настраивается в зависимости от количества задач в очереди. В строках формул допускаются как комментарии, так и разрывы строк.

```csharp
// Get pending tasks for the past 15 minutes.
$samples = $ActiveTasks.GetSamplePercent(TimeInterval_Minute * 15);
// If we have fewer than 70 percent data points, we use the last sample point,
// otherwise we use the maximum of last sample point and the history average.
$tasks = $samples < 70 ? max(0,$ActiveTasks.GetSample(1)) : max( $ActiveTasks.GetSample(1), avg($ActiveTasks.GetSample(TimeInterval_Minute * 15)));
// If number of pending tasks is not 0, set targetVM to pending tasks, otherwise
// half of current dedicated.
$targetVMs = $tasks > 0? $tasks:max(0, $TargetDedicatedNodes/2);
// The pool size is capped at 20, if target VM value is more than that, set it
// to 20. This value should be adjusted according to your use case.
$TargetDedicatedNodes = max(0, min($targetVMs, 20));
// Set node deallocation mode - keep nodes active only until tasks finish
$NodeDeallocationOption = taskcompletion;
```

### <a name="example-3-accounting-for-parallel-tasks"></a>Пример 3. Параллельные задачи
В этом примере размер пула изменяется на основе числа задач. В этой формуле также учитывается значение [MaxTasksPerComputeNode][net_maxtasks], которое было задано для пула. Такой подход полезен, если в пуле поддерживается [параллельное выполнение задач](batch-parallel-node-tasks.md).

```csharp
// Determine whether 70 percent of the samples have been recorded in the past
// 15 minutes; if not, use last sample
$samples = $ActiveTasks.GetSamplePercent(TimeInterval_Minute * 15);
$tasks = $samples < 70 ? max(0,$ActiveTasks.GetSample(1)) : max( $ActiveTasks.GetSample(1),avg($ActiveTasks.GetSample(TimeInterval_Minute * 15)));
// Set the number of nodes to add to one-fourth the number of active tasks (the
// MaxTasksPerComputeNode property on this pool is set to 4, adjust this number
// for your use case)
$cores = $TargetDedicatedNodes * 4;
$extraVMs = (($tasks - $cores) + 3) / 4;
$targetVMs = ($TargetDedicatedNodes + $extraVMs);
// Attempt to grow the number of compute nodes to match the number of active
// tasks, with a maximum of 3
$TargetDedicatedNodes = max(0,min($targetVMs,3));
// Keep the nodes active until the tasks finish
$NodeDeallocationOption = taskcompletion;
```

### <a name="example-4-setting-an-initial-pool-size"></a>Пример 4. Настройка исходного размера пула
В этом примере показан фрагмент кода C# с формулой автомасштабирования, которая задает в качестве размера пула определенное число узлов на начальный период времени. Затем он корректирует размер пула на основе количества запущенных и активных задач по истечению начального периода времени.

Формула в приведенном ниже фрагменте кода выполняет следующие действия.

* Она задает исходный размер пула в 4 узла.
* Не изменяет размер пула в течение первых 10 минут его жизненного цикла.
* После первых 10 минут она получает максимальное количество запущенных и активных задач за последние 60 минут.
  * Если оба значения равны 0 (то есть за 60 минут не было ни активных, ни запущенных задач), то размер пула устанавливается в 0.
  * Если любое из значений больше нуля, изменений не производится.

```csharp
string now = DateTime.UtcNow.ToString("r");
string formula = string.Format(@"
    $TargetDedicatedNodes = {1};
    lifespan         = time() - time(""{0}"");
    span             = TimeInterval_Minute * 60;
    startup          = TimeInterval_Minute * 10;
    ratio            = 50;

    $TargetDedicatedNodes = (lifespan > startup ? (max($RunningTasks.GetSample(span, ratio), $ActiveTasks.GetSample(span, ratio)) == 0 ? 0 : $TargetDedicatedNodes) : {1});
    ", now, 4);
```

## <a name="next-steps"></a>Дополнительная информация
* [Повышение эффективности вычислительных ресурсов в пакетной службе Azure благодаря параллельному выполнению задач на узлах](batch-parallel-node-tasks.md) содержит сведения о том, как можно одновременно выполнять несколько задач на вычислительных узлах пула. Помимо автоматического масштабирования, эта функция позволяет уменьшить длительность выполнения заданий для некоторых рабочих нагрузок, тем самым обеспечивая сокращение затрат.
* Еще одна возможность повысить эффективность — гарантировать, что приложение пакетной службы отправляет запросы в пакетную службу наиболее оптимальным способом. Чтобы узнать, как ограничить объем данных, передаваемых по сети при потенциальном запросе состояния тысяч вычислительных узлов или задач, см. статью [Эффективные запросы к пакетной службе Azure](batch-efficient-list-queries.md).

[net_api]: https://docs.microsoft.com/dotnet/api/microsoft.azure.batch
[net_batchclient]: https://docs.microsoft.com/dotnet/api/microsoft.azure.batch.batchclient
[net_cloudpool_autoscaleformula]: https://docs.microsoft.com/dotnet/api/microsoft.azure.batch.cloudpool.autoscaleformula
[net_cloudpool_autoscaleevalinterval]: https://docs.microsoft.com/dotnet/api/microsoft.azure.batch.cloudpool.autoscaleevaluationinterval
[net_enableautoscaleasync]: https://docs.microsoft.com/dotnet/api/microsoft.azure.batch.pooloperations.enableautoscaleasync
[net_maxtasks]: https://docs.microsoft.com/dotnet/api/microsoft.azure.batch.cloudpool.maxtaskspercomputenode
[net_poolops_resizepoolasync]: https://docs.microsoft.com/dotnet/api/microsoft.azure.batch.pooloperations.resizepoolasync

[rest_api]: https://docs.microsoft.com/rest/api/batchservice/
[rest_autoscaleformula]: https://docs.microsoft.com/rest/api/batchservice/enable-automatic-scaling-on-a-pool
[rest_autoscaleinterval]: https://docs.microsoft.com/rest/api/batchservice/enable-automatic-scaling-on-a-pool
[rest_enableautoscale]: https://docs.microsoft.com/rest/api/batchservice/enable-automatic-scaling-on-a-pool
