---
title: Создание решений пакетной службы с помощью шаблонов Visual Studio в Azure | Документация Майкрософт
description: Узнайте, как шаблоны проектов Visual Studio помогут реализовать и выполнить ресурсоемкие рабочие нагрузки в пакетной службе Azure.
services: batch
documentationcenter: .net
author: dlepow
manager: jeconnoc
editor: ''
ms.assetid: 5e041ae2-25af-4882-a79e-3aa63c4bfb20
ms.service: batch
ms.devlang: multiple
ms.topic: article
ms.tgt_pltfrm: ''
ms.workload: big-compute
ms.date: 02/27/2017
ms.author: danlep
ms.custom: H1Hack27Feb2017
ms.openlocfilehash: 5241c62e8b423b20477fc72c87303daf3d4ab43c
ms.sourcegitcommit: 20d103fb8658b29b48115782fe01f76239b240aa
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/03/2018
ms.locfileid: "30316755"
---
# <a name="use-visual-studio-project-templates-to-jump-start-batch-solutions"></a>Использование шаблонов проектов Visual Studio для быстрого начала работы с решениями пакетной службы

Шаблоны Visual Studio **Диспетчер заданий** и **Обработчик задач** для пакетной службы содержат код, позволяющий максимально упростить внедрение и выполнение ресурсоемких рабочих нагрузок в пакетной службе. Здесь представлено описание этих шаблонов, а также рекомендации по их использованию.

> [!IMPORTANT]
> В этой статье приведены сведения, применимые только к этим двум шаблонам. Здесь предполагается, что вы уже знакомы с пакетной службой и основными связанными с ней понятиями: пулы, вычислительные узлы, задания и задачи, задачи диспетчера заданий, переменные среды и другая важная информация. Дополнительные сведения см. в статье [Основные сведения о пакетной службе Azure](batch-technical-overview.md), [Обзор функций пакетной службы для разработчиков](batch-api-basics.md) и [Начало работы с библиотекой пакетной службы Azure для .NET](batch-dotnet-get-started.md).
> 
> 

## <a name="high-level-overview"></a>Общий обзор
С помощью шаблонов "Диспетчер заданий" и "Обработчик задач" можно создать два полезных компонента:

* Задачу диспетчера заданий, позволяющую внедрить разделитель заданий. Благодаря ему можно разбить задание на несколько задач, которые могут выполняться независимо в параллельном режиме.
* Обработчик задач, использующийся для предварительной обработки и постобработки приложения в командной строке.

Например, при отрисовке фильма разделитель заданий разделяет одно задание на сотни и тысячи отдельных задач, каждая из которых будет обрабатывать отдельные кадры. Соответственно, обработчик задач вызывает приложение для отрисовки и все зависимые процессы, необходимые для отрисовки каждого кадра и выполнения дополнительных действий (например, копирование отрисованного кадра в хранилище).

> [!NOTE]
> Шаблоны "Диспетчер заданий" и "Обработчик задач" независимы друг от друга, поэтому в зависимости от требований вычислительного задания и предпочтений можно использовать оба шаблона или только один из них.
> 
> 

Как показано на схеме ниже, вычислительное задание, в котором используются эти шаблоны, проходит через три этапа:

1. Код клиента (например, приложения, веб-службы и т. д.) отправляет задание в пакетную службу в Azure, указывая в качестве задачи диспетчера заданий программу диспетчера заданий.
2. Пакетная служба выполняет задание диспетчера заданий на вычислительном узле, а разделитель заданий запускает указанное количество задач обработчика задач на необходимом количестве вычислительных узлов с учетом параметров и спецификаций в коде разделителя заданий.
3. Задачи обработчика задач выполняются независимо в параллельном режиме. При этом обрабатываются входные данные и создаются выходные данные.

![Схема взаимодействия клиентского кода с пакетной службой][diagram01]

## <a name="prerequisites"></a>предварительным требованиям
Для использования шаблонов пакетной службы вам потребуется:

* Компьютер, на который установлено программное обеспечение Visual Studio 2015. В настоящее время поддерживаются только шаблоны пакетной службы для Visual Studio 2015.
* Шаблоны пакетной службы, доступные в [коллекции Visual Studio][vs_gallery] в качестве расширений Visual Studio. Получить шаблоны можно двумя способами:
  
  * Установите шаблоны, используя диалоговое окно **Расширения и обновления** в Visual Studio (дополнительные сведения см. в статье [Поиск и использование расширений Visual Studio][vs_find_use_ext]). С помощью диалогового окна **Расширения и обновления** найдите и скачайте следующие два модуля:
    
    * диспетчер заданий пакетной службы Azure с разделителем заданий;
    * обработчик задач пакетной службы Azure.
  * Скачайте шаблоны из коллекции в Интернете для Visual Studio: [Microsoft Azure Batch Project Templates][vs_gallery_templates] (Шаблоны проектов пакетной службы Microsoft Azure).
* Если планируется развернуть диспетчер заданий и обработчик задач на вычислительных узлах пакетной службы с помощью [пакетов приложений](batch-application-packages.md) , необходимо связать учетную запись хранения с учетной записью пакетной службы.

## <a name="preparation"></a>Подготовка
Мы советуем создать решение, содержащее диспетчер заданий и обработчик задач, так как таким образом можно упростить совместное использование кода в диспетчере заданий и обработчике задач. Чтобы создать это решение, сделайте следующее:

1. Откройте Visual Studio и выберите **Файл** > **Создать** > **Проект**.
2. В разделе **Шаблоны** разверните список **Другие типы проектов**, щелкните **Решения Visual Studio** и выберите **Новое решение**.
3. Введите имя, описывающее приложение, и назначение этого решения (например, LitwareBatchTaskPrograms).
4. Чтобы создать решение, нажмите кнопку **ОК**.

## <a name="job-manager-template"></a>Шаблон "Диспетчер заданий"
Шаблон "Диспетчер заданий" позволяет внедрить задачу диспетчера заданий, выполняющую следующие действия:

* разделение задания на несколько задач;
* отправка этих задач для выполнения в пакетной службе.

> [!NOTE]
> Дополнительные сведения о задачах диспетчера заданий см. в статье [Обзор функций пакетной службы для разработчиков](batch-api-basics.md#job-manager-task).
> 
> 

### <a name="create-a-job-manager-using-the-template"></a>Создание диспетчера заданий с помощью шаблона
Чтобы добавить в созданное ранее решение диспетчер заданий, сделайте следующее:

1. Откройте имеющееся решение в Visual Studio.
2. В обозревателе решений щелкните решение правой кнопкой мыши и выберите **Добавить** > **Новый проект**.
3. В разделе **Visual C#** щелкните **Облако**, а затем — **Azure Batch Job Manager with Job Splitter** (Диспетчер заданий пакетной службы Azure с разделителем заданий).
4. Введите имя, описывающее приложение и определяющее этот проект в качестве диспетчера заданий (например, LitwareJobManager).
5. Чтобы создать проект, нажмите кнопку **ОК**.
6. Наконец, создайте проект, чтобы принудительно загрузить в среде Visual Studio все указанные пакеты NuGet, а также чтобы убедиться, что проект допустимый, прежде чем начать изменять его.

### <a name="job-manager-template-files-and-their-purpose"></a>Файлы шаблона "Диспетчер заданий" и их назначение
При создании проекта с помощью шаблона "Диспетчер заданий" создается три группы файлов кода:

* Файл основной программы (Program.cs). Он содержит точку входа программы и расширенные средства обработки исключений. Обычно не требуется изменять этот файл.
* Каталог платформы. Здесь содержатся файлы, отвечающие за стандартные операции программы диспетчера заданий: распаковка параметров, добавление задач в задание пакетной службы и т. д. Обычно не требуется изменять эти файлы.
* Файл разделителя заданий (JobSplitter.cs). Именно в него помещается логика приложения для разделения задания на задачи.

Конечно, при необходимости для поддержки кода разделителя заданий можно добавить дополнительные файлы в зависимости от сложности логики разделителя заданий.

Шаблон также создает стандартные проектные файлы .NET, например CSPROJ-файл, app.config, packages.config и т. д.

В остальной части этого раздела представлено описание различных файлов и структуры кода в них, а также объяснение назначения каждого класса.

![Обозреватель решений Visual Studio, в котором отображается решение шаблона "Диспетчер заданий"][solution_explorer01]

**Файлы платформы**

* `Configuration.cs` инкапсулирует загрузку данных конфигурации задания, например сведения об учетной записи пакетной службы, учетные данные связанной учетной записи хранения, сведения о задании и задаче, а также параметры задания. Он также предоставляет доступ к переменным среды, определяемым пакетной службой (см. параметры среды для задач в документации пакетной службы), в классе Configuration.EnvironmentVariable.
* `IConfiguration.cs` абстрагирует реализацию класса конфигурации, чтобы пользователь мог выполнить модульный тест с разделителем заданий, используя фиктивный или ложный объект конфигурации.
* `JobManager.cs` управляет компонентами программы диспетчера заданий. Он отвечает за инициализацию разделителя заданий, вызов разделителя заданий и подготовку задач, возвращаемых разделителем заданий, к пересылке отравителю задач.
* `JobManagerException.cs` представляет ошибку, требующую завершения работы диспетчера заданий. JobManagerException используется для помещения ожидаемых ошибок в оболочку. При завершении работы могут указываться конкретные диагностические сведения.
* `TaskSubmitter.cs`. Этот класс отвечает за добавление задач, возвращаемых разделителем заданий, в пакетную службу. Класс JobManager объединяет последовательность задач в пакеты для эффективного и своевременного добавления в задание, а затем вызывает TaskSubmitter.SubmitTasks в фоновом потоке для каждого пакета.

**Разделитель заданий**

`JobSplitter.cs`. Этот класс содержит логику приложения для разделения задания на задачи. Платформа вызывает метод JobSplitter.Split для получения последовательности задач, которые она добавляет в задание, когда метод возвращает их. В этот класс встраивается логика задания. Реализуйте метод Split, чтобы вернуть последовательность экземпляров CloudTask, представляющих задачи, на которые требуется разбить задание.

**Стандартные файлы проекта .NET командной строки**

* `App.config`— стандартный файл конфигурации приложения .NET.
* `Packages.config` — стандартный файл зависимостей пакета NuGet.
* `Program.cs` содержит точку входа программы и расширенные средства обработки исключений.

### <a name="implementing-the-job-splitter"></a>Внедрение разделителя заданий
При открытии проекта шаблона "Диспетчер заданий" файл JobSplitter.cs откроется по умолчанию. Вы можете внедрить логику разделения для выполнения задач в рабочей нагрузке, используя метод Split() из следующего примера:

```csharp
/// <summary>
/// Gets the tasks into which to split the job. This is where you inject
/// your application-specific logic for decomposing the job into tasks.
///
/// The job manager framework invokes the Split method for you; you need
/// only to implement it, not to call it yourself. Typically, your
/// implementation should return tasks lazily, for example using a C#
/// iterator and the "yield return" statement; this allows tasks to be added
/// and to start running while splitting is still in progress.
/// </summary>
/// <returns>The tasks to be added to the job. Tasks are added automatically
/// by the job manager framework as they are returned by this method.</returns>
public IEnumerable<CloudTask> Split()
{
    // Your code for the split logic goes here.
    int startFrame = Convert.ToInt32(_parameters["StartFrame"]);
    int endFrame = Convert.ToInt32(_parameters["EndFrame"]);

    for (int i = startFrame; i <= endFrame; i++)
    {
        yield return new CloudTask("myTask" + i, "cmd /c dir");
    }
}
```

> [!NOTE]
> Раздел с заметками в методе `Split()` — единственная часть кода шаблона "Диспетчер заданий", которую нужно изменить, добавив логику для разделения заданий на различные задачи. Чтобы изменить другой раздел шаблона, нужно ознакомиться с принципами работы пакетной службы и опробовать некоторые из [примеров кода этой службы][github_samples].
> 
> 

Для реализации метода Split() доступны такие компоненты:

* параметры задания (в поле `_parameters`);
* объект CloudJob, представляющий задание (в поле `_job`);
* объект CloudTask, представляющий задание диспетчера заданий (в поле `_jobManagerTask`).

При реализации `Split()` не нужно добавлять задачи в задание напрямую. Код должен возвращать последовательность объектов CloudTask, а классы платформы, вызывающие разделитель заданий, добавят задачи в задание автоматически. Как правило, для внедрения разделителей заданий используется итератор для C# (`yield return`), так как таким образом можно начать выполнение задач как можно быстрее, а не дожидаться обработки всех задач.

**Сбой разделителя заданий**

При сбое разделитель заданий делает следующее:

* Завершает последовательность с помощью утверждения C# `yield break`. В этом случае диспетчер заданий будет считаться таким, который совершил выполнение успешно.
* Выдает исключение. В этом случае диспетчер заданий рассматривается как такой, в котором произошел сбой. Он может запускаться повторно в зависимости от конфигурации клиента.

В обоих случаях любые задачи, возвращенные разделителем заданий и добавленные в пакетную службу, можно запускать. Чтобы этого не произошло, можно сделать следующее:

* Завершить выполнение задания перед возвратом из разделителя заданий.
* Создать коллекцию задач перед возвратом (то есть необходимо вернуть `ICollection<CloudTask>` или `IList<CloudTask>`, а не внедрять разделитель заданий с помощью итераторов для C#).
* Создать зависимость заданий от успешного завершения работы диспетчера заданий.

**Повторная попытка запуска диспетчера заданий**

При сбое пакетная служба может предпринять попытку повторного запуска диспетчера заданий в зависимости от параметров повторных попыток клиента. Как правило, это безопасно, так как при добавлении задачи в задание платформа игнорирует любые имеющиеся задачи. Тем не менее если вычисление задач требует значительных затрат, вам не захочется тратить дополнительные средства на выполнение повторного вычисления задач, добавленных в задание. Напротив, если при повторном вычислении не будут получены те же идентификаторы задач, игнорирование повторяющихся элементов не принесет пользу. В таких случаях следует настроить разделитель заданий таким образом, чтобы он определял выполненные задания и не выполнял их снова, например, выполняя CloudJob.ListTasks перед выдачей задач.

### <a name="exit-codes-and-exceptions-in-the-job-manager-template"></a>Коды выхода и исключения в шаблоне "Диспетчер заданий"
Коды выхода и исключения позволяют определить результат выполнения программы, а также выявить проблемы при ее выполнении. Шаблон "Диспетчер заданий" реализует коды выхода и исключения, описанные в этом разделе.

Задача диспетчера заданий, реализующаяся с помощью шаблона "Диспетчер заданий", может вернуть три возможных кода выхода:

| Код | ОПИСАНИЕ |
| --- | --- |
| 0 |Задание диспетчера заданий выполнено успешно. Код разделителя заданий выполнен. Все задачи добавлены в задание. |
| 1 |Произошел сбой задания диспетчера заданий с исключением в ожидаемых результатах программы. Исключение преобразовано в JobManagerException с диагностическими сведениями и рекомендациями по устранению ошибки, где это возможно. |
| 2 |Произошел сбой задания диспетчера заданий с непредвиденным исключением. Исключение зарегистрировано в стандартный вывод, но диспетчеру заданий не удалось добавить дополнительные диагностические сведения или рекомендации по исправлению. |

При сбое задачи диспетчера заданий некоторые задачи могут быть добавлены в службу до возникновения ошибки. Эти задачи будут выполняться в обычном режиме. Обсуждение этого пути кода см. в разделе "Сбой разделителя заданий" выше.

Все сведения, возвращаемые исключением, записываются в файлы stdout.txt и stderr.txt. Дополнительные сведения см. в разделе [Обработка ошибок](batch-api-basics.md#error-handling).

### <a name="client-considerations"></a>Рекомендации для клиента
В этом разделе описываются некоторые требования к реализации в клиенте при вызове диспетчера заданий с использованием этого шаблона. Дополнительные сведения о передаче параметров и переменных среды из клиентского кода см. в [этом разделе](#pass-environment-settings).

**Обязательные учетные данные**

Чтобы добавить задачи в задание пакетной службы Azure, задаче диспетчера заданий требуется URL-адрес и ключ учетной записи пакетной службы Azure. Их необходимо передать в переменные среды YOUR_BATCH_URL и YOUR_BATCH_KEY. Их можно задать в параметрах среды задач диспетчера заданий. Например, в клиенте C#:

```csharp
job.JobManagerTask.EnvironmentSettings = new [] {
    new EnvironmentSetting("YOUR_BATCH_URL", "https://account.region.batch.azure.com"),
    new EnvironmentSetting("YOUR_BATCH_KEY", "{your_base64_encoded_account_key}"),
};
```
**Учетные данные хранилища**

Как правило, клиенту не требуется предоставлять учетные данные связанной учетной записи хранения для задачи диспетчера заданий, так как большинству диспетчеров заданий не требуется непосредственный доступ к связанной учетной записи хранения. Кроме того, связанная учетная запись хранения часто указывается для всех задач в качестве общего параметра среды для задания. Если связанная учетная запись хранения не указывается в общих параметрах среды, а диспетчеру заданий требуется доступ к связанному хранилищу, следует указать учетные данные связанного хранилища следующим образом:

```csharp
job.JobManagerTask.EnvironmentSettings = new [] {
    /* other environment settings */
    new EnvironmentSetting("LINKED_STORAGE_ACCOUNT", "{storageAccountName}"),
    new EnvironmentSetting("LINKED_STORAGE_KEY", "{storageAccountKey}"),
};
```

**Параметры задачи диспетчера заданий**

Клиент должен задать для флага диспетчера заданий *killJobOnCompletion* значение **false**.

Обычно клиенту можно задать для параметра *runExclusive* значение **false**.

Клиент должен использовать коллекцию *resourceFiles* или *applicationPackageReferences*, чтобы развернуть исполняемый файл диспетчера заданий (и необходимые библиотеки DLL) на вычислительном узле.

По умолчанию при сбое не будет выполняться повторный запуск диспетчера заданий. В зависимости от логики диспетчера заданий клиенту может потребоваться выполнить повторную попытку через *constraints*/*maxTaskRetryCount*.

**Параметры задания**

Если разделитель заданий выдает задачи с зависимостями, клиенту требуется задать для параметра задания usesTaskDependencies значение true.

В модели разделителя заданий, как правило, клиенты не добавляют в задания больше задач, чем создает разделитель заданий. Поэтому обычно клиенту нужно задать для параметра задания *onAllTasksComplete* значение **terminatejob**.

## <a name="task-processor-template"></a>Шаблон "Обработчик задач"
Шаблон "Обработчик задач" позволяет внедрить обработчик задач, выполняющий следующие действия:

* настройка сведений, необходимых для выполнения каждой задачи пакетной службы;
* выполнение всех действий, необходимых для каждой задачи пакетной службы;
* сохранение результатов задачи в постоянное хранилище.

Хотя обработчик задач не является обязательным для выполнения задач в пакетной службе, он предоставляет оболочку для реализации всех действий по выполнению задач в одном месте. В этом заключается ключевое преимущество его использования. Например, если в контексте каждой задачи необходимо выполнить несколько приложений или если после завершения каждой задачи необходимо скопировать данные в постоянное хранилище.

Сложность и количество действий, выполняемых обработчиком задач, зависит от требований рабочей нагрузки. Кроме того, внедрив все действия задач в один обработчик задач, можно легко обновить или добавить действия с учетом изменений требований к приложениям или рабочей нагрузке. Однако в некоторых случаях обработчик задач может оказаться не самым оптимальным решением для внедрения, так как он может создать излишние сложности, например, при выполнении заданий, которые можно быстро запустить из простой командной строки.

### <a name="create-a-task-processor-using-the-template"></a>Создание обработчика задач с помощью шаблона
Чтобы добавить в созданное ранее решение обработчик задач, сделайте следующее:

1. Откройте имеющееся решение в Visual Studio.
2. В обозревателе решений щелкните правой кнопкой мыши проект, выберите пункт **Добавить**, а затем щелкните **Новый проект**.
3. В разделе **Visual C#** щелкните **Облако**, а затем — **Azure Batch Task Processor** (Обработчик задач пакетной службы Azure).
4. Введите имя, описывающее приложение и определяющее этот проект в качестве обработчика задач (например, LitwareTaskProcessor).
5. Чтобы создать проект, нажмите кнопку **ОК**.
6. Наконец, создайте проект, чтобы принудительно загрузить в среде Visual Studio все указанные пакеты NuGet, а также чтобы убедиться, что проект допустимый, прежде чем начать изменять его.

### <a name="task-processor-template-files-and-their-purpose"></a>Файлы шаблона "Обработчик задач" и их назначение
При создании проекта с помощью шаблона "Обработчик задач" создается три группы файлов кода:

* Файл основной программы (Program.cs). Он содержит точку входа программы и расширенные средства обработки исключений. Обычно не требуется изменять этот файл.
* Каталог платформы. Здесь содержатся файлы, отвечающие за стандартные операции программы диспетчера заданий: распаковка параметров, добавление задач в задание пакетной службы и т. д. Обычно не требуется изменять эти файлы.
* Файл обработчика задач (TaskProcessor.cs). Сюда помещается логика приложения для выполнения задачи (как правило, путем вызова имеющегося исполняемого файла). Сюда также помещается код предварительной обработки и постобработки, например для скачивания дополнительных данных или отправки файлов результатов.

Конечно, при необходимости для поддержки кода обработчика задач можно добавить дополнительные файлы в зависимости от сложности логики разделителя заданий.

Шаблон также создает стандартные проектные файлы .NET, например CSPROJ-файл, app.config, packages.config и т. д.

В остальной части этого раздела представлено описание различных файлов и структуры кода в них, а также объяснение назначения каждого класса.

![Обозреватель решений Visual Studio, в котором отображается решение шаблона "Обработчик задач"][solution_explorer02]

**Файлы платформы**

* `Configuration.cs` инкапсулирует загрузку данных конфигурации задания, например сведения об учетной записи пакетной службы, учетные данные связанной учетной записи хранения, сведения о задании и задаче, а также параметры задания. Он также предоставляет доступ к переменным среды, определяемым пакетной службой (см. параметры среды для задач в документации пакетной службы), в классе Configuration.EnvironmentVariable.
* `IConfiguration.cs` абстрагирует реализацию класса конфигурации, чтобы пользователь мог выполнить модульный тест с разделителем заданий, используя фиктивный или ложный объект конфигурации.
* `TaskProcessorException.cs` представляет ошибку, требующую завершения работы диспетчера заданий. TaskProcessorException используется для помещения ожидаемых ошибок в оболочку. При завершении работы могут указываться конкретные диагностические сведения.

**Обработчик задач**

* `TaskProcessor.cs`выполняет задачу. Платформа вызывает метод TaskProcessor.Run. В этот класс вставляется логика задачи для приложения. Реализуйте метод Run, чтобы выполнить следующее:
  * проанализировать и проверить все параметры задачи;
  * создать командную строку для любой внешней программы, которую нужно вызвать;
  * зарегистрировать любые диагностические сведения, которые могут потребоваться для отладки;
  * запустить процесс с помощью созданной командной строки;
  * дождаться завершения процесса;
  * записать код выхода процесса, чтобы определить, насколько успешно он выполнен;
  * сохранить выходные файлы, которые нужно сохранить в постоянном хранилище.

**Стандартные файлы проекта .NET командной строки**

* `App.config`— стандартный файл конфигурации приложения .NET.
* `Packages.config` — стандартный файл зависимостей пакета NuGet.
* `Program.cs` содержит точку входа программы и расширенные средства обработки исключений.

## <a name="implementing-the-task-processor"></a>Реализация обработчика задач
При открытии проекта шаблона "Обработчик задач" файл TaskProcessor.cs откроется по умолчанию. Логику выполнения для задач в рабочей нагрузке можно внедрить, используя метод Run() из следующего примера:

```csharp
/// <summary>
/// Runs the task processing logic. This is where you inject
/// your application-specific logic for decomposing the job into tasks.
///
/// The task processor framework invokes the Run method for you; you need
/// only to implement it, not to call it yourself. Typically, your
/// implementation will execute an external program (from resource files or
/// an application package), check the exit code of that program and
/// save output files to persistent storage.
/// </summary>
public async Task<int> Run()

{
    try
    {
        //Your code for the task processor goes here.
        var command = $"compare {_parameters["Frame1"]} {_parameters["Frame2"]} compare.gif";
        using (var process = Process.Start($"cmd /c {command}"))
        {
            process.WaitForExit();
            var taskOutputStorage = new TaskOutputStorage(
            _configuration.StorageAccount,
            _configuration.JobId,
            _configuration.TaskId
            );
            await taskOutputStorage.SaveAsync(
            TaskOutputKind.TaskOutput,
            @"..\stdout.txt",
            @"stdout.txt"
            );
            return process.ExitCode;
        }
    }
    catch (Exception ex)
    {
        throw new TaskProcessorException(
        $"{ex.GetType().Name} exception in run task processor: {ex.Message}",
        ex
        );
    }
}
```
> [!NOTE]
> Раздел с заметками в методе Run() — единственная часть кода шаблона "Обработчик задач", которую нужно изменить, добавив логику выполнения для задач в рабочей нагрузке. Если требуется изменить другой раздел шаблона, ознакомьтесь с принципами работы пакетной службы, просмотрев соответствующую документацию и опробовав некоторые из примеров кода пакетной службы.
> 
> 

Метод Run() отвечает за запуск командной строки, запуск одного или нескольких процессов, ожидание завершения всех процессов, сохранение результатов и возврат с кодом выхода. В методе Run() выполняется реализация логики обработки для задач. Платформа обработчика задач вызывает метод Run() автоматически. Поэтому не нужно делать это вручную.

Для реализации метода Run() доступны такие компоненты:

* параметры задачи (в поле `_parameters`);
* идентификаторы задания и задачи (в полях `_jobId` и `_taskId`);
* конфигурация задачи (в поле `_configuration` ).

**Сбой выполнения задачи**

При сбое можно выйти из метода Run() путем создания исключения. Однако в таком случае кодом выхода управляет главный обработчик исключений. Если необходимо управлять кодом выхода, чтобы отличать различные типы сбоев (например, в целях диагностики или потому что в некоторых режимах сбоя нужно завершать выполнение задание, а в других — нет), нужно выйти из метода Run() путем возврата ненулевого кода выхода. Он становится кодом выхода задачи.

### <a name="exit-codes-and-exceptions-in-the-task-processor-template"></a>Коды выхода и исключения в шаблоне "Обработчик задач"
Коды выхода и исключения позволяют определить результат выполнения программы, а также выявить проблемы при ее выполнении. Шаблон "Обработчик задач" реализует коды выхода и исключения, описанные в этом разделе.

Задача обработчика задач, реализующаяся с помощью шаблона "Обработчик задач", может вернуть три возможных кода выхода:

| Код | ОПИСАНИЕ |
| --- | --- |
| [Process.ExitCode][process_exitcode] |Обработчик задач выполнен. Обратите внимание, что это не означает, что при вызове программы ее выполнение успешно завершилось. Это означает, что обработчик задач успешно вызвал ее и выполнил любые операции постобработки без исключений. Значение кода выхода зависит от вызванной программы. Обычно код выхода 0 означает, что программа выполнена успешно, а любой другой код выхода означает, что произошел сбой. |
| 1 |Произошел сбой обработчика задач с исключением в ожидаемых результатах программы. Исключение преобразовано в `TaskProcessorException` с диагностическими сведениями и рекомендациями по устранению ошибки, где это возможно. |
| 2 |Произошел сбой обработчика задач с непредвиденным исключением. Исключение зарегистрировано в стандартный вывод, но обработчику задач не удалось добавить дополнительные диагностические сведения или рекомендации по исправлению. |

> [!NOTE]
> Если вызываемая программа использует коды выхода 1 и 2 для указания конкретных режимов сбоя, использование кодов выхода 1 и 2 для ошибок обработчика задач приведет к неоднозначности. Эти коды ошибок обработчика задач можно изменить на отличающиеся коды выхода, изменив исключения в файле Program.cs.
> 
> 

Все сведения, возвращаемые исключением, записываются в файлы stdout.txt и stderr.txt. Дополнительные сведения см. в разделе об обработке ошибок в документации по пакетной службе.

### <a name="client-considerations"></a>Рекомендации для клиента
**Учетные данные хранилища**

Если обработчик задач сохраняет результаты в хранилище BLOB-объектов Azure, например с использованием вспомогательной библиотеки соглашений по именованию файлов, то ему требуется доступ *к* учетным данным облачной учетной записи хранения *или* URL-адресу контейнера больших двоичных объектов, включающего подписанный URL-адрес (SAS). Шаблон поддерживает предоставление учетных данных через общие переменные среды. Клиент может передать учетные данные хранилища следующим образом:

```csharp
job.CommonEnvironmentSettings = new [] {
    new EnvironmentSetting("LINKED_STORAGE_ACCOUNT", "{storageAccountName}"),
    new EnvironmentSetting("LINKED_STORAGE_KEY", "{storageAccountKey}"),
};
```

Затем учетная запись хранения становится доступной в свойстве `_configuration.StorageAccount` класса TaskProcessor.

Если вы предпочитаете использовать URL-адрес контейнера с SAS, их также можно передать в общих параметрах среды задания. Однако в настоящее время в шаблон "Обработчик задач" не встроена поддержка этой возможности.

**Настройка хранилища**

Рекомендуется, чтобы клиент или задание обработчика заданий создавали контейнеры, необходимые задачам, прежде чем добавлять задачи в задание. Это обязательно, если URL-адрес контейнера используется с SAS, так как такой URL-адрес не включает разрешение на создание контейнера. Это рекомендуется сделать даже при передаче учетных данных учетной записи хранения, так как при вызове CloudBlobContainer.CreateIfNotExistsAsync для контейнера сохраняются все задачи.

## <a name="pass-parameters-and-environment-variables"></a>Передача параметров и переменных среды
### <a name="pass-environment-settings"></a>Передача параметров среды
Клиент может передать сведения задаче диспетчера заданий в виде параметров среды. Затем эти сведения может использовать задача диспетчера заданий при создании задач соответствующего обработчика, которые будут выполняться как часть вычислительного задания. Ниже приведены примеры сведений, которые можно передать в качестве параметров среды:

* имя учетной записи хранения и ключ учетной записи;
* URL-адрес учетной записи пакетной службы;
* ключ учетной записи пакетной службы.

В пакетной службе предусмотрен простой механизм передачи параметров среды в задаче диспетчера заданий. Для этого нужно использовать свойство `EnvironmentSettings` в [Microsoft.Azure.Batch.JobManagerTask][net_jobmanagertask].

Например, чтобы получить экземпляр `BatchClient` для учетной записи пакетной службы, в качестве переменных среды из клиентского кода можно передать URL-адрес и учетные данные общего ключа для учетной записи пакетной службы. Аналогично для получения доступа к учетной записи хранения, связанной с учетной записью пакетной службы, в качестве переменных среды можно передать имя и ключ учетной записи хранения.

### <a name="pass-parameters-to-the-job-manager-template"></a>Передача параметров в шаблон "Диспетчер заданий"
Во многих случаях полезно передать параметры конкретного задания в задачу диспетчера заданий, чтобы управлять процессом разделения заданий или настроить задачи для задания. Это можно сделать, загрузив JSON-файл с именем parameters.json в качестве файла ресурсов для задачи диспетчера заданий. После этого параметры станут доступными в поле `JobSplitter._parameters` шаблона "Диспетчер заданий".

> [!NOTE]
> Встроенный обработчик параметров поддерживает только строчные словари. Если требуется передать сложные значения JSON в качестве значений параметров, их необходимо передать в качестве строки и проанализировать в разделителе заданий или изменить метод платформы `Configuration.GetJobParameters`.
> 
> 

### <a name="pass-parameters-to-the-task-processor-template"></a>Передача параметров в шаблон "Обработчик задач"
Параметры можно также передавать в отдельные задачи, реализованные с помощью шаблона "Обработчик задач". Так же как и в случае с шаблоном "Диспетчер заданий", шаблон "Обработчик задач" выполняет поиск файла ресурсов с именем

parameters.json. Если он найден, он загружается в качестве словаря параметров. Существует несколько способов передачи параметров задачам обработчика задач:

* Повторное использование параметров задания JSON. Это подходит, если представлены только параметры уровня задания (например, высота и ширина отрисовки). Для этого при создании CloudTask в разделителе заданий нужно добавить ссылку на объект файла ресурсов parameters.json из коллекции ResourceFiles задачи диспетчера заданий (`JobSplitter._jobManagerTask.ResourceFiles`) в коллекцию ResourceFiles объекта CloudTask.
* Создание и отправка документа parameters.json конкретной задачи при выполнении разделителя заданий и создание ссылки на большой двоичный объект в коллекции файлов ресурсов задачи. Это необходимо, если в разных задачах используются разные параметры. Примером может служить сценарий отрисовки 3D-данных, где индекс кадра передается задаче в качестве параметра.

> [!NOTE]
> Встроенный обработчик параметров поддерживает только строчные словари. Если требуется передать сложные значения JSON в качестве значений параметров, их необходимо передать в качестве строки и проанализировать в обработчике задач или изменить метод платформы `Configuration.GetTaskParameters`.
> 
> 

## <a name="next-steps"></a>Дополнительная информация
### <a name="persist-job-and-task-output-to-azure-storage"></a>Сохранение выходных данных заданий и задач в службе хранилища Azure
Еще одно полезное средство в разработке решений пакетной службы — [Azure Batch File Conventions][nuget_package]. Эта библиотека классов .NET (сейчас доступна предварительная версия) позволяет приложениям .NET пакетной службы легко сохранять выходные данные задач в службе хранилища Azure и извлекать их из нее. [Сохранение выходных данных заданий и задач пакетной службы Azure](batch-task-output.md) содержится полное описание библиотеки и сведения о ее использовании.

### <a name="batch-forum"></a>Форум по Пакетной службе
На [форуме по пакетной службе Azure][forum] на сайте MSDN можно обсудить пакетную службу и задать вопросы о ней. Изучайте полезные «прикрепленные» сообщения и задавайте вопросы, возникающие во время сборки пакетных решений.

[forum]: https://social.msdn.microsoft.com/forums/azure/en-US/home?forum=azurebatch
[net_jobmanagertask]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.jobmanagertask.aspx
[github_samples]: https://github.com/Azure/azure-batch-samples
[nuget_package]: https://www.nuget.org/packages/Microsoft.Azure.Batch.Conventions.Files
[process_exitcode]: https://msdn.microsoft.com/library/system.diagnostics.process.exitcode.aspx
[vs_gallery]: https://visualstudiogallery.msdn.microsoft.com/
[vs_gallery_templates]: https://go.microsoft.com/fwlink/?linkid=820714
[vs_find_use_ext]: https://msdn.microsoft.com/library/dd293638.aspx

[diagram01]: ./media/batch-visual-studio-templates/diagram01.png
[solution_explorer01]: ./media/batch-visual-studio-templates/solution_explorer01.png
[solution_explorer02]: ./media/batch-visual-studio-templates/solution_explorer02.png
