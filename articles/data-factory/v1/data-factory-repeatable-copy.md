---
title: Повторяющаяся операция копирования в фабрике данных Azure | Документация Майкрософт
description: Узнайте, как избежать создания дубликатов даже при многократном выполнении среза, копирующего данные.
services: data-factory
documentationcenter: ''
author: linda33wj
manager: craigg
editor: ''
ms.service: data-factory
ms.workload: data-services
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: conceptual
ms.date: 01/10/2018
ms.author: jingwang
robots: noindex
ms.openlocfilehash: 8b1d1cf62dad94ca6141ce33783c0b16b50c931c
ms.sourcegitcommit: 266fe4c2216c0420e415d733cd3abbf94994533d
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/01/2018
ms.locfileid: "34622641"
---
# <a name="repeatable-copy-in-azure-data-factory"></a>Повторяющаяся операция копирования в фабрике данных Azure

## <a name="repeatable-read-from-relational-sources"></a>Повторяющиеся операции чтения из реляционных источников
При копировании данных из реляционных хранилищ важно помнить о повторяемости, чтобы избежать непредвиденных результатов. В фабрике данных Azure можно вручную повторно выполнить срез. Вы можете также настроить для набора данных политику повтора, чтобы при сбое срез выполнялся повторно. При повторном выполнении среза в любом случае необходимо убедиться в том, что считываются те же данные, независимо от того, сколько раз выполняется срез.  
 
> [!NOTE]
> Приведенные ниже примеры предназначены для SQL Azure, но подходят для любого хранилища данных, поддерживающего прямоугольные наборы данных. Для хранилища данных может потребоваться настроить параметр **type** источника и свойство **query** (например, query вместо sqlReaderQuery).   

Обычно при чтении из реляционных хранилищ нужно считывать только данные, соответствующие этому срезу. Сделать это можно с помощью системных переменных WindowStart и WindowEnd, доступных в фабрике данных Azure. Сведения о переменных и функциях в фабрике данных Azure см. в статье [Фабрика данных Azure — функции и системные переменные](data-factory-functions-variables.md). Пример: 

```json
"source": {
    "type": "SqlSource",
    "sqlReaderQuery": "$$Text.Format('select * from MyTable where timestampcolumn >= \\'{0:yyyy-MM-dd HH:mm\\' AND timestampcolumn < \\'{1:yyyy-MM-dd HH:mm\\'', WindowStart, WindowEnd)"
},
```
Этот запрос считывает из таблицы MyTable все данные, которые попадают во временной диапазон среза (от WindowStart до WindowEnd). Повторное выполнение этого среза всегда возвращает одни и те же данные. 

В других случаях может потребоваться чтение всей таблицы.Тогда sqlReaderQuery можно определить следующим образом:

```json
"source": 
{            
    "type": "SqlSource",
    "sqlReaderQuery": "select * from MyTable"
},
```

## <a name="repeatable-write-to-sqlsink"></a>Повторяемая запись в SqlSink
При копировании данных в **SQL Azure или SQL Server** из других хранилищ данных необходимо помнить о повторяемости, чтобы избежать незапланированных результатов. 

Когда вы копируете данные в базу данных SQL Server, действие копирования по умолчанию добавляет данные в таблицу приемника. Предположим, что данные копируются из файла CSV (значения, разделенные запятыми), содержащего две записи, в следующую таблицу в базе данных SQL Server или Azure SQL. При выполнении среза в таблицу SQL копируются две записи. 

```
ID    Product        Quantity    ModifiedDate
...    ...            ...            ...
6    Flat Washer    3            2015-05-01 00:00:00
7     Down Tube    2            2015-05-01 00:00:00
```

Теперь допустим, что в исходном файле вы нашли ошибку и изменили значение параметра Down Tube (изменив 2 на 4). Если вы вручную повторно выполните срез данных за тот же период, к базе данных Azure SQL или SQL Server будут добавлены две новые записи. В этом примере предполагается, что ни один из столбцов таблицы не содержит ограничений первичного ключа.

```
ID    Product        Quantity    ModifiedDate
...    ...            ...            ...
6    Flat Washer    3            2015-05-01 00:00:00
7     Down Tube    2            2015-05-01 00:00:00
6    Flat Washer    3            2015-05-01 00:00:00
7     Down Tube    4            2015-05-01 00:00:00
```

Чтобы избежать такого поведения, нужно указать семантику UPSERT, используя один из двух возможных механизмов.

### <a name="mechanism-1-using-sqlwritercleanupscript"></a>Механизм 1: использование sqlWriterCleanupScript
Вы можете добавить свойство **sqlWriterCleanupScript**, чтобы при запуске среза очищать данные из таблицы-приемника перед вставкой данных. 

```json
"sink":  
{ 
  "type": "SqlSink", 
  "sqlWriterCleanupScript": "$$Text.Format('DELETE FROM table WHERE ModifiedDate >= \\'{0:yyyy-MM-dd HH:mm}\\' AND ModifiedDate < \\'{1:yyyy-MM-dd HH:mm}\\'', WindowStart, WindowEnd)"
}
```

Когда выполняется срез, сначала скрипт очистки удаляет из таблицы SQL все данные, соответствующие добавляемому фрагменту. Затем действие копирования вставляет данные в таблицу SQL. Если выполнить такой срез повторно, число будет изменено правильным образом.

```
ID    Product        Quantity    ModifiedDate
...    ...            ...            ...
6    Flat Washer    3            2015-05-01 00:00:00
7     Down Tube    4            2015-05-01 00:00:00
```

Предположим, что запись Flat Washer удалена из исходного CSV-файла. Тогда повторное выполнение среза даст такой результат: 

```
ID    Product        Quantity    ModifiedDate
...    ...            ...            ...
7     Down Tube    4            2015-05-01 00:00:00
```

Действие копирования выполнило скрипт очистки, удалив соответствующие данные среза. Затем оно получает входные данные из CSV-файла (теперь в нем всего одна запись) и вставляет их в таблицу. 

### <a name="mechanism-2-using-sliceidentifiercolumnname"></a>Механизм 2: использование sliceIdentifierColumnName
> [!IMPORTANT]
> Сейчас sliceIdentifierColumnName не поддерживается для хранилища данных SQL Azure. 

Другой способ достижения повторяемости — выделение в целевой таблице специального столбца sliceIdentifierColumnName. Этот столбец будет использовать фабрика данных Azure, чтобы синхронизировать источник и назначение. Такой подход работает при наличии гибкости в изменении или определении целевой схемы таблицы SQL. 

Фабрика данных Azure будет использовать этот столбец для достижения повторяемости, не изменяя при этом схему таблицы. Способ применения этого подхода:

1. Определите в целевой таблице SQL столбец двоичного типа (**binary (32)**). Для этого столбца не должно быть никаких ограничений. Для нашего примера давайте назовем столбец AdfSliceIdentifier.


    Исходная таблица:

    ```sql
    CREATE TABLE [dbo].[Student](
       [Id] [varchar](32) NOT NULL,
       [Name] [nvarchar](256) NOT NULL
    )
    ```

    Целевая таблица: 

    ```sql
    CREATE TABLE [dbo].[Student](
       [Id] [varchar](32) NOT NULL,
       [Name] [nvarchar](256) NOT NULL,
       [AdfSliceIdentifier] [binary](32) NULL
    )
    ```

2. Он будет использоваться в действии копирования следующим образом.
   
    ```json
    "sink":  
    { 
   
        "type": "SqlSink", 
        "sliceIdentifierColumnName": "AdfSliceIdentifier"
    }
    ```

Фабрика данных Azure заполняет этот столбец так, чтобы поддерживать синхронизацию источника и назначения. Значения этого столбца не следует использовать для других целей. 

Как и при использовании первого механизма, действие копирования сначала автоматически удаляет из целевой таблицы SQL данные для заданного среза. После этого данные из источника вставляются в целевую таблицу. 

## <a name="next-steps"></a>Дополнительная информация
См. следующие статьи о соединителях, где есть полные примеры JSON: 

- [база данных SQL Azure;](data-factory-azure-sql-connector.md)
- [Хранилище данных SQL Azure](data-factory-azure-sql-data-warehouse-connector.md)
- [SQL Server](data-factory-sqlserver-connector.md)
