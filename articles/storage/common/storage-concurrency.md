---
title: Управление параллелизмом в службе хранилища Microsoft Azure
description: Как управлять параллелизмом для служб BLOB-объектов, очередей, таблиц и файлов
services: storage
documentationcenter: ''
author: jasontang501
manager: tadb
editor: tysonn
ms.assetid: cc6429c4-23ee-46e3-b22d-50dd68bd4680
ms.service: storage
ms.workload: storage
ms.tgt_pltfrm: na
ms.devlang: dotnet
ms.topic: article
ms.date: 05/11/2017
ms.author: jasontang501
ms.openlocfilehash: 937cca66a0af0674b868e6a87681adbea330e91c
ms.sourcegitcommit: 6fcd9e220b9cd4cb2d4365de0299bf48fbb18c17
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/05/2018
ms.locfileid: "23060189"
---
# <a name="managing-concurrency-in-microsoft-azure-storage"></a>Управление параллелизмом в службе хранилища Microsoft Azure
## <a name="overview"></a>Обзор
В современных интернет-приложениях данные могут одновременно просматриваться и обновляться несколькими пользователями. Это требует от разработчиков приложений тщательного подхода для обеспечения предсказуемого взаимодействия с конечным пользователем, в частности для сценариев с одновременным обновлением данных несколькими пользователями. Обычно разработчики рассматривают три следующие основные стратегии конфликтов данных:  

1. Оптимистический параллелизм — Обновляемое приложение при обновлении определяет, произошли ли изменения данных с момента последнего считывания данных приложением. Например, если два пользователя просматривают одну и ту же вики-страницу и вносят изменения в нее, платформа вики должна обеспечить возможность для первого обновления не быть перезаписанным вторым, а пользователи должны понять, удачно ли прошло их обновление. Стратегия наиболее часто применяется в веб-приложениях.
2. Пессимистичный параллелизм — До начала обновления приложение блокирует доступ к объекту, не позволяя пользователю изменить данные до снятия блокировки. Например, в сценарии репликации данных ведущий/ведомый, где данные обновляются только ведущим, ведущий применяет монопольную блокировку данных на длительный период времени для предотвращения его изменений кем-либо еще.
3. Сохраняются изменения, внесенные последними — Подход, позволяющий обновлять данные, не определяя, произошли ли изменения данных с момента последнего считывания их приложением. Эта стратегия (или отсутствие формальной стратегии) применяется обычно при таком разделении данных, которое не позволяет доступ нескольким пользователям к одним и тем же данным. Она также применяется при обработке кратковременных потоков данных.  

В статье описывается, как платформа службы хранилища Azure облегчает разработки, предоставляя первоклассную поддержку всем трем стратегиям параллелизма.  

## <a name="azure-storage--simplifies-cloud-development"></a>Служба хранилища Azure — Упрощает облачные разработки
Служба хранилища Azure поддерживает все три стратегии, хотя отличается возможностью полной поддержки оптимистического и пессимистичного параллелизма. Она разработана для поддержания модели строгой согласованности, при которой при вводе или обновлении данных в службе хранилища пользователям, получившим дальнейший доступ к данным, будут гарантированно показаны последние введенные данные. Платформы службы хранилища, иногда применяющие модель согласованности, имеют небольшой интервал между записью данных одним пользователем и возможностью другим пользователем видеть обновленные данные. Это усложняет разработку клиентских приложений с целью предотвращения воздействия несоответствий на конечных пользователей.  

Кроме выбора соответствующей стратегии параллелизма разработчики должны иметь представление о том, как платформа службы хранилища изолирует изменения, в частности изменения одних и тех же объектов между транзакциями. Служба хранилища Azure использует изоляцию моментального снимка, чтобы позволить одновременное выполнение операций чтения и записи в рамках одного раздела. В отличие от других уровней изоляции, изоляция моментального снимка гарантирует видимость операциям чтения только согласованных моментальных снимков данных даже при их обновлении, возвращая, по сути, в процессе обновления последние фиксированные значения.  

## <a name="managing-concurrency-in-blob-storage"></a>Управление параллелизмом в хранилище BLOB-объектов
Вы можете выбрать модель оптимистического или пессимистичного параллелизма для управления доступа к BLOB-объектам и контейнерам службы BLOB-объектов. Если вы не указываете стратегию, то применяется стратегия по умолчанию "Сохраняются изменения, внесенные последними".  

### <a name="optimistic-concurrency-for-blobs-and-containers"></a>Оптимистичный параллелизм для BLOB-объектов и контейнеров
Служба хранилища присваивает идентификатор каждому сохраненному объекту. Идентификатор обновляется при каждом обновлении объекта. Идентификатор возвращается клиенту в качестве ответа HTTP GET с помощью заголовка ETag (тег объекта), определенного в протоколе HTTP. Пользователь, вносящий изменение в объект, может отправить оригинальный ETag с условным заголовком, чтобы удостовериться в том, что обновление произойдет только при удовлетворении определенного условия: в этом случае условие — заголовок "If-Match", который требует, чтобы значение ETag, определенное в запросе на обновление, соответствовало сохраненному в службе хранилища.  

Для этой команды используется следующая структура:  

1. Извлеките BLOB-объект из службы хранилища, ответ содержит значение заголовка HTTP ETag, указывающее текущую версию объекта в службе хранилища.
2. При обновлении BLOB-объекта включите полученное после выполнения шага 1 значение ETag в условный заголовок **If-Match** запроса, отправляемого вами в службу.
3. Служба сравнивает значение ETag запроса с текущим значением ETag BLOB-объекта.
4. Если текущее значение ETag BLOB-объекта отличается от ETag в условном заголовке запроса **If-Match**, служба возвращает клиенту ошибку 412. Это указывает клиенту на то, что после извлечения клиентом BLOB-объекта он был обновлен другим процессом.
5. Если текущее значение ETag BLOB-объекта совпадает со значением ETag в условном заголовке запроса **If-Match** , служба выполняет запрошенную операцию и обновляет текущее значение ETag BLOB-объекта, указывая тем самым на создание новой версии.  

Следующий фрагмент C#-кода (с использованием клиентской библиотеки хранилища версии 4.2.0) является простым примером того, как построить **If-Match AccessCondition** , основанное на значении ETag, доступном из свойств извлеченного или вставленного до этого BLOB-объекта. Затем он использует объект **AccessCondition** при обновлении большого двоичного объекта: объект **AccessCondition** добавляет заголовок **If-Match** к запросу. Если произошло обновление BLOB-объекта другим процессом, служба возвращает сообщение о состоянии HTTP 412 (Необходимое условие не выполнено). Полный пример можно скачать здесь: [Управление параллелизмом с помощью службы хранилища Azure](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).  

```csharp
// Retrieve the ETag from the newly created blob
// Etag is already populated as UploadText should cause a PUT Blob call
// to storage blob service which returns the etag in response.
string orignalETag = blockBlob.Properties.ETag;

// This code simulates an update by a third party.
string helloText = "Blob updated by a third party.";

// No etag, provided so orignal blob is overwritten (thus generating a new etag)
blockBlob.UploadText(helloText);
Console.WriteLine("Blob updated. Updated ETag = {0}",
blockBlob.Properties.ETag);

// Now try to update the blob using the orignal ETag provided when the blob was created
try
{
    Console.WriteLine("Trying to update blob using orignal etag to generate if-match access condition");
    blockBlob.UploadText(helloText,accessCondition:
    AccessCondition.GenerateIfMatchCondition(orignalETag));
}
catch (StorageException ex)
{
    if (ex.RequestInformation.HttpStatusCode == (int)HttpStatusCode.PreconditionFailed)
    {
        Console.WriteLine("Precondition failure as expected. Blob's orignal etag no longer matches");
        // TODO: client can decide on how it wants to handle the 3rd party updated content.
    }
    else
        throw;
}  
```

Служба хранилища включает также поддержку дополнительных условных заголовков, таких как **If-Modified-Since**, **If-Unmodified-Since** и **If-None-Match**, а также их комбинаций. Дополнительные сведения см. в статье [Указание условных заголовков для операций службы BLOB-объектов](http://msdn.microsoft.com/library/azure/dd179371.aspx) в MSDN.  

В таблице содержится свод операций с контейнером, принимающих в запросе такие условные заголовки, как **If-Match** и возвращающих в ответе значение ETag.  

| Операция | Возврат значения ETag для контейнера | Принятие дополнительных заголовков |
|:--- |:--- |:--- |
| Create Container (Создание контейнера) |Yes |Нет  |
| Get Container Properties (Получение свойств контейнера) |Yes |Нет  |
| Get Container Metadata (Получение метаданных контейнера) |Yes |Нет  |
| Определение метаданных контейнера |Yes |Yes |
| Get Container ACL (Получение списка управления доступом для контейнера) |Yes |Нет  |
| Set Container ACL (Задание списка управления доступом для контейнера) |Yes |Да (*) |
| Delete Container (Удаление контейнера) |Нет  |Yes |
| Lease Container (Аренда контейнера) |Yes |Yes |
| List Blobs (Отображение списка BLOB-объектов) |Нет  |Нет  |

(*) Разрешения, определенные SetContainerACL, кэшируются, а обновление разрешений занимает 30 секунд, в течение которых нельзя гарантировать согласованность обновлений.  

В таблице содержится свод операций с BLOB-объектами, принимающих в запросе такие условные заголовки, как **If-Match** и возвращающих в ответе значение ETag.

| Операция | Returns ETag value (Возврат значения ETag) | Принятие дополнительных заголовков |
|:--- |:--- |:--- |
| Put BLOB (Вставка BLOB-объекта) |Yes |Yes |
| Get BLOB (Получение BLOB-объекта) |Yes |Yes |
| Get BLOB Properties (Получение свойств BLOB-объекта) |Yes |Yes |
| Set BLOB Properties (Задание свойств службы BLOB-объекта) |Yes |Yes |
| Get BLOB Metadata (Получение метаданных BLOB-объекта) |Yes |Yes |
| Set BLOB Metadata (Задание метаданных BLOB-объекта) |Yes |Yes |
| Lease Blob (Аренда BLOB-объекта) (*) |Yes |Yes |
| Создание моментального снимка большого двоичного объекта |Yes |Yes |
| Копирование BLOB-объекта |Yes |Да (для исходного и целевого большого двоичного объекта) |
| Прерывание копирования большого двоичного объекта |Нет  |Нет  |
| Delete BLOB (Удаление BLOB-объекта) |Нет  |Yes |
| Put Block (Вставка блокировки) |Нет  |Нет  |
| Put Block List (Вставка списка блокировки) |Yes |Yes |
| Get Block List (Получение списка блокировки) |Yes |Нет  |
| Put Page (Вставка страницы) |Yes |Yes |
| Get Page Ranges (Получение диапазона страницы) |Yes |Yes |

(*) Аренда BLOB-объекта не заменяет ETag на BLOB-объект.  

### <a name="pessimistic-concurrency-for-blobs"></a>Пессимистичный параллелизм для BLOB-объектов
Для блокировки BLOB-объекта в целях монопольного использования вы можете получить его в [аренду](http://msdn.microsoft.com/library/azure/ee691972.aspx) . При получении его в аренду вы можете определить, на какой срок она вам нужна: 15–60 секунд или на неограниченный период, что равносильно монопольной блокировке. Вы можете обновить ограниченную аренду, продлив ее, а также освободиться от нее, если она вам более не нужна. Служба BLOB-объектов автоматически освобождается от ограниченной аренды после завершения ее срока.  

Аренда разрешает поддержку различных стратегий синхронизации, включая монопольную запись / общее чтение, монопольная запись / монопольное чтение и общую запись / монопольное чтение. При наличии аренды служба хранилища включает монопольное чтение (операции put, set и delete), однако, чтобы сделать возможным монопольное чтение, разработчику необходимо обеспечить использование всеми клиентскими приложениями идентификатора аренды, а также наличие действительного идентификатора аренды одновременно только у одного клиента. Операции чтения, не имеющие идентификатора аренды, окажутся в общем чтении.  

Следующий фрагмент C#-кода является примером получения на 30 секунд монопольной аренды на BLOB-объект, обновления содержимого BLOB-объекта и освобождения от аренды. Если на большом двоичном объекте уже есть действительная аренда, а вы пытаетесь получить новую аренду, то служба BLOB-объектов возвращает статус "HTTP (409) Conflict" (HTTP (409) — конфликт). Следующий фрагмент кода использует объект **AccessCondition**, чтобы инкапсулировать данные аренды, когда он выполняет запрос на обновление большого двоичного объекта в службе хранилища.  Полный пример можно скачать здесь: [Управление параллелизмом с помощью службы хранилища Azure](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).

```csharp
// Acquire lease for 15 seconds
string lease = blockBlob.AcquireLease(TimeSpan.FromSeconds(15), null);
Console.WriteLine("Blob lease acquired. Lease = {0}", lease);

// Update blob using lease. This operation will succeed
const string helloText = "Blob updated";
var accessCondition = AccessCondition.GenerateLeaseCondition(lease);
blockBlob.UploadText(helloText, accessCondition: accessCondition);
Console.WriteLine("Blob updated using an exclusive lease");

//Simulate third party update to blob without lease
try
{
    // Below operation will fail as no valid lease provided
    Console.WriteLine("Trying to update blob without valid lease");
    blockBlob.UploadText("Update without lease, will fail");
}
catch (StorageException ex)
{
    if (ex.RequestInformation.HttpStatusCode == (int)HttpStatusCode.PreconditionFailed)
        Console.WriteLine("Precondition failure as expected. Blob's lease does not match");
    else
        throw;
}  
```

Если вы пытаетесь совершить операцию записи на арендованном BLOB-объекте, не идентифицировав аренду, неудавшийся запрос возвращается с ошибкой 412. Если срок аренды истекает до вызова метода **UploadText**, но вы все еще проходите идентификацию аренды, запрос также завершается неудачей с ошибкой **412**. Дополнительные сведения об управлении сроком аренды и идентификаторами аренды см. в статье, посвященной операции [Lease Blob](http://msdn.microsoft.com/library/azure/ee691972.aspx), в документации REST.  

Для управления пессимистичным параллелизмом аренда может использоваться в следующих операциях с BLOB-объектами:  

* Put BLOB (Вставка BLOB-объекта)
* Get BLOB (Получение BLOB-объекта)
* Get BLOB Properties (Получение свойств BLOB-объекта)
* Set BLOB Properties (Задание свойств службы BLOB-объекта)
* Get BLOB Metadata (Получение метаданных BLOB-объекта)
* Set BLOB Metadata (Задание метаданных BLOB-объекта)
* Delete BLOB (Удаление BLOB-объекта)
* Put Block (Вставка блокировки)
* Put Block List (Вставка списка блокировки)
* Get Block List (Получение списка блокировки)
* Put Page (Вставка страницы)
* Get Page Ranges (Получение диапазона страницы)
* Snapshot Blob (Моментальные снимки BLOB-объектов) — идентификатор аренды не обязателен, если есть аренда
* Copy Blob (Копирование BLOB-объекта) — необходим идентификатор аренды, если есть аренда на целевой BLOB-объект
* Abort Copy Blob (Прерывание копирования BLOB-объекта) — необходим идентификатор аренды, если есть неограниченная аренда на целевой BLOB-объект
* Lease Blob  

### <a name="pessimistic-concurrency-for-containers"></a>Пессимистичный параллелизм для контейнеров
Аренда на контейнеры разрешает поддержку тех же стратегий синхронизации, что и на BLOB-объектах (монопольная запись / общее чтение, монопольная запись / монопольное чтение и общая запись / монопольное чтение), однако, в отличие от BLOB-объектов, служба хранилища применяет монополию только к операциям удаления (delete operations). Для удаления контейнера с активной арендой клиент наряду с запросом на удаление должен ввести активный идентификатор аренды. Остальные операции по контейнерам выполняются без введения идентификатора аренды, являясь общими операциями. Если требуется монополия на операции обновления (put или set) или чтения, разработчик должен обеспечить всех клиентов возможностью использования идентификатора аренды, а также наличие действительного идентификатора аренды одновременно только у одного клиента.  

Для управления пессимистичным параллелизмом аренда может использоваться в следующих операциях с контейнерами:  

* Delete Container (Удаление контейнера)
* Get Container Properties (Получение свойств контейнера)
* Get Container Metadata (Получение метаданных контейнера)
* Set Container Metadata (Определение метаданных контейнера)
* Get Container ACL (Получение списка управления доступом для контейнера)
* Set Container ACL (Задание списка управления доступом для контейнера)
* Lease Container (Аренда контейнера)  

Дополнительные сведения можно найти в разделе   

* [Указание условных заголовков для операций службы BLOB-объектов](http://msdn.microsoft.com/library/azure/dd179371.aspx)
* [Аренда контейнера](http://msdn.microsoft.com/library/azure/jj159103.aspx)
* [Аренда большого двоичного объекта ](http://msdn.microsoft.com/library/azure/ee691972.aspx)

## <a name="managing-concurrency-in-the-table-service"></a>Управление параллелизмом в службе таблиц
Когда вы работаете с сущностями, служба таблиц использует по умолчанию проверку оптимистичного параллелизма в отличие от службы BLOB-объектов, где вы должны монопольно выбирать проверку оптимистичного параллелизма. Другое отличие служб таблиц и BLOB-объектов заключается в том, что вы можете управлять параллельным поведением только сущностей, в то время как в службе BLOB-объектов можно управлять параллелизмом контейнеров и BLOB-объектов.  

Чтобы использовать оптимистичный параллелизм и проверить, модифицировал ли какой-либо процесс сущность с момента его извлечения из службы табличного хранилища, вы можете использовать значение ETag, которое вы получите при возвращении службой таблиц сущности. Для этой команды используется следующая структура:  

1. Извлеките сущность из службы табличного хранилища. Ответ включает значение ETag, определяющее текущий идентификатор, ассоциирующийся с этой сущностью в службе хранилища.
2. При обновлении сущности включите полученное после выполнения шага 1 значение ETag в обязательный заголовок **If-Match** запроса, отправляемого вами в службу.
3. Служба сравнивает значение ETag запроса с текущим значением ETag сущности.
4. Если текущее значение ETag сущности отличается от ETag в обязательном заголовке запроса **If-Match**, служба возвращает клиенту ошибку 412. Это указывает клиенту на то, что после извлечения клиентом сущности он был обновлен другим процессом.
5. Если текущее значение сущности совпадает со значением ETag в обязательном заголовке запроса **If-Match** или заголовок **If-Match** содержит подстановочный знак (*), служба выполняет запрошенную операцию и обновляет текущее значение ETag сущности, указывая тем самым на создание версии.  

Обратите внимание, что в отличие от службы BLOB-объектов служба таблиц требует от клиента включения заголовка **If-Match** в обновленный запрос. Однако можно принудительно применить безусловное обновление (стратегия "Сохраняются изменения, внесенные последними") и избежать проверки параллелизма, если клиент устанавливает в заголовке **If-Match** подстановочный знак (*), когда делает запрос.  

Следующий фрагмент C#-кода показывает пользователю сущность, предварительно созданную или извлеченную, с обновленным электронным адресом. Начальная операция по вводу или извлечению сохраняет значение ETag в объекте пользователя, а так как образец использует тот же экземпляр при операции замены, он автоматически отправляет значение ETag назад в службу таблиц, вызывая проверку на нарушение параллелизма. Если произошло обновление сущности в службе хранилища другим процессом, служба возвращает сообщение о состоянии HTTP 412 (Необходимое условие не выполнено).  Полный пример можно скачать здесь: [Управление параллелизмом с помощью службы хранилища Azure](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).

```csharp
try
{
    customer.Email = "updatedEmail@contoso.org";
    TableOperation replaceCustomer = TableOperation.Replace(customer);
    customerTable.Execute(replaceCustomer);
    Console.WriteLine("Replace operation succeeded.");
}
catch (StorageException ex)
{
    if (ex.RequestInformation.HttpStatusCode == 412)
        Console.WriteLine("Optimistic concurrency violation – entity has changed since it was retrieved.");
    else
        throw;
}  
```

Для явного отключения проверки на параллелизм вам следует задать характеристику **ETag** объекта **employee** в виде "*", прежде чем выполнить операцию замены.  

```csharp
customer.ETag = "*";  
```

Таблица показывает, как операции сущности в таблице используют значения ETag:

| Операция | Returns ETag value (Возврат значения ETag) | Requires If-Match request header (Требует заголовок запроса If-Match) |
|:--- |:--- |:--- |
| Query Entities (Сущности запроса) |Yes |Нет  |
| Insert Entity (Вставка сущности ) |Yes |Нет  |
| Update Entity (Обновление сущности) |Yes |Yes |
| Merge Entity (Слияние сущностей) |Yes |Yes |
| Delete Entity (Удаление сущности) |Нет  |Yes |
| Insert or Replace Entity (Вставка или замена сущности) |Yes |Нет  |
| Insert or Merge Entity (Вставка или слияние сущностей) |Yes |Нет  |

Обратите внимание, что операции **Insert or Replace Entity** и **Insert or Merge Entity** *не* проверяют параллелизм, так как они не отправляют значение ETag в службу таблиц.  

В основном разработчики, использующие таблицы, при разработке масштабируемых приложений должны полагаться на оптимистичный параллелизм. При необходимости в пессимистической блокировке, разработчики при получении доступа к таблицам могут сделать следующее: назначить для каждой таблицы определенный BLOB-объект и попытаться арендовать BLOB-объект до операции на таблице. Этот подход требует, чтобы приложение обеспечило путям доступа ко всем данным возможность получить аренду до операций на таблице. Вам следует обратить внимание на то, что минимальный срок аренды составляет 15 секунд, что необходимо тщательно изучить для масштабируемости.  

Дополнительные сведения можно найти в разделе   

* [Операции с сущностями](http://msdn.microsoft.com/library/azure/dd179375.aspx)  

## <a name="managing-concurrency-in-the-queue-service"></a>Управление параллелизмом в службе очередей
Одним из сценариев, в котором параллелизм является проблемой, является служба очередей, в которой из очереди получают сообщения несколько клиентов. Когда сообщение извлекается из очереди, ответ включает в себя сообщение и значение подтверждения получения, необходимое для удаления очереди. Сообщение не удаляется из очереди автоматически, но после извлечения оно становится невидимым для других клиентов на интервал времени, установленный параметрами visibilitytimeout (время ожидания видимости). Предполагается, что клиент, извлекший сообщение, удалит его после обработки до времени, указанного элементом ответа TimeNextVisible и рассчитанного на основе значения параметра visibilitytimeout. Значение visibilitytimeout добавляется ко времени, за которое извлекается сообщение, для определения значения TimeNextVisible.  

Служба очередей не имеет поддержки ни оптимистического, ни пессимистичного параллелизма, поэтому клиент, обрабатывающий сообщение, извлеченное из очереди, должен обеспечить обработку сообщения идемпотентным образом. Стратегия "Сохраняются изменения, внесенные последними" используется для обновления операций, таких как SetQueueServiceProperties, SetQueueMetaData, SetQueueACL и UpdateMessage.  

Дополнительные сведения можно найти в разделе   

* [REST API службы очередей](http://msdn.microsoft.com/library/azure/dd179363.aspx)
* [Получение сообщений](http://msdn.microsoft.com/library/azure/dd179474.aspx)  

## <a name="managing-concurrency-in-the-file-service"></a>Управление параллелизмом в файловой службе
Доступ к файловой службе можно получить с помощью двух протоколов конечной точки — SMB и REST. Служба REST не поддерживает ни оптимистическую, ни пессимистическую блокировки, и все обновления происходят по стратегии "Сохраняются изменения, внесенные последними". Клиент SMB, монтирующий общий ресурс, может использовать механизм блокировки файловой системы для управления доступом к общим файлам, включая возможность пессимистической блокировки. При открытии файла клиентом SMB он определяет как доступ к файлам, так и режим общего доступа. Параметры доступа к файлам "Write" или "Read/Write" ("Для записи" или "Для чтения и записи"), а также режима совместного использования файлам "None" ("Ни один") приводят к блокировке файла клиентом SMB до закрытия файла. Если попытаться осуществить операцию REST на файле, заблокированном клиентом, SMB служба REST вернет код состояния 409 (конфликт) с кодом ошибки SharingViolation.  

При открытии клиентом SMB файла для удаления она отмечает файл как "ожидающий удаления" до тех пор, пока все остальные клиенты SMB, открывшие дескрипторы на файл, закроются. Пока файл отмечен как "ожидающий удаления", любая операция REST на этом файле вернется кодом состояния 409 (конфликт) и с кодом ошибки SMBDeletePending. Код состояния 404 (не найден) не возвращается, так как клиент SMB не может удалить флажок "ожидающий удаления" с файла до его закрытия. Иными словами, получение кода состояния 404 (не найден) возможно только после удаления файла. Заметьте, что пока файл находится в состоянии ожидания удаления SMB, он не будет включен в результаты операции "Список файлов". Обратите также внимание, что операции REST Delete File (Удалить файлы) и REST Delete Directory (Удалить каталог) выполняются атомарным образом и не ведут к состоянию ожидания удаления.  

Дополнительные сведения можно найти в разделе   

* [Управление блокировкой файлов](http://msdn.microsoft.com/library/azure/dn194265.aspx)  

## <a name="summary-and-next-steps"></a>Сводка и дальнейшие действия
Служба хранилища Microsoft Azure разработана для удовлетворения потребностей большинства сложных интерактивных приложений, при этом не принуждает разработчиков нарушать или пересматривать ключевые допущения в разработках, такие как параллелизм и согласованность данных, которые уже учтены.  

Полный образец приложения, упомянутый в блоге:  

* [Управление параллелизмом с помощью службы хранилища Azure: пример приложения](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114)  

Подробнее о службе хранения Azure:  

* [Домашняя страница службы хранилища Microsoft Azure](https://azure.microsoft.com/services/storage/)
* [Введение в хранилище Azure](storage-introduction.md)
* Приступая к работе с хранилищем: [большой двоичный объект](../blobs/storage-dotnet-how-to-use-blobs.md), [таблица](../../cosmos-db/table-storage-how-to-use-dotnet.md), [очереди](../storage-dotnet-how-to-use-queues.md) и [файлы](../storage-dotnet-how-to-use-files.md).
* Архитектура службы хранилища — [Azure Storage: A Highly Available Cloud Storage Service with Strong Consistency](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx) (Служба хранилища Azure: высокодоступная облачная служба хранилища со строгой согласованностью).

