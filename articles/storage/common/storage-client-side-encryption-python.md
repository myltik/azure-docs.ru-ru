---
title: Шифрование на стороне клиента с помощью Python для службы хранилища Microsoft Azure | Документация Майкрософт
description: Клиентская библиотека службы хранилища Azure для Python поддерживает шифрование на стороне клиента для обеспечения максимальной защиты ваших приложений службы хранилища Azure.
services: storage
documentationcenter: python
author: lakasa
manager: jahogg
editor: tysonn
ms.assetid: f9bf7981-9948-4f83-8931-b15679a09b8a
ms.service: storage
ms.workload: storage
ms.tgt_pltfrm: na
ms.devlang: python
ms.topic: article
ms.date: 05/11/2017
ms.author: lakasa
ms.openlocfilehash: c925b41d1654bd5c9b40438c4b6b9f402ec4bac2
ms.sourcegitcommit: 782d5955e1bec50a17d9366a8e2bf583559dca9e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/02/2018
ms.locfileid: "29742648"
---
# <a name="client-side-encryption-with-python-for-microsoft-azure-storage"></a>Шифрование на стороне клиента с помощью Python для службы хранилища Microsoft Azure
[!INCLUDE [storage-selector-client-side-encryption-include](../../../includes/storage-selector-client-side-encryption-include.md)]

## <a name="overview"></a>Обзор
[Клиентская библиотека службы хранилища Azure для Python](https://pypi.python.org/pypi/azure-storage) поддерживает шифрование данных в клиентских приложениях перед отправкой в службу хранилища Azure и их расшифровку во время скачивания клиентом.

> [!NOTE]
> Библиотека Python для службы хранилища Azure находится на этапе предварительной версии.
> 
> 

## <a name="encryption-and-decryption-via-the-envelope-technique"></a>Шифрование и расшифровка методом конвертов
Для шифрования и расшифровки используется конвертный метод.

### <a name="encryption-via-the-envelope-technique"></a>Шифрование конвертным методом
Шифрование конвертным методом выполняется следующим образом.

1. Клиентская библиотека хранилища Azure создает ключ шифрования содержимого (CEK), который является симметричным ключом для однократного использования.
2. Данные пользователя шифруются с помощью этого ключа CEK.
3. Ключ CEK, в свою очередь, шифруется с помощью ключа шифрования ключа KEK. KEK определяется идентификатором ключа и может быть парой асимметричных ключей или симметричным ключом, управляемым локально.
   Сама клиентская библиотека хранилища не имеет доступа к ключу KEK. Библиотека вызывает алгоритм шифрования ключа, предоставляемый KEK. Пользователи могут при необходимости использовать настраиваемые поставщики для шифрования и расшифровки ключа.
4. Зашифрованные данные затем передаются в службу хранилища Azure. Зашифрованный ключ вместе с дополнительными метаданными шифрования хранится как метаданные (в большом двоичном объекте) или вставляется в зашифрованные данные (сообщения в очереди и табличные сущности).

### <a name="decryption-via-the-envelope-technique"></a>Расшифровка конвертным методом
Расшифровка конвертным методом выполняется следующим образом.

1. Клиентская библиотека предполагает, что пользователь управляет ключом шифрования ключа (KEK) локально. Пользователь может не знать, какой именно ключ использовался для шифрования. Вместо этого достаточно настроить и использовать сопоставитель ключей, который будет распознавать разные идентификаторы ключей.
2. Клиентская библиотека скачивает зашифрованные данные вместе с данными шифрования, которые хранятся в службе.
3. Зашифрованный ключ шифрования содержимого CEK расшифровывается с помощью ключа шифрования ключа KEK. Клиентская библиотека не имеет доступа к ключу KEK. Она просто вызывает алгоритм расшифровки, предоставляемый настраиваемым поставщиком.
4. Затем ключ шифрования содержимого CEK используется для расшифровки зашифрованных пользовательских данных.

## <a name="encryption-mechanism"></a>Механизм шифрования
Клиентская библиотека хранилища использует алгоритм [AES](http://en.wikipedia.org/wiki/Advanced_Encryption_Standard) для шифрования данных пользователя. Говоря более конкретно, это режим [цепочки цифровых блоков или CBC](http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher-block_chaining_.28CBC.29) вместе с AES. Каждая служба работает по-разному, поэтому каждая служба рассматривается отдельно.

### <a name="blobs"></a>BLOB-объекты
Клиентская библиотека в настоящий момент полностью поддерживает только шифрование больших двоичных объектов. В частности, шифрование поддерживается при использовании методов **create**\*. Поддерживаются полное скачивание и скачивание диапазона, кроме того, доступно распараллеливание передачи и скачивания.

Во время шифрования клиентская библиотека создает случайный вектор инициализации IV размером 16 байт, случайный ключ шифрования содержимого CEK размером 32 байта и выполняет конвертное шифрование данных большого двоичного объекта, используя полученную информацию. Затем зашифрованный ключ CEK и дополнительные метаданные шифрования сохраняются в службе как метаданные большого двоичного объекта вместе с зашифрованным большим двоичным объектом.

> [!WARNING]
> Если вы изменяете или загружаете собственные метаданные для большого двоичного объекта, нужно убедиться, что данные сохранены. Если загрузить новые метаданные без этих метаданных, зашифрованный ключ CEK, ключ IV и другие метаданные будут утеряны, а без них получить содержимое большого двоичного объекта невозможно.
> 
> 

Скачивание зашифрованного большого двоичного объекта предполагает получение всего его содержимого с помощью удобных методов **get**\*. Зашифрованный ключ CEK расшифровывается и используется вместе с ключом IV (который в данном случае хранится как метаданные большого двоичного объекта) для передачи расшифрованных данных обратно пользователям.

Скачивание произвольного диапазона (с помощью методов **get**\* и передаваемых параметров диапазона) из зашифрованного большого двоичного объекта предполагает настройку диапазона на стороне пользователя, чтобы получить небольшой объем дополнительных данных, которые помогут расшифровать запрошенный диапазон.

Только блочные и страничные BLOB-объекты могут быть зашифрованы и расшифрованы с помощью этой схемы. В настоящее время не поддерживается шифрование добавочных BLOB-объектов.

### <a name="queues"></a>Очереди
Поскольку очередь сообщений может иметь любой формат, клиентская библиотека определяет нестандартный формат, который включает вектор инициализации IV и зашифрованный ключ шифрования содержимого CEK в текст сообщения.

Во время шифрования клиентская библиотека создает случайный ключ IV размером 16 байт, случайный ключ CEK размером 32 байта и выполняет конвертное шифрование текста сообщения очереди, используя полученную информацию. Зашифрованный ключ CEK и дополнительные метаданные шифрования добавляются в зашифрованное сообщение очереди. Это измененное сообщение (показано ниже) сохраняется в службе.

```
<MessageText>{"EncryptedMessageContents":"6kOu8Rq1C3+M1QO4alKLmWthWXSmHV3mEfxBAgP9QGTU++MKn2uPq3t2UjF1DO6w","EncryptionData":{…}}</MessageText>
```

Во время расшифровки зашифрованный ключ извлекается из сообщения очереди и расшифровывается. Ключ IV также извлекается из сообщения очереди и используется вместе с расшифрованным ключом для расшифровки данных сообщения очереди. Обратите внимание, что размер метаданных шифрования очень мал (не более 500 байт), поэтому, хотя этот их размер учитывается при подсчете максимального размера в 64 КБ для сообщения очереди, этим размером данных можно пренебречь.

### <a name="tables"></a>Таблицы
Клиентская библиотека поддерживает шифрование свойств сущности для операций вставки и замены.

> [!NOTE]
> Слияние в настоящее время не поддерживается. Поскольку подмножество свойств могло уже быть зашифровано с помощью другого ключа, простое слияние новых свойств и обновление метаданных приведет к потере данных. Для слияния требуется либо сначала прочитать данные существующей сущности в службе, либо использовать новый ключ для каждого свойства, однако оба способа не подходят из-за низкой эффективности.
> 
> 

Шифрование табличных данных выполняется следующим образом.

1. Пользователи указывают свойства, которые следует зашифровать.
2. Клиентская библиотека создает случайный вектор инициализации IV размером 16 байт и произвольный ключ шифрования содержимого CEK размером 32 байта для каждой сущности и выполняет конвертное шифрование для отдельных свойств, которые следует зашифровать путем создания нового ключа IV для каждого свойства. Зашифрованное свойство хранится в виде двоичных данных.
3. Затем зашифрованный ключ CEK и дополнительные метаданные шифрования сохраняются в виде двух дополнительных зарезервированных свойств. Первое зарезервированное свойство (\_ClientEncryptionMetadata1) — это строковое свойство, которое содержит информацию о ключе IV, версию и зашифрованный ключ. Второе зарезервированное свойство (\_ClientEncryptionMetadata2) — это двоичное свойство, которое содержит информацию о зашифрованных свойствах. Сведения в этом втором свойстве (\_ClientEncryptionMetadata2) сами по себе зашифрованы.
4. Из-за этих двух дополнительных зарезервированных свойств, необходимых для шифрования, пользователи могут иметь только 250 пользовательских свойств вместо 252. Общий размер сущности должен быть меньше 1 МБ.
   
   Обратите внимание, что зашифрованы могут быть только строковые свойства. Если необходимо зашифровать другие типы свойств, их необходимо преобразовать в строки. Зашифрованные строки хранятся в службе в виде двоичных свойств. Они преобразовываются обратно в строки (необработанные строки, не EntityProperties типа EdmType.STRING) после расшифровки.
   
   Что касается таблиц, то в дополнение к политике шифрования пользователи должны указать свойства, которые необходимо зашифровать. Это можно сделать, либо сохранив эти свойства в объектах TableEntity, задав для них тип EdmType.STRING, а для поля encrypt — значение true, либо задав encryption_resolver_function для объекта tableservice. Сопоставитель шифрования — это функция, которая получает ключ секции, ключ строки и имя свойства, а затем возвращает логическое значение, которое указывает, следует ли это свойство шифровать. Во время шифрования клиентская библиотека использует эти сведения, чтобы решить, следует ли шифровать свойство перед отправкой. Делегат также обеспечивает возможность логики в отношении того, как шифруются свойства. (Например, если значение равно X, то шифровать свойство А; в противном случае шифровать свойства А и В.) Обратите внимание, что нет необходимости предоставлять эти сведения при чтении или выполнении запросов к сущностям.

### <a name="batch-operations"></a>Пакетные операции
Одна политика шифрования применяется ко всем строкам в пакете. Клиентская библиотека создает новый случайный ключ IV и случайный ключ CEK для каждой строки в пакете. Пользователи могут также выбрать шифрование других свойств для каждой операции в пакете, определив это поведение в сопоставителе шифрования.
Если пакет создан в качестве диспетчера контекста посредством метода batch() объекта tableservice, то политика шифрования tableservice будет автоматически применена к этому пакету. Если пакет был явно создан путем вызова конструктора, то политика шифрования должна быть передана как параметр и должна оставаться без изменений в течение времени существования пакета.
Обратите внимание, что сущности шифруются, когда вставляются в пакет, с помощью политики шифрования пакета (сущности НЕ шифруются с помощью политики шифрования tableservice во время фиксации пакета).

### <a name="queries"></a>Запросы
> [!NOTE]
> Так как сущности зашифрованы, нельзя запускать запросы с фильтрацией для них.  Такая попытка даст неверные результаты, потому что в службе зашифрованные данные будут сравниваться с незашифрованными.
> 
>
Чтобы выполнять операции запроса, следует указать сопоставитель ключа, который способен распознавать все ключи в результирующем наборе. Если сущность в результате запроса не может быть разрешена для поставщика, клиентская библиотека выдаст ошибку. Для запроса, который обращен к серверу, клиентская библиотека добавляет по умолчанию специальные свойства метаданных шифрования (\_ClientEncryptionMetadata1 и \_ClientEncryptionMetadata2) к выбранным столбцам.

> [!IMPORTANT]
> Учтите следующие важные моменты при использовании шифрования на стороне клиента.
> 
> * При чтении или записи в зашифрованном большом двоичном объекте используйте команды загрузки полного большого двоичного объекта и команды диапазонной либо полной выгрузки. Избегайте написания зашифрованного большого двоичного объекта с помощью операций протокола, таких как Put Block, Put Block List, Write Pages или Clear Pages, иначе это может привести к повреждению зашифрованного большого двоичного объекта, что сделает его нечитабельным.
> * Для таблиц существуют аналогичные ограничения. Будьте внимательны и не обновляйте зашифрованные свойства без обновления метаданных шифрования.
> * Если задать метаданные в зашифрованном большом двоичном объекте, могут быть перезаписаны метаданные, относящиеся к шифрованию и необходимые для расшифровки, поскольку настройку метаданных добавить нельзя. Это также касается моментальных снимков. Не указывайте метаданные во время создания моментального снимка зашифрованного большого двоичного объекта. Если необходимо задать метаданные, следует сначала вызвать метод **get_blob_metadata** для получения текущих метаданных шифрования и не выполнять параллельные операции записи во время установки метаданных.
> * Включите флаг **require_encryption** в объекте службы для пользователей, которые должны работать только с зашифрованными данными. См. дополнительные сведения ниже.
> 
> 

Клиентская библиотека хранилища ожидает предоставленный KEK и сопоставитель ключей, чтобы реализовать приведенный ниже интерфейс. [хранилище ключей Azure](https://azure.microsoft.com/services/key-vault/) ожидается и будет интегрирована в эту библиотеку, когда будет готова.

## <a name="client-api--interface"></a>API-интерфейс клиента / интерфейс
После создания объекта службы хранилища (т. е. blockblobservice) пользователь может присвоить значения полям, которые составляют политику шифрования: key_encryption_key, key_resolver_function и require_encryption. Пользователи могут предоставлять только ключ шифрования ключей, только сопоставитель или и то, и другое. key_encryption_key — это базовый тип ключа, который идентифицируется с помощью идентификатора ключа и который обеспечивает логику для шифрования и расшифровки. key_resolver_function используется для сопоставления ключа во время расшифровки. При этом возвращается допустимый KEK по заданному идентификатору ключа. В результате пользователи могут выбирать между несколькими ключами, которые хранятся в разных местах.

KEK должен реализовывать следующие методы для успешного шифрования данных:

* wrap_key(cek): шифрует заданный CEK (байты) с помощью алгоритма по выбору пользователя. Возвращает зашифрованный ключ.
* get_key_wrap_algorithm(): возвращает алгоритм, используемый для шифрования ключей.
* get_kid(): возвращает идентификатор ключа строки для данного KEK.
  KEK должен реализовывать следующие методы для успешной расшифровки данных:
* unwrap_key (cek, algorithm): возвращает указанный CEK в расшифрованном виде с помощью алгоритма, соответствующего строке.
* get_kid(): возвращает идентификатор ключа строки для данного KEK.

Сопоставитель ключей по крайней мере должен реализовывать метод, который по заданному идентификатору ключа возвращает соответствующий KEK, реализующий приведенный выше интерфейс. Только этот метод может быть назначен свойству key_resolver_function объекта службы.

* Для шифрования ключ используется всегда, при этом отсутствие ключа приведет к возникновению ошибки.
* Для расшифровки:
  
  * Сопоставитель ключа вызывается, если он нужен для получения ключа. Если сопоставитель указан, но он не имеет данных, сопоставимых с идентификатором ключа, возникает ошибка.
  * Если сопоставитель не указан, но указан ключ, ключ используется, если его идентификатор соответствует требуемому идентификатору ключа. Если идентификатор не совпадает, выдается ошибка.
    
    В статье с примерами шифрования (azure.storage.samples <fix URL>) показан подробный комплексный сценарий для больших двоичных объектов, очередей и таблиц.
      Примеры реализации KEK и сопоставителя ключей предоставлены среди примеров файлов. Это KeyWrapper и KeyResolver, соответственно.

### <a name="requireencryption-mode"></a>Режим RequireEncryption
При необходимости можно включить режим работы, где все передачи и загрузки должны быть зашифрованы. В этом режиме все попытки клиента передать данные без политики шифрования или загрузить данные, которые не зашифрованы в службе, закончатся ошибкой. Флаг **Require_encryption** в объекте службы управляет этим поведением.

### <a name="blob-service-encryption"></a>Шифрование службы BLOB-объектов
Задайте поля политики шифрования объекта blockblobservice. Все остальные задачи решаются клиентской библиотекой.

```python
# Create the KEK used for encryption.
# KeyWrapper is the provided sample implementation, but the user may use their own object as long as it implements the interface above.
kek = KeyWrapper('local:key1') # Key identifier

# Create the key resolver used for decryption.
# KeyResolver is the provided sample implementation, but the user may use whatever implementation they choose so long as the function set on the service object behaves appropriately.
key_resolver = KeyResolver()
key_resolver.put_key(kek)

# Set the KEK and key resolver on the service object.
my_block_blob_service.key_encryption_key = kek
my_block_blob_service.key_resolver_funcion = key_resolver.resolve_key

# Upload the encrypted contents to the blob.
my_block_blob_service.create_blob_from_stream(container_name, blob_name, stream)

# Download and decrypt the encrypted contents from the blob.
blob = my_block_blob_service.get_blob_to_bytes(container_name, blob_name)
```

### <a name="queue-service-encryption"></a>Шифрование службы очередей
Задайте поля политики шифрования объекта queueservice. Все остальные задачи решаются клиентской библиотекой.

```python
# Create the KEK used for encryption.
# KeyWrapper is the provided sample implementation, but the user may use their own object as long as it implements the interface above.
kek = KeyWrapper('local:key1') # Key identifier

# Create the key resolver used for decryption.
# KeyResolver is the provided sample implementation, but the user may use whatever implementation they choose so long as the function set on the service object behaves appropriately.
key_resolver = KeyResolver()
key_resolver.put_key(kek)

# Set the KEK and key resolver on the service object.
my_queue_service.key_encryption_key = kek
my_queue_service.key_resolver_funcion = key_resolver.resolve_key

# Add message
my_queue_service.put_message(queue_name, content)

# Retrieve message
retrieved_message_list = my_queue_service.get_messages(queue_name)
```

### <a name="table-service-encryption"></a>Шифрование службы таблиц
Помимо создания политики шифрования и настройки параметров запроса необходимо указать **encryption_resolver_function** для **tableservice** или задать атрибут encrypt для EntityProperty.

### <a name="using-the-resolver"></a>Использование сопоставителя

```python
# Create the KEK used for encryption.
# KeyWrapper is the provided sample implementation, but the user may use their own object as long as it implements the interface above.
kek = KeyWrapper('local:key1') # Key identifier

# Create the key resolver used for decryption.
# KeyResolver is the provided sample implementation, but the user may use whatever implementation they choose so long as the function set on the service object behaves appropriately.
key_resolver = KeyResolver()
key_resolver.put_key(kek)

# Define the encryption resolver_function.
def my_encryption_resolver(pk, rk, property_name):
    if property_name == 'foo':
        return True
    return False

# Set the KEK and key resolver on the service object.
my_table_service.key_encryption_key = kek
my_table_service.key_resolver_funcion = key_resolver.resolve_key
my_table_service.encryption_resolver_function = my_encryption_resolver

# Insert Entity
my_table_service.insert_entity(table_name, entity)

# Retrieve Entity
# Note: No need to specify an encryption resolver for retrieve, but it is harmless to leave the property set.
my_table_service.get_entity(table_name, entity['PartitionKey'], entity['RowKey'])
```

### <a name="using-attributes"></a>Использование атрибутов
Как упоминалось выше, свойство можно пометить для шифрования, сохранив его в объекте EntityProperty и задав поле encrypt.

```python
encrypted_property_1 = EntityProperty(EdmType.STRING, value, encrypt=True)
```

## <a name="encryption-and-performance"></a>Шифрование и производительность
Обратите внимание, что шифрование результатов анализа данных хранилища отрицательно влияет на производительность. Ключ содержимого и ключ IV необходимо создать, само содержимое — зашифровать, а дополнительные метаданные — отформатировать и передать. Эти издержки зависят от объема шифруемых данных. Мы рекомендуем клиентам всегда тестировать свои приложения для повышения производительности во время разработки.

## <a name="next-steps"></a>Дополнительная информация
* Скачайте [клиентскую библиотеку службы хранилища Azure для пакета PyPi Java](https://pypi.python.org/pypi/azure-storage)
* Скачайте [клиентскую библиотеку службы хранилища Azure для исходного кода Python с портала GitHub](https://github.com/Azure/azure-storage-python)
