---
title: Проектирование высокодоступных приложений с использованием геоизбыточного хранилища с доступом на чтение Azure (RA-GRS) | Документация Майкрософт
description: Как использовать хранилище RA-GRS Azure для разработки высокодоступного приложения, достаточно гибкого для обработки сбоев.
services: storage
documentationcenter: .net
author: tamram
manager: timlt
editor: tysonn
ms.assetid: 8f040b0f-8926-4831-ac07-79f646f31926
ms.service: storage
ms.workload: storage
ms.tgt_pltfrm: na
ms.devlang: dotnet
ms.topic: article
ms.date: 03/21/2018
ms.author: tamram
ms.openlocfilehash: f7f3f2d99e5582a1bcb672cc176258dfff9c3217
ms.sourcegitcommit: 20d103fb8658b29b48115782fe01f76239b240aa
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/03/2018
ms.locfileid: "30322936"
---
# <a name="designing-highly-available-applications-using-ra-grs"></a>Проектирование высокодоступных приложений с использованием RA-GRS

Характерной чертой облачных инфраструктур, таких как служба хранилища Azure, является то, что они предоставляют высокодоступную платформу для размещения приложений. Разработчикам облачных приложений необходимо внимательно обдумать, как эффективно использовать эту платформу, чтобы обеспечить высокий уровень доступности приложений пользователям. В этой статье объясняется, как разработчики могут использовать геоизбыточное хранилище с доступом на чтение (RA-GRS), чтобы обеспечить высокий уровень доступности приложений в службе хранилища Azure.

[!INCLUDE [storage-common-redundancy-options](../../../includes/storage-common-redundancy-options.md)]

В этой статье мы рассмотрим GRS и RA-GRS. При использовании GRS три копии ваших данных хранятся в основном регионе, выбранном при настройке учетной записи хранения. Три дополнительные копии сохраняются асинхронно в дополнительном регионе, заданном Azure. Хранилище RA-GRS похоже на GRS, за исключением того, что у вас есть доступ на чтение к дополнительной копии. Дополнительные сведения о различных вариантах обеспечения избыточности в службе хранилища Azure см. в статье [Репликация службы хранилища Azure](https://docs.microsoft.com/azure/storage/storage-redundancy). В статье о репликации также показано связывание основных и дополнительных регионов.

Эта статья содержит фрагменты кода и ссылку на полный пример в конце, который можно скачать и запустить.

> [!NOTE]
> Служба хранилища Azure теперь поддерживает хранилище, избыточное в пределах зоны (ZRS), для создания высокодоступных приложений. ZRS предлагает простое решение для потребностей в избыточности многих приложений. ZRS предоставляет защиту от сбоев оборудования или от катастрофических сбоев в одном центре обработки данных. Дополнительные сведения см. в статье [Хранилище, избыточное в пределах зоны (ZRS). Высокодоступные приложения для службы хранилища Azure](storage-redundancy-zrs.md).

## <a name="key-features-of-ra-grs"></a>Ключевые возможности RA-GRS

При разработке приложения для RA-GRS учитывайте следующие основные моменты.

* Служба хранилища Azure сохраняет в дополнительном регионе доступную только для чтения копию данных, хранящихся в основном регионе. Как отмечалось выше, расположение этого дополнительного региона определяет служба хранилища.

* Доступная только для чтения копия [согласована в конечном счете](https://en.wikipedia.org/wiki/Eventual_consistency) с данными в основной области.

* Для больших двоичных объектов, таблиц и очередей можно отправить запрос в дополнительный регион, чтобы получить значение *Last Sync Time*. Оно указывает, когда произошла последняя репликация из основного региона в дополнительный. (Это не поддерживается для файлов Azure, которые в настоящее время не обеспечивают избыточности RA-GRS.)

* Вы можете использовать клиентскую библиотеку службы хранилища для взаимодействия с данными в основном или дополнительном регионе. Можно также автоматически перенаправлять запросы на чтение в дополнительный регион, если истекло время ожидания запроса на чтение в основном регионе.

* В случае серьезной проблемы, влияющей на доступность данных в основном регионе, команда Azure может активировать географическую отработку отказа. При этом записи DNS, указывающие на основной регион, будут изменены, чтобы указывать на дополнительный регион.

* В случае географической отработки отказа Azure выберет новое дополнительное расположение и будет реплицировать данные в него, после чего укажет его в дополнительных записях DNS. Вторичная конечная точка будет недоступна до завершения репликации учетной записи хранения. Дополнительные сведения см. в разделе [Что делать в случае простоя службы хранилища Azure](https://docs.microsoft.com/azure/storage/storage-disaster-recovery-guidance).

## <a name="application-design-considerations-when-using-ra-grs"></a>Рекомендации по проектированию приложений при использовании RA-GRS

Цель этой статьи — показать, как создать приложение, которое будет работать (хотя и с ограниченными возможностями) даже в случае серьезной аварии в основном центре обработки данных. Вы можете разработать приложение, которое будет устранять временные или длительные проблемы, считывая данные из дополнительного региона, при возникновении ошибки, из-за которой невозможно считать данные из основного региона. Когда основной регион снова станет доступным, приложение сможет считывать данные из него, как и прежде.

### <a name="using-eventually-consistent-data"></a>Использование данных, согласованных в конечном счете

Предлагаемое решение предполагает, что вполне допустимо вернуть вызывающему приложению потенциально устаревшие данные. Так как данные в дополнительном регионе являются согласованными в конечном счете, основной регион может стать недоступным до того, как завершится репликация обновления в дополнительный регион.

Например, предположим, что клиент успешно отправил обновление, но в основном регионе произошел сбой, прежде чем обновление распространилось на дополнительный регион. Если клиент запросит чтение этих данных, то вместо обновленных данных он получит устаревшие из дополнительного региона. На этапе разработки приложения вам нужно решить, допустимо ли это, и если допустимо, — определить способ уведомления клиента. 

Далее в этой статье объясняется, как проверить время последней синхронизации данных в дополнительном регионе, чтобы определить, актуальны ли они.

### <a name="handling-services-separately-or-all-together"></a>Отдельная или совместная обработка служб

Хотя это маловероятно, возможна ситуация, когда одна служба станет недоступна, в то время как другие службы будут по-прежнему работать в полнофункциональном режиме. Можно обрабатывать повторные попытки и режим только для чтения для каждой службы отдельно (большие двоичные объекты, очереди, таблицы) или универсально для всех служб хранилища.

Например, при использовании очередей и больших двоичных объектов в приложении можно добавить отдельный код для каждой из этих сущностей, обрабатывающий ошибки, допускающие повторение. Затем, если произойдет ошибка службы BLOB-объектов и потребуется повторить попытку, а служба очередей останется работоспособной, будет затронута только та часть приложения, которая обрабатывают большие двоичные объекты. Если вы решите универсально обрабатывать все повторные попытки операций служб хранилища и вызов к службе BLOB-объектов вернет ошибку, допускающую повторение, то будут запросы и к службе BLOB-объектов, и к службе очередей.

В конечном счете решение зависит от сложности приложения. Можно не обрабатывать сбои каждой отдельной службы, а вместо этого перенаправлять запросы на чтение для всех служб хранилища в дополнительный регион чтения и запускать приложение в режиме только для чтения при обнаружении проблемы в работе какой-либо службы хранения в основном регионе.

### <a name="other-considerations"></a>Дополнительные рекомендации

Ниже приведены дополнительные рекомендации, которые будут рассмотрены в оставшейся части этой статьи.

*   Обработка повторных запросов на чтение с помощью шаблона автоматического выключения.

*   Согласованные в конечном счете данные и время последней синхронизации.

*   Тестирование

## <a name="running-your-application-in-read-only-mode"></a>Выполнение приложения в режиме только для чтения

Чтобы использовать хранилище RA-GRS, требуется возможность обрабатывать как невыполненные запросы на чтение, так и невыполненные запросы на обновление (под обновлением в данном случае подразумеваются операции вставки, изменения и удаления). В случае сбоя основного центра обработки данных запросы на чтение могут быть перенаправлены в дополнительный центр обработки данных. Но запросы на обновление невозможно перенаправить в дополнительный центр обработки данных, так как он доступен только для чтения. По этой причине необходимо разработать приложение, выполняемое в режиме только для чтения.

Например, можно установить флаг, который будет проверяться перед отправкой любых запросов на обновление в службу хранилища Azure. Пр поступлении запроса на обновление его можно пропустить и вернуть пользователю соответствующий ответ. Можно даже полностью отключить определенные функции до устранения проблемы и уведомить пользователей, что эти функции будут временно недоступны.

Если принято решение отдельно обрабатывать ошибки каждой службы, то необходимо также реализовать возможность запуска службой приложения в режиме только для чтения. Например, для каждой службы можно создать флаги режима только для чтения, которые можно включать и отключать. Затем вы сможете управлять этими флагами в соответствующих частях кода.

Возможность запуска приложения в режиме только для чтения имеет еще одно преимущество — дает возможность ограничить функциональность во время обновления основного приложения. Можно активировать запуск приложения в режиме только для чтения и указать дополнительный центр обработки данных. Это гарантирует, что никто не получит доступ к данным в основном регионе, пока выполняется обновление.

## <a name="handling-updates-when-running-in-read-only-mode"></a>Обработка обновлений в режиме только для чтения

Существует множество способов обработки запросов на обновление в режиме только для чтения. Мы не сможем подробно рассмотреть их все, но в целом существует несколько шаблонов, которые вам стоит принять во внимание.

1.  Можно ответить пользователям и сообщить, что в настоящее время обновления не принимаются. Например, система управления контактами может предоставлять клиентам доступ к контактной информации, но не сохранять изменения.

2.  Можно поставить обновления в очередь в другом регионе. В этом случае отложенные запросы на обновление нужно будет записывать в очередь в другом регионе, а затем каким-то образом обрабатывать их после возобновления работы основного центра обработки данных. В этом сценарии следует сообщить пользователю, что запрошенное обновление поставлено в очередь для последующей обработки.

3.  Можно записывать обновления в учетную запись хранения в другом регионе. А когда возобновится работоспособность основного центра обработки данных, каким-либо образом объединить эти обновления с основными данными, в зависимости от их структуры. Например, если создаются отдельные файлы с меткой даты и времени в имени, их можно скопировать обратно в основной регион. Это подходит для некоторых рабочих нагрузок, например ведения журнала и данных Интернета вещей.

## <a name="handling-retries"></a>Обработка повторных попыток

Как узнать, какие ошибки допускают повторение? Это определяет клиентская библиотека службы хранилища. Например, сообщение об ошибке 404 (ресурс не найден) не допускает повторения, так как маловероятно, что повторная попытка увенчается успехом. С другой стороны, ошибка 500 допускает повторение, так как это ошибка сервера, которая может оказаться лишь временной. Для получения дополнительных сведений ознакомьтесь с [открытым кодом класса ExponentialRetry](https://github.com/Azure/azure-storage-net/blob/87b84b3d5ee884c7adc10e494e2c7060956515d0/Lib/Common/RetryPolicies/ExponentialRetry.cs) в клиентской библиотеке службы хранилища для .NET. (Найдите метод ShouldRetry.)

### <a name="read-requests"></a>Запросы на чтение

В случае проблем с основным хранилищем запросы на чтение можно перенаправлять в дополнительное хранилище. Как было отмечено выше в разделе [Использование данных, согласованных в конечном счете](#using-eventually-consistent-data), для вашего приложения должно быть приемлемым чтение потенциально устаревших данных. При использовании клиентской библиотеки службы хранилища для доступа к данным RA-GRS можно задать режим повторения запросов на чтение, задав для свойства **LocationMode** одно из следующих значений:

*   **PrimaryOnly** (по умолчанию);

*   **PrimaryThenSecondary**;

*   **SecondaryOnly**;

*   **SecondaryThenPrimary**.

Если присвоить **LocationMode** значение **PrimaryThenSecondary**, то если при первоначальном запросе на чтение к основной конечной точке происходит ошибка, допускающая повторение, то клиент автоматически выполняет другой запрос на чтение к дополнительной конечной точке. Если ошибка возникла из-за времени ожидания сервера, то клиенту придется дождаться, пока не истечет время ожидания, прежде чем служба вернет ему сообщение об ошибке, допускающей повторение.

По сути, решая, как реагировать на ошибки, допускающие повторение, следует учитывать два сценария:

*   Это изолированная проблема, и последующие запросы к основной конечной точке не вернут ошибку, допускающую повторение. Например, такая ситуация может сложиться при временной ошибке в сети.

    В этом сценарии присвоение **LocationMode** значения **PrimaryThenSecondary** почти не скажется на производительности, так как это происходит редко.

*   Это проблема в работе по крайней мере одной из служб хранилища в основном регионе, и все последующие запросы к этой службе в основном регионе, скорее всего, какое-то время будут возвращать ошибки, допускающие повторение. Примером этого является ситуация, когда основной регион полностью недоступен.

    В этом сценарии производительность снижается, так как все запросы на чтение сначала будут пытаться использовать основную конечную точку и ждать истечения времени ожидания, а затем переключаться на дополнительную конечную точку.

В таких сценариях следует выявлять текущие проблемы с основной конечной точки и отправлять все запросы на чтение напрямую к дополнительной конечной точке, присвоив свойству **LocationMode** значение **SecondaryOnly**. На данном этапе следует также изменить режим запуска приложения на "только для чтения". Этот подход известен как [шаблон автоматического выключения](https://msdn.microsoft.com/library/dn589784.aspx).

### <a name="update-requests"></a>Запросы на обновление

Шаблон автоматического выключения может также применяться для запросов на обновление. Тем не менее запросы на обновление невозможно перенаправлять в дополнительное хранилище, которое доступно только для чтения. Для этих запросов следует оставить используемое по умолчанию значение свойства **LocationMode** — **PrimaryOnly**. Чтобы обработать данные ошибки, можно применить метрики для этих запросов (например, 10 ошибок подряд) и по достижении порога переключать приложение в режим только для чтения. Эти же методы можно использовать для возвращения в режим обновления, как описано в следующем разделе о шаблоне автоматического выключения.

## <a name="circuit-breaker-pattern"></a>Шаблон автоматического выключения

С помощью шаблона автоматического выключения в приложении можно предотвратить повторное выполнение операции, которая, вероятнее всего, будет приводить к повторным сбоям. Это позволяет приложению продолжать работу, а не тратить время на повторение операций по нарастающей. Шаблон также обнаружит, когда будет исправлена ошибка, и в этот момент приложение сможет повторить операцию.

### <a name="how-to-implement-the-circuit-breaker-pattern"></a>Как реализовать шаблон автоматического выключения

Для выявления проблемы в работе основной конечной точки можно отслеживать, как часто клиент сталкивается с ошибками, допускающими повторение. Так как все случаи разные, необходимо определить пороговое значение для переключения на дополнительную конечную точку и запуска приложения в режиме только для чтения. Например, можно выполнять переключение при 10 сбоев подряд, после которых запрос по-прежнему не выполнен. Другой пример: переключение при сбое 90 % запросов в течение 2 минут.

В первом случае можно просто считать число ошибок, и если запрос успешно выполняется до достижения порога, сбрасывать это значение до нуля. Во втором случае для реализации переключения можно использовать объект MemoryCache (в .NET). Для каждого запроса добавьте CacheItem в кэш, задайте значение для успешного (1) или неудачного выполнения (0) и задайте срок действия в 2 минуты от текущего времени (или установленное ограничение времени). По истечении срока действия запись автоматически удаляется. Это обеспечит скользящее окно в 2 минуты. Каждый раз при отправке запроса к службе хранилища сначала используется запрос Linq через объект MemoryCache для вычисления процента успешных операций путем суммирования значений и деления их на количество. Когда процент успешных операций опустится ниже некоторого порога (например, 10 %), следует присвоить свойству **LocationMode** для запросов на чтение значение **SecondaryOnly** и переключить приложение в режим только для чтения, прежде чем продолжить.

Пороговое число ошибок, которое определяет, когда нужно переключить приложение, может отличаться для различных служб в приложении. Поэтому рекомендуется сделать пороговые значения настраиваемыми параметрами. Кроме того, нужно решить, как обрабатывать ошибки, допускающие повторение, от каждой службы — по-отдельности или вместе, как было описано ранее.

Вам следует решить, как будут обрабатываться несколько экземпляров одного приложения и какие действия будут выполняться при обнаружении ошибок, допускающих повторение, в каждом экземпляре. Например, одно приложение может быть загружено на 20 виртуальных машин. Каждый экземпляр будет обрабатываться отдельно? Если в работе одного экземпляра возникают проблемы, требуется ли ответное действие только для этого экземпляра, или вы хотите, чтобы все экземпляры попытались выполнить одинаковое ответное действие в случае проблемы с одним экземпляром? Отдельная обработка экземпляров гораздо проще, чем одновременное координирование ответных действий всех экземпляров, но конкретная реализация зависит от архитектуры приложения.

### <a name="options-for-monitoring-the-error-frequency"></a>Способы мониторинга частоты ошибок

Существует три основных способа мониторинга частоты повторов в основном регионе, позволяющих определить, когда нужно переключиться на дополнительный регион и запустить приложение в режиме только для чтения.

*   Добавьте обработчик события [**Retrying**](http://msdn.microsoft.com/library/microsoft.windowsazure.storage.operationcontext.retrying.aspx) для объекта [**OperationContext**](http://msdn.microsoft.com/library/microsoft.windowsazure.storage.operationcontext.aspx), передаваемого в запросы к хранилищу. Этот метод показан в этой статье и используется в соответствующем примере. Данные события активируются, когда клиент повторяет запрос, что позволяет отслеживать, как часто клиент сталкивается с ошибками, допускающими повторение, на основной конечной точке.

    ```csharp 
    operationContext.Retrying += (sender, arguments) =>
    {
        // Retrying in the primary region
        if (arguments.Request.Host == primaryhostname)
            ...
    };
    ```

*   В методе [**Evaluate**](http://msdn.microsoft.com/library/microsoft.windowsazure.storage.retrypolicies.iextendedretrypolicy.evaluate.aspx) в пользовательской политике повтора можно выполнять пользовательский код всякий раз, когда происходит повторная попытка. Помимо записи повторных попыток это также дает возможность изменить их режим.

    ```csharp 
    public RetryInfo Evaluate(RetryContext retryContext,
    OperationContext operationContext)
    {
        var statusCode = retryContext.LastRequestResult.HttpStatusCode;
        if (retryContext.CurrentRetryCount >= this.maximumAttempts
            || ((statusCode >= 300 && statusCode < 500 && statusCode != 408)
            || statusCode == 501 // Not Implemented
            || statusCode == 505 // Version Not Supported
            ))
        {
            // Do not retry
            return null;
        }

        // Monitor retries in the primary location
        ...

        // Determine RetryInterval and TargetLocation
        RetryInfo info =
            CreateRetryInfo(retryContext.CurrentRetryCount);

        return info;
    }
    ```

*   Третий подход заключается в реализации пользовательского компонента мониторинга в приложении, который постоянно проверяет связь с конечной точкой основного хранилища с помощью фиктивных запросов на чтение (например, запросов на чтение большого двоичного объекта небольшого размера), чтобы определить его работоспособность. Это может потребовать какое-то количество ресурсов, но не значительное. При обнаружении ошибки, которая достигла порога, выполняется переключение в режим **SecondaryOnly** с доступом только для чтения.

В какой-то момент потребуется переключиться обратно на основную конечную точку и разрешить обновления. Если используется один из первых двух методов, описанных выше, то можно просто переключиться обратно на основную конечную точку и включить режим обновления после истечения произвольного периода времени или выполнения произвольного количества операций. После этого можно будет снова задействовать логику повторных попыток. В случае устранения проблемы будет по-прежнему использоваться основная конечная точка с возможностью обновления данных. Если проблема не устранена, то после нарушения установленных вами условий будет выполнено повторное переключение на дополнительную конечную точку и включен режим только для чтения.

В третьем сценарии, когда при проверке связи конечная точка основного хранилища восстановит работоспособность, можно будет активировать переключение обратно в режим **PrimaryOnly** и не запрещать обновления.

## <a name="handling-eventually-consistent-data"></a>Обработка данных, согласованных в конечном счете

RA-GRS функционирует, реплицируя транзакции из основного в дополнительный регион. Репликация гарантирует, что данные во дополнительном регионе *согласованы в конечном счете*. Это означает, что все транзакции в основном регионе в конечном итоге появятся и в дополнительном регионе, но перед этим возможна задержка, и нет никакой гарантии, что транзакции поступят в дополнительный регион в том же порядке, в котором они первоначально были применены в основном регионе. Если транзакции поступают в дополнительный регион не по порядку, то вы *можете* рассматривать данные в этом регионе как несогласованные, пока служба не наверстает упущенное.

В таблице ниже показан пример того, что может произойти при обновлении сведений о сотруднице для ее добавления в роль *administrators*. В этом примере требуется обновить сущность **employee** и изменить в сущности **administrator role** общее число администраторов. Обратите внимание на то, как обновления применяются не по порядку в дополнительном регионе.

| **Время** | **Транзакция**                                            | **Репликация**                       | **Last Sync Time** | **Результат** |
|----------|------------------------------------------------------------|---------------------------------------|--------------------|------------| 
| T0       | Транзакция А: <br> вставка сущности <br> сотрудника в основном регионе. |                                   |                    | Транзакция А вставлена в основной регион,<br> но еще не реплицирована. |
| T1       |                                                            | Транзакция А <br> реплицирована в<br> дополнительный регион. | T1 | Транзакция А реплицирована в дополнительный регион. <br>Значение Last Sync Time обновлено.    |
| T2       | Транзакция Б:<br>Блокировка изменений<br> обновление сущности сотрудника<br> в основном регионе.  |                                | T1                 | Транзакция Б записана в основной регион,<br> но еще не реплицирована.  |
| T3       | Транзакция В:<br> Блокировка изменений <br>administrator<br>сущности роли в<br>primary |                    | T1                 | Транзакция В записана в основной регион,<br> но еще не реплицирована.  |
| *T4*     |                                                       | Транзакция В <br>реплицирована в<br> дополнительный регион. | T1         | Транзакция В реплицирована в дополнительный регион.<br>Значение Last Sync Time не обновлено, так как <br>транзакция Б еще не реплицирована.|
| *T5*     | Чтение сущностей <br>из дополнительного региона.                           |                                  | T1                 | Вы получаете устаревшее значение для <br> сущности employee, так как транзакция Б <br> еще не реплицирована. Вы получаете новое значение для<br> сущности administrator role, так как<br> транзакция В реплицирована. Значение Last Sync Time<br> все еще не обновлено, так как транзакция Б<br> не реплицирована. Можно считать сущность<br>administrator role несогласованной, <br>так как ее дата и время превышают <br>значение Last Sync Time. |
| *T6*     |                                                      | Транзакция Б<br> реплицирована в<br> дополнительный регион. | T6                 | *T6* — всех транзакции вплоть до В <br>реплицированы, значение Last Sync Time<br> обновлено. |

В этом примере предполагается, что клиент переключается на чтение из дополнительного региона на этапе T5. На этом этапе он может успешно считать сущность **administrator role**, но она содержит число администраторов, которое не согласовано с числом сущностей **employee**, которые на данный момент помечены как администраторы в дополнительном регионе. Клиент просто может отобразить это значение с риском, что оно является несогласованным. Кроме того, клиент может попытаться определить, что сущность **administrator role** является потенциально несогласованной, так как обновления были выполнены не по порядку, и затем информировать пользователей об этом.

Чтобы выявить потенциальную несогласованность данных, клиент может использовать значение *Last Sync Time*, которое можно получить в любое время с помощью запроса к службе хранилища. Оно указывает время, когда данные в дополнительном регионе были согласованными в последний раз и когда служба применила все транзакции, предшествующие этому моменту времени. В примере, показанном выше, после того, как служба вставляет сущность **employee** в дополнительный регион, время последней синхронизации (Last Sync Time) принимает значение *T1*. Значение *T1* сохраняется до момента обновления службой сущности **employee** в дополнительном регионе, после чего Last Sync Time принимает значение *T6*. Если клиент получает время последней синхронизации при чтении сущности на этапе *T5*, то может сравнить его с меткой времени сущности. Если метка времени сущности превышает время последней синхронизации, то сущность является потенциально несогласованной, и вы можете выполнить соответствующее действие для приложения. Чтобы использовать это поле, необходимо знать, когда было завершено последнее обновление в основном регионе.

## <a name="testing"></a>Тестирование

Важно проверить, правильно ли приложение работает при обнаружении ошибок, допускающих повторение. Например, нужно проверить, что приложение переходит на дополнительный регион и переключается в режим только для чтения, когда обнаруживает неполадку, и переключается обратно, когда основной регион снова становится доступным. Для этого требуется способ моделирования ошибок, допускающих повторение, и управления их частотой.

Для перехвата и изменения ответов HTTP в сценарии можно использовать [Fiddler](http://www.telerik.com/fiddler). Этот сценарий может определять ответы от основной конечной точки и заменять код состояния HTTP значением, которое клиентская библиотека службы хранилища распознает как ошибку, допускающую повторение. В этом фрагменте кода показан простой пример сценария Fiddler, который перехватывает ответы, получаемые на запросы на чтение к таблице **employeedata**, чтобы возвращать код состояния 502.

```java
static function OnBeforeResponse(oSession: Session) {
    ...
    if ((oSession.hostname == "\[yourstorageaccount\].table.core.windows.net")
      && (oSession.PathAndQuery.StartsWith("/employeedata?$filter"))) {
        oSession.responseCode = 502;
    }
}
```

Вы можете расширить этот пример, перехватывая более широкий диапазон запросов и изменяя **responseCode** только некоторых из них, чтобы точнее имитировать реальную ситуацию. Дополнительные сведения о настройке сценариев Fiddler см. в разделе [Modifying a Request or Response](http://docs.telerik.com/fiddler/KnowledgeBase/FiddlerScript/ModifyRequestOrResponse) (Изменение запроса или ответа) в документации по Fiddler.

Если вы сделали настраиваемыми пороговые значения для переключения приложения в режим только для чтения, то вам будет проще тестировать его поведение на определенных объемах непроизводственных транзакций.

## <a name="next-steps"></a>Дальнейшие действия

* Дополнительные сведения о геоизбыточном хранилище с доступом на чтение, включая еще один пример настройки LastSyncTime, см. в записи блога [Windows Azure Storage Redundancy Options and Read Access Geo Redundant Storage](https://blogs.msdn.microsoft.com/windowsazurestorage/2013/12/11/windows-azure-storage-redundancy-options-and-read-access-geo-redundant-storage/) (Варианты обеспечения избыточности службы хранилища Microsoft Azure и геоизбыточное хранилище с доступом на чтение).

* Полный пример, демонстрирующий, как переключаться между основной и дополнительной конечными точками, см. в разделе [Azure Samples – Using the Circuit Breaker Pattern with RA-GRS storage](https://github.com/Azure-Samples/storage-dotnet-circuit-breaker-pattern-ha-apps-using-ra-grs) (Примеры Azure. Использование шаблона автоматического выключения с хранилищем RA-GRS).
