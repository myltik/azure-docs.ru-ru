<properties
	pageTitle="Шифрование на стороне клиента с помощью Java для службы хранилища Microsoft Azure | Microsoft Azure"
	description="Клиентская библиотека хранилища Azure для Java поддерживает шифрование на стороне клиента, а также интеграцию с хранилищем ключей Azure для обеспечения максимальной защиты ваших приложений службы хранилища Azure."
	services="storage"
	documentationCenter="java"
	authors="dineshmurthy"
	manager="jahogg"
	editor="tysonn"/>

<tags
	ms.service="storage"
	ms.workload="storage"
	ms.tgt_pltfrm="na"
	ms.devlang="na"
	ms.topic="article"
	ms.date="09/20/2016"
	ms.author="dineshm;robinsh"/>


# Шифрование на стороне клиента с помощью Java для службы хранилища Microsoft Azure   

[AZURE.INCLUDE [storage-selector-client-side-encryption-include](../../includes/storage-selector-client-side-encryption-include.md)]

## Обзор  

[Клиентская библиотека службы хранилища Azure для Java](http://mvnrepository.com/artifact/com.microsoft.azure/azure-storage) поддерживает шифрование данных в клиентских приложениях перед их отправкой в службу хранилища Azure и их расшифровку во время скачивания клиентом. Библиотека также поддерживает интеграцию с [хранилищем ключей Azure](https://azure.microsoft.com/services/key-vault/) для управления ключами учетной записи хранения.

## Шифрование и расшифровка методом конвертов    
Для шифрования и расшифровки используется конвертный метод.

### Шифрование конвертным методом  
Шифрование конвертным методом выполняется следующим образом.

1.	Клиентская библиотека хранилища Azure создает ключ шифрования содержимого (CEK), который является симметричным ключом для однократного использования.

2.	Данные пользователя шифруются с помощью этого ключа CEK.

3.	Ключ CEK, в свою очередь, шифруется с помощью ключа шифрования ключа KEK. KEK определяется идентификатором ключа и может быть парой асимметричных ключей или симметричным ключом. Им можно управлять локально, а также хранить его в хранилище ключей Azure. Сама клиентская библиотека хранилища не имеет доступа к ключу KEK. Библиотека вызывает алгоритм шифрования ключа, который обеспечивается хранилищем ключей. Пользователи могут при необходимости использовать настраиваемые поставщики для шифрования и расшифровки ключа.

4.	Зашифрованные данные затем передаются в службу хранилища Azure. Зашифрованный ключ вместе с дополнительными метаданными шифрования хранится как метаданные (в большом двоичном объекте) или вставляется в зашифрованные данные (сообщения в очереди и табличные сущности).

### Расшифровка конвертным методом  
Расшифровка конвертным методом выполняется следующим образом.

1.	Клиентская библиотека предполагает, что пользователь управляет ключом шифрования ключа KEK локально или через хранилище ключей Azure. Пользователь может не знать, какой именно ключ использовался для шифрования. Вместо этого достаточно настроить и использовать сопоставитель ключей, который будет распознавать разные идентификаторы ключей.

2.	Клиентская библиотека скачивает зашифрованные данные вместе с данными шифрования, которые хранятся в службе.

3.	Зашифрованный ключ шифрования содержимого CEK расшифровывается с помощью ключа шифрования ключа KEK. Клиентская библиотека не имеет доступа к ключу KEK. Клиентская библиотека вызывает пользовательский алгоритм или алгоритм расшифровки поставщика хранилища ключей.

4.	Затем ключ шифрования содержимого CEK используется для расшифровки зашифрованных пользовательских данных.

## Механизм шифрования  
Клиентская библиотека хранилища использует алгоритм [AES](http://en.wikipedia.org/wiki/Advanced_Encryption_Standard) для шифрования данных пользователя. Говоря более конкретно, это режим [цепочки цифровых блоков или CBC](http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher-block_chaining_.28CBC.29) вместе с AES. Каждая служба работает по-разному, поэтому каждая служба рассматривается отдельно.

### BLOB-объекты  
Клиентская библиотека в настоящий момент полностью поддерживает только шифрование больших двоичных объектов. В частности, шифрование поддерживается, когда пользователи применяют методы **upload*** или метод **openOutputStream**. Что касается загрузок, то поддерживаются как полные, так и диапазонные загрузки.

Во время шифрования клиентская библиотека создает случайный вектор инициализации IV размером 16 байт, случайный ключ шифрования содержимого CEK размером 32 байта и выполняет конвертное шифрование данных большого двоичного объекта, используя полученную информацию. Затем зашифрованный ключ CEK и дополнительные метаданные шифрования сохраняются в службе как метаданные большого двоичного объекта вместе с зашифрованным большим двоичным объектом.

>[AZURE.WARNING] Если вы изменяете или загружаете собственные метаданные для большого двоичного объекта, нужно убедиться, что данные сохранены. Если загрузить новые метаданные без этих метаданных, зашифрованный ключ CEK, ключ IV и другие метаданные будут утеряны, а без них получить содержимое большого двоичного объекта невозможно.

Скачивание зашифрованного большого двоичного объекта предполагает получение всего его содержимого с помощью удобных методов **download*/openInputStream**. Зашифрованный ключ CEK расшифровывается и используется вместе с ключом IV (который в данном случае хранится как метаданные большого двоичного объекта) для передачи расшифрованных данных обратно пользователям.

Скачивание произвольного диапазона (с помощью методов **downloadRange***) из зашифрованного большого двоичного объекта предполагает настройку диапазона на стороне пользователя, чтобы получить небольшой объем дополнительных данных, которые помогут расшифровать запрошенный диапазон.

Все типы больших двоичных объектов (блочные, страничные и инкрементируемые) могут быть зашифрованы и расшифрованы с помощью этой схемы.

### Очереди  
Поскольку очередь сообщений может иметь любой формат, клиентская библиотека определяет нестандартный формат, который включает вектор инициализации IV и зашифрованный ключ шифрования содержимого CEK в текст сообщения.

Во время шифрования клиентская библиотека создает случайный ключ IV размером 16 байт, случайный ключ CEK размером 32 байта и выполняет конвертное шифрование текста сообщения очереди, используя полученную информацию. Зашифрованный ключ CEK и дополнительные метаданные шифрования добавляются в зашифрованное сообщение очереди. Это измененное сообщение (показано ниже) сохраняется в службе.

	<MessageText>{"EncryptedMessageContents":"6kOu8Rq1C3+M1QO4alKLmWthWXSmHV3mEfxBAgP9QGTU++MKn2uPq3t2UjF1DO6w","EncryptionData":{…}}</MessageText>

Во время расшифровки зашифрованный ключ извлекается из сообщения очереди и расшифровывается. Ключ IV также извлекается из сообщения очереди и используется вместе с расшифрованным ключом для расшифровки данных сообщения очереди. Обратите внимание, что размер метаданных шифрования очень мал (не более 500 байт), поэтому, хотя этот их размер учитывается при подсчете максимального размера в 64 КБ для сообщения очереди, этим размером данных можно пренебречь.

### Таблицы  
Клиентская библиотека поддерживает шифрование свойств сущности для операций вставки и замены.

>[AZURE.NOTE] Слияние в настоящее время не поддерживается. Поскольку подмножество свойств могло уже быть зашифровано с помощью другого ключа, простое слияние новых свойств и обновление метаданных приведет к потере данных. Для слияния требуется либо сначала прочитать данные существующей сущности в службе, либо использовать новый ключ для каждого свойства, однако оба способа не подходят из-за низкой эффективности.

Шифрование табличных данных выполняется следующим образом.

1.	Пользователи указывают свойства, которые следует зашифровать.

2.	Клиентская библиотека создает случайный вектор инициализации IV размером 16 байт и произвольный ключ шифрования содержимого CEK размером 32 байта для каждой сущности и выполняет конвертное шифрование для отдельных свойств, которые следует зашифровать путем создания нового ключа IV для каждого свойства. Зашифрованное свойство хранится в виде двоичных данных.

3.	Затем зашифрованный ключ CEK и дополнительные метаданные шифрования сохраняются в виде двух дополнительных зарезервированных свойств. Первое зарезервированное свойство (\_ClientEncryptionMetadata1) — это строковое свойство, которое содержит информацию о ключе IV, версию и зашифрованный ключ. Второе зарезервированное свойство (\_ClientEncryptionMetadata2) — это двоичное свойство, которое содержит информацию о зашифрованных свойствах. Сведения в этом втором свойстве (\_ClientEncryptionMetadata2) сами по себе зашифрованы.

4.	Из-за этих двух дополнительных зарезервированных свойств, необходимых для шифрования, пользователи могут иметь только 250 пользовательских свойств вместо 252. Общий размер сущности должен быть меньше 1 МБ.

	Обратите внимание, что зашифрованы могут быть только строковые свойства. Если необходимо зашифровать другие типы свойств, их необходимо преобразовать в строки. Зашифрованные строки хранятся в службе в виде двоичных свойств. Они преобразуются обратно в строки после расшифровки.

	Что касается таблиц, то в дополнение к политике шифрования пользователи должны указать свойства, которые необходимо зашифровать. Это можно сделать путем указания атрибута [Encrypt] \(для сущностей POCO, которые являются производными от TableEntity) или с помощью сопоставителя шифрования в параметрах запроса. Сопоставитель шифрования — это делегат, который получает ключ раздела, ключ строки и имя свойства, а затем возвращает логическое значение, которое указывает, следует ли это свойство шифровать. Во время шифрования клиентская библиотека использует эти сведения, чтобы решить, следует ли шифровать свойство перед отправкой. Делегат также обеспечивает возможность логики в отношении того, как шифруются свойства. (Например, если значение равно X, то шифровать свойство А; в противном случае шифровать свойства А и В.) Обратите внимание, что нет необходимости предоставлять эти сведения при чтении или выполнении запросов к сущностям.

### Пакетные операции  
В пакетных операциях один ключ KEK используется для всех строк операции, поскольку клиентская библиотека допускает использование только одного объекта параметров (и, следовательно, одну политику или ключ KEK) на одну пакетную операцию. Однако клиентская библиотека создает новый случайный ключ IV и случайный ключ CEK на каждую строку в пакете. Пользователи могут также выбрать шифрование других свойств для каждой операции в пакете, определив это поведение в сопоставителе шифрования.

### Запросы  
Чтобы выполнять операции запроса, следует указать сопоставитель ключа, который способен распознавать все ключи в результирующем наборе. Если сущность в результате запроса не может быть разрешена для поставщика, клиентская библиотека выдаст ошибку. Для запроса, который обращается к серверу, клиентская библиотека добавляет по умолчанию специальные свойства метаданных шифрования (\_ClientEncryptionMetadata1 и \_ClientEncryptionMetadata2) к выбранным столбцам.

## Хранилище ключей Azure  
Хранилище ключей Azure помогает защитить криптографические ключи и секреты, используемые облачными приложениями и службами. Хранилище ключей Azure позволяет шифровать ключи и секреты (например, ключи проверки подлинности, ключи учетных записей хранения, ключи шифрования данных, PFX-файлы и пароли), используя ключи, защищенные аппаратными модулями безопасности. Дополнительные сведения см. в статье [Что такое хранилище ключей Azure?](../key-vault/key-vault-whatis.md).

Клиентская библиотека хранилища использует основную библиотеку хранилища ключей для обеспечения общей платформы для управления ключами в Azure. Пользователи также получают дополнительное преимущество от использования библиотеки хранилища ключей. Библиотека расширений предоставляет полезные функции для локальных и облачных поставщиков ключей с простым и симметричным алгоритмом (RSA), а также функции агрегирования и кэширования.

### Интерфейс и зависимости  
Существует три пакета хранилища ключей:

- azure-keyvault-core содержит IKey и IKeyResolver. Это небольшой пакет без зависимостей. Клиентская библиотека хранилища для Java определяет это как зависимость.
- azure-keyvault содержит клиентское REST-приложение хранилища ключей.
- azure-keyvault-extensions содержит код расширения, который включает реализации криптографических алгоритмов, а также ключи RSAKey и SymmetricKey. Пакет зависит от пространств имен Core и KeyVault и обеспечивает функции, которые позволяют определить составной сопоставитель (когда пользователи используют несколько поставщиков ключей) и сопоставитель ключа кэширования. Клиентская библиотека хранилища не зависит напрямую от этого пакета, однако, если пользователь хочет использовать хранилище ключей Azure для хранения ключей или расширения хранилища ключей для работы с локальными и облачными поставщиками служб шифрования, потребуется этот пакет.

  Хранилище ключей разработано для главных ключей, и ограничения регулирования, связанные с хранилищем ключей, учитывают это. При выполнении шифрования на стороне клиента с помощью хранилища ключей предпочтительный способ — использовать симметричные главные ключи, которые хранятся в качестве секретов в хранилище ключей, и кэшировать их локально. Рекомендуется придерживаться следующих правил.

1.	Создайте секрет без подключения к сети и загрузите его в хранилище ключей.

2.	Используйте базовый идентификатор секрета в качестве параметра для разрешения текущей версии секрета для шифрования и кэшируйте эту информацию локально. Используйте параметр CachingKeyResolver для кэширования; пользователи не должны реализовывать собственную логику кэширования.

3.	Во время создания политики шифрования используйте кэширующий сопоставитель в качестве входных данных. Дополнительные сведения об использовании хранилища ключей см. в разделе с примерами кода шифрования. <Исправить URL-адрес>

## Рекомендации  
Шифрование поддерживается только клиентской библиотекой хранилища для Java.

>[AZURE.IMPORTANT] Учтите следующие важные моменты при использовании шифрования на стороне клиента.
>  
>- При чтении или записи в зашифрованном большом двоичном объекте используйте команды загрузки полного большого двоичного объекта и команды диапазонной либо полной выгрузки. Избегайте написания зашифрованного большого двоичного объекта с помощью операций протокола, таких как Put Block, Put Block List, Write Pages, Clear Pages или Append Block, иначе это может привести к повреждению зашифрованного большого двоичного объекта, что сделает его нечитабельным.
>
>- Для таблиц существуют аналогичные ограничения. Будьте внимательны и не обновляйте зашифрованные свойства без обновления метаданных шифрования.
>
>- Если задать метаданные в зашифрованном большом двоичном объекте, могут быть перезаписаны метаданные, относящиеся к шифрованию и необходимые для расшифровки, поскольку настройку метаданных добавить нельзя. Это также касается моментальных снимков. Не указывайте метаданные во время создания моментального снимка зашифрованного большого двоичного объекта. Если необходимо задать метаданные, нужно сначала вызвать метод **downloadAttributes** для получения текущих метаданных шифрования и избегать параллельных операций записи во время установки метаданных.
>
>- Включите флаг **requireEncryption** в параметрах запроса по умолчанию для пользователей, которые должны работать только с зашифрованными данными. См. дополнительные сведения ниже.

## API-интерфейс клиента / интерфейс  
При создании объекта EncryptionPolicy пользователи могут предоставить только ключ (который реализует IKey), только сопоставитель (который реализует IKeyResolver) или оба этих объекта. IKey — это базовый тип ключа, который идентифицируется с помощью идентификатора ключа и который обеспечивает логику для шифрования и расшифровки. IKeyResolver используется для сопоставления ключа во время расшифровки. IKeyResolver определяет метод, который возвращает IKey в зависимости от идентификатора ключа. В результате пользователи могут выбирать между несколькими ключами, которые хранятся в разных местах.

- Для шифрования ключ используется всегда, при этом отсутствие ключа приведет к возникновению ошибки.
- Для расшифровки:
	- Сопоставитель ключа вызывается, если он нужен для получения ключа. Если сопоставитель указан, но он не имеет данных, сопоставимых с идентификатором ключа, возникает ошибка.
	- Если сопоставитель не указан, но указан ключ, ключ используется, если его идентификатор соответствует требуемому идентификатору ключа. Если идентификатор не совпадает, выдается ошибка.

	  В статье с [примерами шифрования](https://github.com/Azure/azure-storage-net/tree/master/Samples/GettingStarted/EncryptionSamples) <исправить URL-адрес> показан подробный комплексный сценарий для больших двоичных объектов, очередей, таблиц и интеграции хранилища ключей.

### Режим RequireEncryption  
При необходимости можно включить режим работы, где все передачи и загрузки должны быть зашифрованы. В этом режиме все попытки клиента передать данные без политики шифрования или загрузить данные, которые не зашифрованы в службе, закончатся ошибкой. Это поведение контролирует флаг **requireEncryption** объекта параметров запроса. Если приложение будет шифровать все объекты из службы хранилища Azure, то можно задать свойство **requireEncryption** в параметрах запроса по умолчанию для объекта клиента службы.

Например, используйте для **CloudBlobClient.getDefaultRequestOptions().setRequireEncryption(true)**, чтобы требовать шифрования всех операций с большими двоичными объектами, выполненных посредством этого объекта клиента.

### Шифрование службы BLOB-объектов  
Создайте объект **BlobEncryptionPolicy** и задайте его в параметрах запроса (для каждого API или на уровне клиента с помощью параметра **DefaultRequestOptions**). Все остальные задачи решаются клиентской библиотекой.

	// Create the IKey used for encryption.
	RsaKey key = new RsaKey("private:key1" /* key identifier */);

	// Create the encryption policy to be used for upload and download.
	BlobEncryptionPolicy policy = new BlobEncryptionPolicy(key, null);

	// Set the encryption policy on the request options.
	BlobRequestOptions options = new BlobRequestOptions();
	options.setEncryptionPolicy(policy);

	// Upload the encrypted contents to the blob.
	blob.upload(stream, size, null, options, null);

	// Download and decrypt the encrypted contents from the blob.
	ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
	blob.download(outputStream, null, options, null);

### Шифрование службы очередей  
Создайте объект **QueueEncryptionPolicy** и задайте его в параметрах запроса (для каждого API или на уровне клиента с помощью параметра **DefaultRequestOptions**). Все остальные задачи решаются клиентской библиотекой.

	// Create the IKey used for encryption.
	RsaKey key = new RsaKey("private:key1" /* key identifier */);

	// Create the encryption policy to be used for upload and download.
	QueueEncryptionPolicy policy = new QueueEncryptionPolicy(key, null);

	// Add message
	QueueRequestOptions options = new QueueRequestOptions();
	options.setEncryptionPolicy(policy);

	queue.addMessage(message, 0, 0, options, null);

	// Retrieve message
	CloudQueueMessage retrMessage = queue.retrieveMessage(30, options, null);

### Шифрование службы таблиц  
Помимо создания политики шифрования и настройки параметров запроса необходимо указать **EncryptionResolver** в **TableRequestOptions** или задать атрибут [Encrypt] для методов задания и считывания сущности.

### Использование сопоставителя  

	// Create the IKey used for encryption.
	RsaKey key = new RsaKey("private:key1" /* key identifier */);

	// Create the encryption policy to be used for upload and download.
	TableEncryptionPolicy policy = new TableEncryptionPolicy(key, null);

	TableRequestOptions options = new TableRequestOptions()
	options.setEncryptionPolicy(policy);
	options.setEncryptionResolver(new EncryptionResolver() {
	    public boolean encryptionResolver(String pk, String rk, String key) {
        	if (key == "foo")
        	{
	            return true;
        	}
        	return false;
    	}
	});

	// Insert Entity
	currentTable.execute(TableOperation.insert(ent), options, null);

	// Retrieve Entity
	// No need to specify an encryption resolver for retrieve
	TableRequestOptions retrieveOptions = new TableRequestOptions()
	retrieveOptions.setEncryptionPolicy(policy);

	TableOperation operation = TableOperation.retrieve(ent.PartitionKey, ent.RowKey, DynamicTableEntity.class);
	TableResult result = currentTable.execute(operation, retrieveOptions, null);

### Использование атрибутов  
Как было показано выше, если сущность реализует TableEntity, методы задания и считывания свойства можно определить с помощью атрибута [Encrypt], а не с помощью **EncryptionResolver**.

	private string encryptedProperty1;

	@Encrypt
	public String getEncryptedProperty1 () {
	    return this.encryptedProperty1;
	}

	@Encrypt
	public void setEncryptedProperty1(final String encryptedProperty1) {
	    this.encryptedProperty1 = encryptedProperty1;
	}

## Шифрование и производительность  
Обратите внимание, что шифрование результатов анализа данных хранилища отрицательно влияет на производительность. Ключ содержимого и вектор инициализации необходимо создать, само содержимое — зашифровать, а дополнительные метаданные — отформатировать и передать. Эти издержки зависят от объема шифруемых данных. Мы рекомендуем клиентам всегда тестировать свои приложения для повышения производительности во время разработки.

## Дальнейшие действия  

- Скачайте [клиентскую библиотеку хранилища Azure для пакета Maven Java](http://mvnrepository.com/artifact/com.microsoft.azure/azure-storage).
- Скачайте [клиентскую библиотеку хранилища Azure для исходного кода Java из GitHub](https://github.com/Azure/azure-storage-java).
- Скачайте библиотеку Maven хранилища ключей Azure для пакетов Maven Java.
	- [Основной](http://mvnrepository.com/artifact/com.microsoft.azure/azure-keyvault-core) пакет.
	- [Клиентский](http://mvnrepository.com/artifact/com.microsoft.azure/azure-keyvault) пакет.
- Просмотрите [документацию по хранилищу ключей Azure](../key-vault/key-vault-whatis.md).

<!---HONumber=AcomDC_0921_2016-->