---
title: Общие сведения о языке запросов Центра Интернета вещей Azure | Документация Майкрософт
description: Руководство разработчика. Описание похожего на SQL языка запросов Центра Интернета вещей, который используется для получения сведений о двойниках устройств и модулей, а также заданиях из Центра Интернета вещей.
author: fsautomata
manager: ''
ms.service: iot-hub
services: iot-hub
ms.topic: conceptual
ms.date: 02/26/2018
ms.author: elioda
ms.openlocfilehash: 663277bfe347f42fa7ee241f5acddf4a3dca9268
ms.sourcegitcommit: 266fe4c2216c0420e415d733cd3abbf94994533d
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/01/2018
ms.locfileid: "34633518"
---
# <a name="iot-hub-query-language-for-device-and-module-twins-jobs-and-message-routing"></a>Язык запросов Центра Интернета вещей для двойников устройств и двойников модулей, заданий и маршрутизации сообщений

Центр Интернета вещей предоставляет эффективный язык запросов, похожий на SQL, для получения сведений о [двойниках устройств][lnk-twins], [заданиях][lnk-jobs] и [маршрутизации сообщений][lnk-devguide-messaging-routes]. В этой статье представлены:

* общие сведения об основных возможностях языка запросов Центра Интернета вещей;
* подробное описание языка.

[!INCLUDE [iot-hub-basic](../../includes/iot-hub-basic-partial.md)]

## <a name="device-and-module-twin-queries"></a>Запросы двойников устройств и модулей
[Двойники устройств][lnk-twins] и двойники модулей могут содержать произвольные объекты JSON в качестве тегов и свойств. Центр Интернета вещей позволяет выполнять запросы к двойникам устройств и двойникам модулей как к одному документу JSON, содержащему все сведения о двойниках.
Предположим, что двойники устройств в Центре Интернета вещей имеют следующую структуру (структура двойников модулей будет выглядеть так же и содержать элемент moduleId):

```json
{
    "deviceId": "myDeviceId",
    "etag": "AAAAAAAAAAc=",
    "status": "enabled",
    "statusUpdateTime": "0001-01-01T00:00:00",    
    "connectionState": "Disconnected",    
    "lastActivityTime": "0001-01-01T00:00:00",
    "cloudToDeviceMessageCount": 0,
    "authenticationType": "sas",    
    "x509Thumbprint": {    
        "primaryThumbprint": null,
        "secondaryThumbprint": null
    },
    "version": 2,
    "tags": {
        "location": {
            "region": "US",
            "plant": "Redmond43"
        }
    },
    "properties": {
        "desired": {
            "telemetryConfig": {
                "configId": "db00ebf5-eeeb-42be-86a1-458cccb69e57",
                "sendFrequencyInSecs": 300
            },
            "$metadata": {
            ...
            },
            "$version": 4
        },
        "reported": {
            "connectivity": {
                "type": "cellular"
            },
            "telemetryConfig": {
                "configId": "db00ebf5-eeeb-42be-86a1-458cccb69e57",
                "sendFrequencyInSecs": 300,
                "status": "Success"
            },
            "$metadata": {
            ...
            },
            "$version": 7
        }
    }
}
```

### <a name="device-twin-queries"></a>Запросы двойника устройства

Центр Интернета вещей предоставляет двойники устройства как коллекцию документов с именем **devices**.
Следующий запрос получает весь набор двойников устройства:

```sql
SELECT * FROM devices
```

> [!NOTE]
> [Пакеты SDK для Azure IoT][lnk-hub-sdks] поддерживают разбивку на страницы объемных результатов.

Центр Интернета вещей позволяет получить двойники устройств, отфильтрованные по произвольным условиям. Например, для получения двойников устройств, где тег **location.region** имеет значение **US**, используйте следующий запрос:

```sql
SELECT * FROM devices
WHERE tags.location.region = 'US'
```

Кроме того, поддерживаются логические операторы и арифметические сравнения. Например, для получения двойников устройств, которые находятся в США и настроены для отправки телеметрии не чаще раза в минуту, используйте следующий запрос:

```sql
SELECT * FROM devices
WHERE tags.location.region = 'US'
    AND properties.reported.telemetryConfig.sendFrequencyInSecs >= 60
```

Для удобства можно также использовать константы массива с операторами **IN** ("входит") и **NIN** ("не входит"). Например, для получения двойников устройств, сообщающих о подключении по Wi-Fi или проводной сети, используйте следующий запрос:

```sql
SELECT * FROM devices
WHERE properties.reported.connectivity IN ['wired', 'wifi']
```

Часто требуется определить все двойники устройств, содержащие определенное свойство. Для этой цели Центр Интернета вещей поддерживает функцию `is_defined()`. Например, для получения двойников устройств, которые определяют свойство `connectivity`, используется следующий запрос:

```SQL
SELECT * FROM devices
WHERE is_defined(properties.reported.connectivity)
```

Полное описание возможностей фильтрации см. в разделе [Предложение WHERE][lnk-query-where].

Кроме того, поддерживаются группирование и агрегаты. Например, чтобы найти количество устройств в каждом состоянии конфигурации телеметрии, используйте следующий запрос:

```sql
SELECT properties.reported.telemetryConfig.status AS status,
    COUNT() AS numberOfDevices
FROM devices
GROUP BY properties.reported.telemetryConfig.status
```

Этот запрос группировки вернет результат, как в следующем примере:

```json
[
    {
        "numberOfDevices": 3,
        "status": "Success"
    },
    {
        "numberOfDevices": 2,
        "status": "Pending"
    },
    {
        "numberOfDevices": 1,
        "status": "Error"
    }
]
```

В этом примере три устройства сообщают об успешной конфигурации, два все еще применяют конфигурацию и одно сообщило об ошибке.

Запросы проекции позволяют разработчикам настроить возврат только требуемых свойств. Например, чтобы узнать время последнего действия всех отключенных устройств, используйте следующий запрос:

```sql
SELECT LastActivityTime FROM devices WHERE status = 'enabled'
```

### <a name="module-twin-queries"></a>Запросы двойника модуля

Запросы к двойникам модулей похожи на запросы к двойникам устройств, но они используют другую коллекцию или пространство имен. Например, вместо блока FROM devices запрос может содержать следующее:

```sql
SELECT * FROM devices.modules
```

Мы не рекомендуем объединять коллекции devices и devices.modules. Если нужно выполнить запрос к двойникам модулей на всех устройствах, используйте для этого теги. Этот запрос вернет список всех двойников модулей с состоянием scanning на всех устройствах:

```sql
Select * from devices.modules where reported.properties.status = 'scanning'
```

Этот запрос вернет список всех двойников модулей с состоянием scanning, но только в определенном наборе устройств:

```sql
Select * from devices.modules where reported.properties.status = 'scanning' and deviceId IN ('device1', 'device2')  
```

### <a name="c-example"></a>Пример C#
Функция обработки запросов предоставляется в [пакете SDK для служб C#][lnk-hub-sdks] в классе **RegistryManager**.
Ниже приведен пример простого запроса:

```csharp
var query = registryManager.CreateQuery("SELECT * FROM devices", 100);
while (query.HasMoreResults)
{
    var page = await query.GetNextAsTwinAsync();
    foreach (var twin in page)
    {
        // do work on twin object
    }
}
```

Объект **query** создается с размером страницы (до 100). Затем несколько страниц извлекаются путем вызова методов **GetNextAsTwinAsync** несколько раз.

Объект query предоставляет несколько значений **Next**, которые зависят от параметра десериализации, необходимого для запроса. Например, двойник устройства или объекты задания, или обычные JSON при использовании проекций.

### <a name="nodejs-example"></a>Пример для Node.js
Функция обработки запросов предоставляется в [пакете SDK службы Azure IoT для Node.js][lnk-hub-sdks] в объекте **Registry**.
Ниже приведен пример простого запроса:

```nodejs
var query = registry.createQuery('SELECT * FROM devices', 100);
var onResults = function(err, results) {
    if (err) {
        console.error('Failed to fetch the results: ' + err.message);
    } else {
        // Do something with the results
        results.forEach(function(twin) {
            console.log(twin.deviceId);
        });

        if (query.hasMoreResults) {
            query.nextAsTwin(onResults);
        }
    }
};
query.nextAsTwin(onResults);
```

Объект **query** создается с размером страницы (до 100). Затем несколько страниц извлекаются путем вызова метода **nextAsTwin** несколько раз.

Объект query предоставляет несколько значений **Next**, которые зависят от параметра десериализации, необходимого для запроса. Например, двойник устройства или объекты задания, или обычные JSON при использовании проекций.

### <a name="limitations"></a>Ограничения

> [!IMPORTANT]
> Результаты запросов могут поступать с задержкой в несколько минут и не учитывать последние значения в двойниках устройств. При запросе к отдельному двойнику устройства по идентификатору используйте API извлечения двойника устройства. Этот API всегда содержит последние значения и имеет большие границы регулирования.

В настоящее время сравнения поддерживаются только между типами-примитивами (не объектами), например, `... WHERE properties.desired.config = properties.reported.config` поддерживается только в том случае, если эти свойства имеют примитивные значения.

## <a name="get-started-with-jobs-queries"></a>Начало работы с запросами заданий

[Задания][lnk-jobs] позволяют выполнять операции с наборами устройств. Каждый двойник устройства содержит сведения о заданиях, в которых он участвует, в коллекции с именем **jobs**.
Логически получается следующее:

```json
{
    "deviceId": "myDeviceId",
    "etag": "AAAAAAAAAAc=",
    "tags": {
        ...
    },
    "properties": {
        ...
    },
    "jobs": [
        {
            "deviceId": "myDeviceId",
            "jobId": "myJobId",
            "jobType": "scheduleTwinUpdate",
            "status": "completed",
            "startTimeUtc": "2016-09-29T18:18:52.7418462",
            "endTimeUtc": "2016-09-29T18:20:52.7418462",
            "createdDateTimeUtc": "2016-09-29T18:18:56.7787107Z",
            "lastUpdatedDateTimeUtc": "2016-09-29T18:18:56.8894408Z",
            "outcome": {
                "deviceMethodResponse": null
            }
        },
        ...
    ]
}
```

В настоящее время к этой коллекции можно выполнить запрос как к **devices.jobs** на языке запросов Центра Интернета вещей.

> [!IMPORTANT]
> В настоящее время свойство jobs никогда не возвращается при запросах двойников устройств. То есть при запросах, содержащих FROM devices. Доступ к свойству задания можно получить только непосредственно с помощью запросов, использующих `FROM devices.jobs`.
>
>

Например, чтобы получить все задания (выполненные и запланированные), влияющие на одно устройство, можно использовать следующий запрос:

```sql
SELECT * FROM devices.jobs
WHERE devices.jobs.deviceId = 'myDeviceId'
```

Обратите внимание, как этот запрос предоставляет сведения о состоянии конкретного устройства (и, возможно, ответ на прямой метод) в каждом возвращенном задании.
Все свойства объектов в коллекции **devices.jobs** можно также отфильтровать с помощью произвольных логических условий.
Например, чтобы получить все завершенные задания по обновлению двойников устройств, созданных после сентября 2016 года для определенного устройства, используйте следующий запрос:

```sql
SELECT * FROM devices.jobs
WHERE devices.jobs.deviceId = 'myDeviceId'
    AND devices.jobs.jobType = 'scheduleTwinUpdate'
    AND devices.jobs.status = 'completed'
    AND devices.jobs.createdTimeUtc > '2016-09-01'
```

Вы также можете получить результаты по одному заданию для каждого устройства.

```sql
SELECT * FROM devices.jobs
WHERE devices.jobs.jobId = 'myJobId'
```

### <a name="limitations"></a>Ограничения
В настоящее время запросы к **devices.jobs** не поддерживают следующие элементы:

* проекции, поэтому можно использовать только `SELECT *`;
* условия, касающиеся двойника устройства, и свойства задания (см. предыдущий раздел);
* выполняемые агрегаты, например count, avg, group by.

## <a name="device-to-cloud-message-routes-query-expressions"></a>Выражения запросов по маршрутам сообщений, отправляемых с устройства в облако

С помощью [маршрутов с устройства в облако][lnk-devguide-messaging-routes] можно сделать так, чтобы Центр Интернета вещей передавал сообщения, отправляемые с устройства в облако, в разные конечные точки. Распределение основано на выражениях, вычисляемых для отдельных сообщений.

Используемое в маршруте [условие][lnk-query-expressions] создается на том же языка запросов Центра Интернета вещей, что и условия в запросах двойников и заданий. Условия маршрута вычисляются по заголовкам и тексту сообщения. Выражение запроса маршрутизации может включать только заголовки сообщений, только текст сообщения или и то, и другое. Центр Интернета вещей предполагает наличие определенной схемы для заголовков и текста сообщения для маршрутизации сообщений. В следующих разделах описываются необходимые условия правильной маршрутизации Центра Интернета вещей.

### <a name="routing-on-message-headers"></a>Маршрутизация по заголовкам сообщений

Центр Интернета вещей предполагает следующее представление JSON заголовков сообщений для маршрутизации:

```json
{
  "message": {
    "systemProperties": {
      "contentType": "application/json",
      "contentEncoding": "utf-8",
      "iothub-message-source": "deviceMessages",
      "iothub-enqueuedtime": "2017-05-08T18:55:31.8514657Z"
    },
    "appProperties": {
      "processingPath": "<optional>",
      "verbose": "<optional>",
      "severity": "<optional>",
      "testDevice": "<optional>"
    },
    "body": "{\"Weather\":{\"Temperature\":50}}"
  }
}
```

Системные свойства сообщений начинаются с символов `'$'`.
Доступ к пользовательским свойствам всегда осуществляется с использованием их имен. Если имя пользовательского свойства совпадает с системным свойством (например, `$contentType`), такое пользовательское свойство будет извлечено с помощью выражения `$contentType`.
Вы всегда можете получить доступ к системному свойству с помощью квадратных скобок `{}`: например, можно использовать выражение `{$contentType}` для доступа к системному свойству `contentType`. Имена свойств в квадратных скобках всегда позволяют получить соответствующее системное свойство.

Не забывайте, что в именах свойств не учитывается регистр.

> [!NOTE]
> Все свойства сообщения являются строками. Системные свойства сейчас нельзя использовать в запросах (см. [руководство разработчика][lnk-devguide-messaging-format]).
>

Например, если вы используете свойство `messageType`, вы можете направлять все данные телеметрии в одну конечную точку, а все оповещения — в другую. Следующее выражение позволяет перенаправить данные телеметрии:

```sql
messageType = 'telemetry'
```

А это выражение будет перенаправлять текст оповещения:

```sql
messageType = 'alert'
```

Также поддерживаются логические выражения и функции. Например, это позволяет различать сообщения по уровню серьезности:

```sql
messageType = 'alerts' AND as_number(severity) <= 2
```

Полный список поддерживаемых операторов и функций вы найдете в разделе [Выражения и условия][lnk-query-expressions].

### <a name="routing-on-message-bodies"></a>Маршрутизация по тексту сообщений

Центр Интернета вещей поддерживает маршрутизацию на основе содержимого текста сообщения, только если текст сообщения соответствует формату JSON в кодировке UTF-8, UTF-16 или UTF-32. Задайте тип содержимого сообщения `application/json`. В качестве кодировки содержимого сообщения необходимо задать одну из поддерживаемых кодировок UTF в заголовках сообщения. Если один из заголовков не указан, Центр Интернета вещей не будет пытаться вычислить любое выражение запроса, включающее текст, по сообщению. Если формат сообщения отличается от JSON или сообщение не указывает тип и кодировку содержимого, маршрутизацию сообщений, тем не менее, можно выполнить на основе заголовков сообщения.

В следующем примере показано, как создать сообщение с правильно форматированным и закодированным текстом JSON.

```csharp
string messageBody = @"{ 
                            ""Weather"":{ 
                                ""Temperature"":50, 
                                ""Time"":""2017-03-09T00:00:00.000Z"", 
                                ""PrevTemperatures"":[ 
                                    20, 
                                    30, 
                                    40 
                                ], 
                                ""IsEnabled"":true, 
                                ""Location"":{ 
                                    ""Street"":""One Microsoft Way"", 
                                    ""City"":""Redmond"", 
                                    ""State"":""WA"" 
                                }, 
                                ""HistoricalData"":[ 
                                    { 
                                    ""Month"":""Feb"", 
                                    ""Temperature"":40 
                                    }, 
                                    { 
                                    ""Month"":""Jan"", 
                                    ""Temperature"":30 
                                    } 
                                ] 
                            } 
                        }"; 
 
// Encode message body using UTF-8 
byte[] messageBytes = Encoding.UTF8.GetBytes(messageBody); 
 
using (var message = new Message(messageBytes)) 
{ 
    // Set message body type and content encoding. 
    message.ContentEncoding = "utf-8"; 
    message.ContentType = "application/json"; 
 
    // Add other custom application properties.  
    message.Properties["Status"] = "Active";    
 
    await deviceClient.SendEventAsync(message); 
}
```

Для маршрутизации сообщения можно использовать `$body` в выражении запроса. В выражении запроса можно использовать простую ссылку на текст, ссылку на массив текста или несколько ссылок на текст. В выражении запроса можно также указывать сочетание ссылки на текст со ссылкой на заголовок сообщения. Например, все выражения, приведенные ниже, допустимы:

```sql
$body.Weather.HistoricalData[0].Month = 'Feb'
$body.Weather.Temperature = 50 AND $body.Weather.IsEnabled
length($body.Weather.Location.State) = 2
$body.Weather.Temperature = 50 AND Status = 'Active'
```

## <a name="basics-of-an-iot-hub-query"></a>Основные сведения о запросе Центра Интернета вещей
Каждый запрос Центра Интернета вещей состоит из предложений SELECT и FROM, а также необязательных предложений WHERE и GROUP BY. Каждый запрос выполняется для коллекции документов JSON, например двойников устройств. Предложение FROM указывает коллекцию документов, по которой будет выполняться итерация (**devices** или **devices.jobs**). Затем применяется фильтр в предложении WHERE. С использованием агрегации результаты этого шага сгруппированы, как указано в предложении GROUP BY. Для каждой группы создается строка, как указано в предложении SELECT.

```sql
SELECT <select_list>
FROM <from_specification>
[WHERE <filter_condition>]
[GROUP BY <group_specification>]
```

## <a name="from-clause"></a>Предложение FROM
Предложение **FROM <из_спецификации>** может предоставить только два значения: **FROM devices** для запроса двойников устройства или **FROM devices.jobs** для запроса сведений о задании для каждого устройства.

## <a name="where-clause"></a>Предложение WHERE
Предложение **WHERE <условие_фильтрации>** является необязательным. Оно определяет одно или несколько условий, которым должны соответствовать документы JSON в коллекции FROM, чтобы быть включенными в результат. Любой документ JSON должен при вычислении указанных условий возвращать значение true, чтобы быть включенным в результат.

Допустимые условия описаны в разделе [Выражения и условия][lnk-query-expressions].

## <a name="select-clause"></a>Предложение SELECT
Предложение **SELECT <список_для_выбора>** является обязательным. Оно указывает значения, которые будут получены из запроса. Здесь задаются значения JSON, которые используются для создания новых объектов JSON.
На этапе проекции для каждого элемента, отфильтрованного (и при необходимости сгруппированного) подмножества коллекции FROM создается объект JSON. Этот объект собран из значений, которые указаны в предложении SELECT.

Далее приводится грамматика предложения SELECT:

```
SELECT [TOP <max number>] <projection list>

<projection_list> ::=
    '*'
    | <projection_element> AS alias [, <projection_element> AS alias]+

<projection_element> :==
    attribute_name
    | <projection_element> '.' attribute_name
    | <aggregate>

<aggregate> :==
    count()
    | avg(<projection_element>)
    | sum(<projection_element>)
    | min(<projection_element>)
    | max(<projection_element>)
```

**Attribute_name** относится к любому свойству документа JSON в коллекции FROM. Некоторые примеры предложений SELECT можно найти в разделе [Начало работы с запросами двойника устройства][lnk-query-getstarted].

В настоящее время предложения для осуществления выбора, отличные от **SELECT*** , поддерживаются только в статистических запросах к двойникам устройств.

## <a name="group-by-clause"></a>Предложение GROUP BY
Предложение **GROUP BY <спецификация_группирования>** является необязательным. Оно выполняется после фильтра, указанного в предложении WHERE, и перед проекцией, указанной в предложении SELECT. Оно группирует документы на основе значения атрибута. Эти группы используются для создания статистических значений, как указано в предложении SELECT.

Ниже представлен пример запроса с использованием предложения GROUP BY:

```sql
SELECT properties.reported.telemetryConfig.status AS status,
    COUNT() AS numberOfDevices
FROM devices
GROUP BY properties.reported.telemetryConfig.status
```

Далее указан формальный синтаксис предложения GROUP BY:

```
GROUP BY <group_by_element>
<group_by_element> :==
    attribute_name
    | < group_by_element > '.' attribute_name
```

**Attribute_name** относится к любому свойству документа JSON в коллекции FROM.

В настоящее время предложение GROUP BY поддерживается только при запросе к двойникам устройств.

## <a name="expressions-and-conditions"></a>Выражения и условия
В общем *выражение*:

* возвращает экземпляр типа JSON (например, логическое значение, число, строка, массив или объект);
* определяется обработкой данных, поступающих из документа JSON устройства, и констант с помощью встроенных операторов и функций.

*Условия* — это выражения, результатом вычисления которых является логическое значение. Любая другая константа, отличная от логической **true**, считается **false**. Это правило включает значение **null**, **не определено**, любой экземпляр объекта или массива, любую строку и логическое значение **false**.

Выражения имеют следующий синтаксис:

```
<expression> ::=
    <constant> |
    attribute_name |
    <function_call> |
    <expression> binary_operator <expression> |
    <create_array_expression> |
    '(' <expression> ')'

<function_call> ::=
    <function_name> '(' expression ')'

<constant> ::=
    <undefined_constant>
    | <null_constant>
    | <number_constant>
    | <string_constant>
    | <array_constant>

<undefined_constant> ::= undefined
<null_constant> ::= null
<number_constant> ::= decimal_literal | hexadecimal_literal
<string_constant> ::= string_literal
<array_constant> ::= '[' <constant> [, <constant>]+ ']'
```

Чтобы понять, что означает каждый символ в синтаксисе выражений, ознакомьтесь со следующей таблицей:

| Знак | Определение |
| --- | --- |
| attribute_name | Любое свойство документа JSON в коллекции **FROM**. |
| binary_operator | Любой бинарный оператор, перечисленный в разделе [Операторы](#operators). |
| function_name| Любая функция, перечисленная в разделе [Функции](#functions). |
| decimal_literal |Число с плавающей запятой в десятичном представлении. |
| hexadecimal_literal |Число, представленное строкой 0x, за которой следует строка с шестнадцатеричными цифрами. |
| string_literal |Строковые литералы — это строки Юникода, представленные в виде последовательности из нуля или более знаков Юникода или escape-последовательностей. Строковые литералы заключаются в одинарные или двойные кавычки. В знаках Юникода, определяемых 4 шестнадцатеричными цифрами, разрешено использовать escape-символы `\'`, `\"`, `\\` и `\uXXXX`. |

### <a name="operators"></a>Операторы
Поддерживаются следующие операторы:

| Семейство | Операторы |
| --- | --- |
| Арифметические |+, -, *, /, % |
| Логические |AND, OR, NOT |
| Сравнение |=, !=, <, >, <=, >=, <> |

### <a name="functions"></a>Функции Azure
В запросах двойников и заданий поддерживается только одна функция.

| Функция | ОПИСАНИЕ |
| -------- | ----------- |
| IS_DEFINED(Свойство) | Возвращает логическое значение, указывающее, назначено ли свойству значение (в том числе значение `null`). |

В условиях маршрута поддерживаются следующие математические функции.

| Функция | ОПИСАНИЕ |
| -------- | ----------- |
| ABS(x) | Возвращает модуль (положительное значение) указанного числового выражения. |
| EXP(x) | Возвращает значение экспоненты для указанного числового выражения (e^x). |
| POWER(x,y) | Возвращает результат возведения указанного числового выражения в заданную степень (x^y).|
| SQUARE(x) | Возвращает квадратный корень из указанного числового значения. |
| CEILING(x) | Возвращает наименьшее целочисленное значение, которое больше или равно указанному числовому выражению. |
| FLOOR(x) | Возвращает наибольшее целочисленное значение, которое меньше или равно указанному числовому выражению. |
| SIGN(x) | Возвращает знак указанного числового выражения (+1 для положительных чисел, 0 для нуля или -1 для отрицательных).|
| SQRT(x) | Возвращает квадратный корень из указанного числового значения. |

В условиях маршрута поддерживаются следующие функции проверки и приведения типов.

| Функция | ОПИСАНИЕ |
| -------- | ----------- |
| AS_NUMBER | Преобразует входную строку в число. Возвращает `noop`, если аргумент является числом, или `Undefined`, если строка не представляет число.|
| IS_ARRAY | Возвращает логическое значение, указывающее, является ли указанное выражение массивом. |
| IS_BOOL | Возвращает логическое значение, указывающее, является ли указанное выражение логическим значением. |
| IS_DEFINED | Возвращает логическое значение, указывающее, назначено ли свойству значение. |
| IS_NULL | Возвращает логическое значение, указывающее, является ли указанное выражение значением Null. |
| IS_NUMBER | Возвращает логическое значение, указывающее, является ли указанное выражение числовым значением. |
| IS_OBJECT | Возвращает логическое значение, указывающее, является ли указанное выражение объектом JSON. |
| IS_PRIMITIVE | Возвращает логическое значение, указывающее, является ли указанное выражение примитивом (строкой, логическим значением, числовым значением или `null`). |
| IS_STRING | Возвращает логическое значение, указывающее, является ли указанное выражение строковым значением. |

В условиях маршрутов поддерживаются следующие строковые функции.

| Функция | ОПИСАНИЕ |
| -------- | ----------- |
| CONCAT(x, y, …) | Возвращает строку, являющуюся результатом объединения двух или более строковых значений. |
| LENGTH(x) | Возвращает число символов указанного строкового выражения.|
| LOWER(x) | Возвращает строковое выражение после преобразования символов верхнего регистра в нижний. |
| UPPER(x) | Возвращает строковое выражение после преобразования символов нижнего регистра в верхний. |
| SUBSTRING(строка, начало[, длина]) | Возвращает часть строкового выражения, начиная с указанной позиции (отсчет начинается с нуля) и до достижения указанной длины (или до конца строки). |
| INDEX_OF(строка, фрагмент) | Возвращает начальную позицию первого вхождения второго строкового выражения в первое указанное строковое выражение или –1, если строка не найдена.|
| STARTS_WITH(x, y) | Возвращает значение логического типа, указывающее, начинается ли первое строковое выражение вторым. |
| ENDS_WITH(x, y) | Возвращает значение логического типа, указывающее, заканчивается ли первое строковое выражение вторым. |
| CONTAINS(x,y) | Возвращает значение логического типа, указывающее, содержит ли первое строковое выражение второе. |

## <a name="next-steps"></a>Дополнительная информация
Узнайте, как выполнять запросы в своих приложениях с помощью [пакетов SDK для Azure IoT][lnk-hub-sdks].

[lnk-query-where]: iot-hub-devguide-query-language.md#where-clause
[lnk-query-expressions]: iot-hub-devguide-query-language.md#expressions-and-conditions
[lnk-query-getstarted]: iot-hub-devguide-query-language.md#get-started-with-device-twin-queries

[lnk-twins]: iot-hub-devguide-device-twins.md
[lnk-jobs]: iot-hub-devguide-jobs.md
[lnk-devguide-endpoints]: iot-hub-devguide-endpoints.md
[lnk-devguide-quotas]: iot-hub-devguide-quotas-throttling.md
[lnk-devguide-mqtt]: iot-hub-mqtt-support.md
[lnk-devguide-messaging-routes]: iot-hub-devguide-messages-read-custom.md
[lnk-devguide-messaging-format]: iot-hub-devguide-messages-construct.md
[lnk-devguide-messaging-routes]: ./iot-hub-devguide-messages-read-custom.md

[lnk-hub-sdks]: iot-hub-devguide-sdks.md
