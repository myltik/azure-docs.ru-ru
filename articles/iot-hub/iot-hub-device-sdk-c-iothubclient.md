---
title: Пакет SDK для устройств Azure IoT для C — IoTHubClient | Документация Майкрософт
description: Узнайте, как использовать библиотеку IoTHubClient в пакете SDK для устройств Azure IoT для C и как создавать приложения для устройств, взаимодействующие с Центром Интернета вещей.
author: yzhong94
manager: arjmands
ms.service: iot-hub
services: iot-hub
ms.devlang: c
ms.topic: conceptual
ms.date: 08/29/2017
ms.author: yizhon
ms.openlocfilehash: 15541c8719e89080ba7685781cedf36fb4335e70
ms.sourcegitcommit: 266fe4c2216c0420e415d733cd3abbf94994533d
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/01/2018
ms.locfileid: "34633100"
---
# <a name="azure-iot-device-sdk-for-c--more-about-iothubclient"></a>Пакет SDK для устройств Azure IoT для C — дополнительные сведения о библиотеке IoTHubClient
В [первой статье](iot-hub-device-sdk-c-intro.md) этого курса вы познакомились с **пакетом SDK для устройств Azure IoT для C**. В ней объяснялось, что в пакете SDK есть два архитектурных уровня. В основе лежит библиотека **IoTHubClient**, которая непосредственно управляет связью с Центром Интернета вещей. На втором уровне находится библиотека **serializer** , которая реализована поверх упомянутой выше и предоставляет службы сериализации. В данной статье мы раскроем дополнительные подробности о библиотеке **IoTHubClient** .

[!INCLUDE [iot-hub-basic](../../includes/iot-hub-basic-partial.md)]

В предыдущей статье мы рассказали, как с помощью библиотеки **IoTHubClient** отправлять события в Центр Интернета вещей и получать из него сообщения. В данной статье продолжается обсуждение этой темы. Мы объясним, как можно с большей точностью управлять *временем* отправки и получения данных, используя **интерфейсы API нижнего уровня**. Также мы объясним, как прикреплять свойства к событиям (и извлекать их из сообщений) с помощью функций обработки свойств в библиотеке **IoTHubClient**. Кроме того, мы предоставим дополнительное описание различных способов обработки сообщений, полученных из Центра Интернета вещей.

В конце статьи будет раскрыто несколько других тем, в частности дополнительные сведения об учетных данных устройства и о том, как изменять поведение **IoTHubClient** через параметры конфигурации.

Чтобы раскрыть эти темы на должном уровне, мы будем использовать образцы из пакета SDK для библиотеки **IoTHubClient**. Если вы хотите сразу же проверять все, о чем мы рассказываем, найдите приложения **iothub\_client\_sample\_http** и **iothub\_client\_sample\_amqp**. Они входят в пакет SDK для устройств Azure IoT для C. Все, что описано в следующих разделах, продемонстрировано именно в этих примерах.

[**Пакет SDK для устройств Интернета вещей Azure для C**](https://github.com/Azure/azure-iot-sdk-c) доступен в репозитории на сайте GitHub. Дополнительные сведения об API см. в [справочной документации по API для C](https://azure.github.io/azure-iot-sdk-c/index.html).

## <a name="the-lower-level-apis"></a>Интерфейсы API нижнего уровня
В предыдущей статье были описаны основные операции библиотеки **IotHubClient** в контексте приложения **iothub\_client\_sample\_amqp**. В частности, в ней объяснялось, как инициализировать библиотеку с помощью следующего кода.

```
IOTHUB_CLIENT_HANDLE iotHubClientHandle;
iotHubClientHandle = IoTHubClient_CreateFromConnectionString(connectionString, AMQP_Protocol);
```

В ней также было описано, как отправлять события с помощью следующего вызова функции.

```
IoTHubClient_SendEventAsync(iotHubClientHandle, message.messageHandle, SendConfirmationCallback, &message);
```

Также в статье описано, как получать сообщения путем регистрации функции обратного вызова.

```
int receiveContext = 0;
IoTHubClient_SetMessageCallback(iotHubClientHandle, ReceiveMessageCallback, &receiveContext);
```

В статье также показано, как освободить ресурсы с помощью следующего кода.

```
IoTHubClient_Destroy(iotHubClientHandle);
```

Для каждого из этих интерфейсов API существуют сопутствующие функции:

* IoTHubClient\_LL\_CreateFromConnectionString
* IoTHubClient\_LL\_SendEventAsync
* IoTHubClient\_LL\_SetMessageCallback
* IoTHubClient\_LL\_Destroy

В имени API всех этих функций содержатся символы LL (Lower Level — нижний уровень). За исключением этого, параметры каждой из этих функций идентичны их аналогам без символов LL. Однако в работе этих функций есть одна важная особенность.

При вызове **IoTHubClient\_CreateFromConnectionString** базовые библиотеки создают новый поток, выполняемый в фоновом режиме. Этот поток отправляет события в Центр Интернета вещей и принимает сообщения из него. При работе с интерфейсами API нижнего уровня (LL) такой поток не создается. Создание фонового потока — это удобный инструмент для разработчиков. Вам не нужно беспокоиться о явной отправке событий и получении сообщений из Центра Интернета вещей — это происходит автоматически в фоновом режиме. Напротив, интерфейсы API нижнего уровня (LL) позволяют контролировать обмен данными с Центром Интернета вещей, если это необходимо.

Чтобы лучше понять это, рассмотрим пример.

При вызове **IoTHubClient\_SendEventAsync** вы фактически помещаете событие в буфер. Фоновый поток, созданный при вызове **IoTHubClient\_CreateFromConnectionString**, постоянно отслеживает этот буфер и отправляет любые содержащиеся в нем данные в Центр Интернета вещей. Это происходит в фоновом режиме в то же время, когда основной поток выполняет другую работу.

Аналогичным образом, когда вы регистрируете функцию обратного вызова для сообщений с помощью **IoTHubClient\_SetMessageCallback**, вы указываете пакету SDK, что фоновый поток должен вызвать функцию обратного вызова, когда будет получено сообщение, независимо от того, что в это время будет делать основной поток.

Интерфейсы API нижнего уровня не создают фоновый поток. Вместо этого для явной отправки и получения данных из Центра Интернета вещей необходимо вызывать новый интерфейс API. Это продемонстрировано в следующем примере.

Приложение **iothub\_client\_sample\_http**, включенное в пакет SDK, демонстрирует интерфейсы API нижнего уровня. В этом примере мы отправляем события в Центр Интернета вещей с помощью кода, аналогичного приведенному ниже.

```
EVENT_INSTANCE message;
sprintf_s(msgText, sizeof(msgText), "Message_%d_From_IoTHubClient_LL_Over_HTTP", i);
message.messageHandle = IoTHubMessage_CreateFromByteArray((const unsigned char*)msgText, strlen(msgText));

IoTHubClient_LL_SendEventAsync(iotHubClientHandle, message.messageHandle, SendConfirmationCallback, &message)
```

Первые три строки создают сообщение, а последняя строка отправляет событие. Тем не менее, как было сказано ранее, "отправка" события означает, что данные просто помещаются в буфер. При вызове **IoTHubClient\_LL\_SendEventAsync** ничего не передается по сети. Чтобы фактически передать данные в Центр Интернета вещей, необходимо вызвать **IoTHubClient\_LL\_DoWork**, как в следующем примере:

```
while (1)
{
    IoTHubClient_LL_DoWork(iotHubClientHandle);
    ThreadAPI_Sleep(1000);
}
```

Этот код (из приложения **iothub\_client\_sample\_http**) многократно вызывает функцию **IoTHubClient\_LL\_DoWork**. При каждом вызове функции **IoTHubClient\_LL\_DoWork** она отправляет некоторые события из буфера в Центр Интернета вещей и получает сообщение из очереди, отправляемое на устройство. В последнем случае это означает, что если мы зарегистрировали функцию обратного вызова для сообщений, то выполняется обратный вызов (предполагается, что в очереди есть сообщения). Такую функцию обратного вызова мы зарегистрируем с помощью следующего кода:

```
IoTHubClient_LL_SetMessageCallback(iotHubClientHandle, ReceiveMessageCallback, &receiveContext)
```

Причина частого циклического вызова **IoTHubClient\_LL\_DoWork** в том, что при каждом вызове этой функции она отправляет *некоторые* буферизованные события в Центр Интернета вещей и извлекает *следующее* сообщение из очереди для устройства. Отправка всех буферизованных событий каждым вызовом или получение всех сообщений из очереди не гарантируется. Если вам нужно отправить все события из буфера, а затем заняться другой обработкой, замените этот цикл следующим кодом.

```
IOTHUB_CLIENT_STATUS status;

while ((IoTHubClient_LL_GetSendStatus(iotHubClientHandle, &status) == IOTHUB_CLIENT_OK) && (status == IOTHUB_CLIENT_SEND_STATUS_BUSY))
{
    IoTHubClient_LL_DoWork(iotHubClientHandle);
    ThreadAPI_Sleep(1000);
}
```

Этот код вызывает **IoTHubClient\_LL\_DoWork** до тех пор, пока все события из буфера не будут отправлены в Центр Интернета вещей. Обратите внимание, что это не означает, что все сообщения из очереди получены. Отчасти это объясняется тем, что проверка «всех» сообщений не является настолько детерминированным действием. Что происходит при извлечении «всех» сообщений и отправке другого сообщения на устройство непосредственно после этого? Лучше такие моменты решать через запрограммированное время ожидания. Например, функция обратного вызова сообщений может сбрасывать таймер при каждом вызове. Затем можно написать логику для продолжения обработки, если, например, ни одно сообщение не было получено за последние *X* секунд.

После завершения передачи событий и получения сообщений не забудьте вызвать функцию для очистки ресурсов.

```
IoTHubClient_LL_Destroy(iotHubClientHandle);
```

По сути существует только один набор интерфейсов API для отправки и получения данных в фоновом потоке и другой набор интерфейсов API, который делает то же самое без фонового потока. Многие разработчики предпочитают интерфейсы API, не относящие к нижнему уровню. Тем не менее, API нижнего уровня полезны, когда разработчику нужно контролировать передачу данных по сети. Например, некоторые устройства собирают данные в течение продолжительного периода и передают события только через заданные интервалы времени (скажем, раз в час или раз в день). Интерфейсы API нижнего уровня позволяют вам четко контролировать, когда будут отправляться и приниматься данные из Центра Интернета вещей. Другие разработчики отдадут предпочтение простоте интерфейсов API нижнего уровня. Все действия происходят в основном потоке, а не в фоновом режиме.

Выбрав ту или иную модель, обязательно используйте соответствующие интерфейсы API. Если вы начнете с вызова **IoTHubClient\_LL\_CreateFromConnectionString**, то в последующей работе используйте только соответствующие интерфейсы API нижнего уровня:

* IoTHubClient\_LL\_SendEventAsync
* IoTHubClient\_LL\_SetMessageCallback
* IoTHubClient\_LL\_Destroy
* IoTHubClient\_LL\_DoWork

И наоборот, если вы начали с **IoTHubClient\_CreateFromConnectionString**, то для любой дополнительной обработки используйте интерфейсы API, не относящиеся к нижнему уровню.

В пакете SDK для устройств Azure IoT для C найдите приложение **iothub\_client\_sample\_http**, в котором содержится полный пример использования интерфейсов API нижнего уровня. Приложение **iothub\_client\_sample\_amqp** служит полным примером использования интерфейсов API, не относящихся к нижнему уровню.

## <a name="property-handling"></a>Обработка свойств
До сих пор для описания отправки данных мы использовали текст сообщения. Рассмотрим для примера такой код:

```
EVENT_INSTANCE message;
sprintf_s(msgText, sizeof(msgText), "Hello World");
message.messageHandle = IoTHubMessage_CreateFromByteArray((const unsigned char*)msgText, strlen(msgText));
IoTHubClient_LL_SendEventAsync(iotHubClientHandle, message.messageHandle, SendConfirmationCallback, &message)
```

Этот код отправляет в Центр Интернета вещей сообщение с текстом "Hello World". Но Центр Интернета вещей также позволяет к каждому сообщению прикреплять свойства. Свойства — это пары "имя-значение", которые можно присоединять к сообщению. Например, мы можем прикрепить свойство к сообщению, изменив приведенный выше код.

```
MAP_HANDLE propMap = IoTHubMessage_Properties(message.messageHandle);
sprintf_s(propText, sizeof(propText), "%d", i);
Map_AddOrUpdate(propMap, "SequenceNumber", propText);
```

Сначала мы вызываем функцию **IoTHubMessage\_Properties** и передаем ей дескриптор сообщения. Обратно мы получаем ссылку **MAP\_HANDLE**, которая позволяет добавлять свойства. Для добавления свойств мы вызываем метод **Map\_AddOrUpdate**, который принимает ссылку на MAP\_HANDLE, имя свойства и значение свойства. С помощью этого API мы можем добавить сколько угодно свойств.

Когда событие считывается из **концентраторов событий**, получатель может перечислить свойства и извлечь их соответствующие значения. Например, в среде .NET это можно реализовать путем обращения к [коллекции свойств в объекте EventData](https://msdn.microsoft.com/library/azure/microsoft.servicebus.messaging.eventdata.properties.aspx).

В предыдущем примере мы прикрепляем свойства к событию, которое отправляем в Центр Интернета вещей. Свойства можно также прикреплять к сообщениям, получаемым из Центра Интернета вещей. Чтобы извлечь свойства из сообщения, в функции обратного вызова сообщения используйте код, подобный указанному ниже.

```
static IOTHUBMESSAGE_DISPOSITION_RESULT ReceiveMessageCallback(IOTHUB_MESSAGE_HANDLE message, void* userContextCallback)
{
    . . .

    // Retrieve properties from the message
    MAP_HANDLE mapProperties = IoTHubMessage_Properties(message);
    if (mapProperties != NULL)
    {
        const char*const* keys;
        const char*const* values;
        size_t propertyCount = 0;
        if (Map_GetInternals(mapProperties, &keys, &values, &propertyCount) == MAP_OK)
        {
            if (propertyCount > 0)
            {
                printf("Message Properties:\r\n");
                for (size_t index = 0; index < propertyCount; index++)
                {
                    printf("\tKey: %s Value: %s\r\n", keys[index], values[index]);
                }
                printf("\r\n");
            }
        }
    }

    . . .
}
```

Вызов **IoTHubMessage\_Properties** возвращает ссылку **MAP\_HANDLE**, которую мы передаем в метод **Map\_GetInternals**, чтобы получить ссылку на массив пар "имя-значение" (и количество свойств). На этом этапе для получения нужных значений достаточно просто перебрать свойства.

Использовать свойства в приложении не обязательно, но если вам нужно указывать их для событий или получать из сообщений, с библиотекой **IoTHubClient** сделать это будет просто.

## <a name="message-handling"></a>Обработка сообщений
Как упоминалось ранее, когда сообщения поступают из Центра Интернета вещей, библиотека **IoTHubClient** отвечает вызовом зарегистрированной функции обратного вызова. У этой функции есть параметр возврата, который требует дополнительного пояснения. Вот фрагмент функции обратного вызова из приложения **iothub\_client\_sample\_http**:

```
static IOTHUBMESSAGE_DISPOSITION_RESULT ReceiveMessageCallback(IOTHUB_MESSAGE_HANDLE message, void* userContextCallback)
{
    . . .
    return IOTHUBMESSAGE_ACCEPTED;
}
```

Обратите внимание, что тип возврата — **IOTHUBMESSAGE\_DISPOSITION\_RESULT**, а в данном случае мы возвращаем **IOTHUBMESSAGE\_ACCEPTED**. Из этой функции мы можем возвращать другие значения, которые изменяют способ реакции библиотеки **IoTHubClient** на обратный вызов сообщения. Вот эти другие значения:

* **IOTHUBMESSAGE\_ACCEPTED** — сообщение успешно обработано. Библиотека **IoTHubClient** не будет вызывать функцию обратного вызова еще раз для того же сообщения.
* **IOTHUBMESSAGE\_REJECTED** — сообщение не обработано и обрабатываться не будет. Библиотеке **IoTHubClient** не нужно вызывать функцию обратного вызова еще раз для того же сообщения.
* **IOTHUBMESSAGE\_ABANDONED** — сообщение не было обработано успешно, но библиотека **IoTHubClient** должна вызвать функцию обратного вызова еще раз для того же сообщения.

Для первых двух кодов возврата библиотека **IoTHubClient** отправляет сообщение в Центр Интернета вещей, указывая, что сообщение следует удалить из очереди устройства и не доставлять повторно. Совокупный эффект оказывается таким же (сообщение удаляется из очереди устройства), но все так же делается запись о том, было ли сообщение принято или отклонено.  Такая запись полезна для отправителей сообщения, которые принимают обратную связь, чтобы выяснить, приняло ли устройство определенное сообщение или отклонило.

Если сообщение отклонено, оно также отправляется в Центр Интернета вещей, но при этом указывается, что сообщение следует доставить повторно. Обычно отказ от сообщения выполняется тогда, когда возникла какая-то ошибка, но при этом то же сообщение нужно попытаться обработать снова. С другой стороны, отклонение сообщения уместно при возникновении неустранимой ошибки (или если вы просто определили, что это сообщение не нужно обрабатывать).

В любом случае помните о различных кодах возврата, позволяющих обеспечить требуемое поведение библиотеки **IoTHubClient**.

## <a name="alternate-device-credentials"></a>Альтернативные учетные данные устройств
Как отмечалось ранее, первое, что необходимо сделать при работе с библиотекой **IoTHubClient**, — получить дескриптор **IOTHUB\_CLIENT\_HANDLE** с помощью такого вызова:

```
IOTHUB_CLIENT_HANDLE iotHubClientHandle;
iotHubClientHandle = IoTHubClient_CreateFromConnectionString(connectionString, AMQP_Protocol);
```

Аргументами **IoTHubClient\_CreateFromConnectionString** выступают строка подключения устройства и параметр, указывающий протокол, который используется для связи с Центром Интернета вещей. Строка подключения для устройства имеет следующий формат.

```
HostName=IOTHUBNAME.IOTHUBSUFFIX;DeviceId=DEVICEID;SharedAccessKey=SHAREDACCESSKEY
```

В этой строке указаны четыре значения: имя центра Интернета вещей, суффикс центра IoT, идентификатор устройства и ключ общего доступа. При создании экземпляра центра IoT на портале Azure вы получаете полное доменное имя (FQDN) центра IoT. Из этого имени мы получаем имя центра IoT (первая часть FQDN) и суффикс центра IoT (остальная часть FQDN). Идентификатор устройства и общий ключ доступа получаются при регистрации устройства в Центре Интернета вещей (см. [предыдущую статью](iot-hub-device-sdk-c-intro.md)).

**IoTHubClient\_CreateFromConnectionString** — это всего лишь один из способов инициализации библиотеки. При желании вы можете создать дескриптор **IOTHUB\_CLIENT\_HANDLE**, используя вместо строки подключения устройства отдельные параметры. Для этого используется такой код:

```
IOTHUB_CLIENT_CONFIG iotHubClientConfig;
iotHubClientConfig.iotHubName = "";
iotHubClientConfig.deviceId = "";
iotHubClientConfig.deviceKey = "";
iotHubClientConfig.iotHubSuffix = "";
iotHubClientConfig.protocol = HTTP_Protocol;
IOTHUB_CLIENT_HANDLE iotHubClientHandle = IoTHubClient_LL_Create(&iotHubClientConfig);
```

Этот код выполняет то же самое, что и **IoTHubClient\_CreateFromConnectionString**.

Вы, вероятно, решите, что использовать **IoTHubClient\_CreateFromConnectionString** удобнее, чем такой подробный метод инициализации. Но не стоит забывать, что при регистрации устройства в Центре Интернета вещей вы получаете только идентификатор и ключ устройства (а не строку подключения). Пакет SDK для *обозревателя устройств*, который мы упоминали в [предыдущей статье](iot-hub-device-sdk-c-intro.md), создает строку подключения устройства на основе идентификатора и ключа устройства, а также имени узла Центра Интернета вещей с помощью библиотек из **пакета SDK для служб Azure IoT**. Поэтому метод с вызовом **IoTHubClient\_LL\_Create** может быть предпочтительнее, так как он позволяет исключить этап создания строки подключения. Используйте тот метод, который для вас удобнее.

## <a name="configuration-options"></a>Варианты настройки
До сих пор все описываемые способы работы библиотеки **IoTHubClient** отражали ее стандартное поведение. Однако существует несколько параметров, позволяющих изменить то, как работает библиотека. Для этого используется API **IoTHubClient\_LL\_SetOption**. Рассмотрим следующий пример.

```
unsigned int timeout = 30000;
IoTHubClient_LL_SetOption(iotHubClientHandle, "timeout", &timeout);
```

Существует несколько часто используемых параметров:

* **SetBatching** (логическое значение). Если значение равно **true**, то данные, отправляемые в Центр Интернета вещей, передаются пакетами. При значении **false** сообщения отправляются по отдельности. Значение по умолчанию — **false**. Обратите внимание, что параметр **SetBatching** применяется только для протокола HTTPS, а не для MQTT и AMQP.
* **Timeout** (целое число без знака). Это значение указывается в миллисекундах. Если отправка HTTPS-запроса или прием ответа выполняется дольше этого времени, время ожидания соединения заканчивается.

Параметр пакетной обработки является важным параметром. По умолчанию библиотека передает события по отдельности (одно событие — это то, что вы передаете в **IoTHubClient\_LL\_SendEventAsync**). Если параметр пакетной обработки имеет значение **true**, библиотека собирает из буфера максимально возможное количество событий (вплоть до максимального размера сообщения, который принимается Центром Интернета вещей).  Пакет событий отправляется в Центр Интернета вещей за один вызов HTTPS (отдельные события объединяются в массив JSON). Включение пакетной обработки обычно позволяет существенно увеличить производительность, так как уменьшается число сетевых круговых путей. При этом также существенно экономится пропускная способность, так как вы отправляете с пакетом событий только один набор заголовков HTTPS, а не набор заголовков для каждого отдельного события. Мы рекомендуем включать пакетную обработку при условии, что у вас нет веских причин поступать иначе.

## <a name="next-steps"></a>Дополнительная информация
В этой статье подробно описывается работа библиотеки **IoTHubClient**, содержащейся в **пакете SDK для устройств Azure IoT для C**. Эти сведения позволят вам хорошо изучить возможности библиотеки **IoTHubClient**. В [следующей статье](iot-hub-device-sdk-c-serializer.md) мы подробно расскажем о библиотеке **serializer** .

Дополнительные сведения о разработке для Центра Интернета вещей см. в статье [Пакеты SDK для Центра Интернета вещей][lnk-sdks].

Для дальнейшего изучения возможностей Центра Интернета вещей см. следующие статьи:

* [Развертывание ИИ на пограничных устройствах с использованием Azure IoT Edge][lnk-iotedge]

[lnk-sdks]: iot-hub-devguide-sdks.md

[lnk-iotedge]: ../iot-edge/tutorial-simulate-device-linux.md
