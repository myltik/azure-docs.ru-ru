---
title: Жизненный цикл Reliable Services в Azure Service Fabric | Документация Майкрософт
description: Сведения о событиях жизненного цикла служб Reliable Services в Service Fabric.
services: service-fabric
documentationcenter: java
author: PavanKunapareddyMSFT
manager: timlt
ms.assetid: ''
ms.service: service-fabric
ms.devlang: java
ms.topic: conceptual
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 06/30/2017
ms.author: pakunapa
ms.openlocfilehash: cc89d174a201b38d79c7993d548c8eac4a47fbcb
ms.sourcegitcommit: eb75f177fc59d90b1b667afcfe64ac51936e2638
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/16/2018
ms.locfileid: "34210687"
---
# <a name="reliable-services-lifecycle"></a>Жизненный цикл Reliable Services
> [!div class="op_single_selector"]
> * [C# в Windows](service-fabric-reliable-services-lifecycle.md)
> * [Java в Linux](service-fabric-reliable-services-lifecycle-java.md)
>
>

Reliable Services являются одной из моделей программирования, доступных в Azure Service Fabric. При изучении жизненного цикла Reliable Services наиболее важно разобраться с его основными событиями. Точный порядок событий зависит от сведений о конфигурации. 

Как правило, жизненный цикл Reliable Services включает следующие события:

* Во время запуска:
  * создаются службы;
  * службы могут создавать и возвращать ни одного или несколько прослушивателей;
  * все возвращаемые прослушиватели открываются для взаимодействия со службой;
  * вызывается метод `runAsync` службы, позволяя службе выполнять длительную или фоновую работу.
* Во время завершения работы:
  * токен отмены, переданный в `runAsync`, отменяется и прослушиватели закрываются;
  * уничтожается сам объект службы.

Порядок событий в Reliable Services может немного изменяться в зависимости от того, предусматривают ли Reliable Services отслеживание состояния. 

В случае со службами с отслеживанием состояния нужно иметь дело со сценарием переключения первичной реплики. Во время этой процедуры первичная роль передается другой реплике (или возвращается) без завершения работы службы. 

И наконец, следует учитывать условия ошибок и сбоев.

## <a name="stateless-service-startup"></a>Запуск службы без отслеживания состояния
Жизненный цикл службы без отслеживания состояния достаточно прост. Ниже приведен порядок событий.

1. Создается служба.
2. Эти события происходят в параллельном режиме:
    - Вызывается метод `StatelessService.createServiceInstanceListeners()` и открываются все возвращаемые прослушиватели. Для каждого прослушивателя вызывается метод `CommunicationListener.openAsync()`.
    - Вызывается метод (`StatelessService.runAsync()`) службы `runAsync`.
3. При наличии вызывается собственный метод `onOpenAsync` службы. В частности, вызывается `StatelessService.onOpenAsync()`. Это редко используемое переопределение, но оно доступно.

Важно отметить, что между вызовами методов для создания и открытия прослушивателей и метода `runAsync` нет упорядоченности. Прослушиватели могут быть открыты перед запуском `runAsync`. Аналогичным образом метод `runAsync` может быть вызван перед открытием или созданием прослушивателей связи. Если необходима синхронизация, ее должен выполнить разработчик. Ниже приведены некоторые распространенные решения.

* Иногда прослушиватели не могут работать, пока не будут сформированы другие сведения или выполнены некоторые задачи. Для службы без отслеживания состояния такие задачи обычно могут выполняться в конструкторе службы во время вызова `createServiceInstanceListeners()` или в рамках создания самого прослушивателя.
* Иногда код в `runAsync` не запускается, пока прослушиватели открыты. В этом случае необходима дополнительная координация. Распространенным решением является добавление флага в прослушиватели. Флаг указывает время завершения их работы. Метод `runAsync` проверяет это, прежде чем будет продолжена фактическая работа.

## <a name="stateless-service-shutdown"></a>Завершение работы службы без отслеживания состояния
При завершении работы службы без отслеживания состояния те же операции выполняются в обратном порядке.

1. Эти события происходят в параллельном режиме:
    - Закрываются все открытые прослушиватели. Для каждого прослушивателя вызывается метод `CommunicationListener.closeAsync()`.
    - Токен отмены, переданный в `runAsync()`, отменяется. В результате проверки свойства `isCancelled` токена отмены возвращается значение `true`, а при вызове метода `throwIfCancellationRequested` токена возвращается `CancellationException`.
2. После завершения `closeAsync()` для каждого прослушивателя также завершается `runAsync()` и вызывается метод `StatelessService.onCloseAsync()` службы, если он присутствует. Опять же, обычно это не переопределяется, но позволяет безопасно закрыть все ресурсы, остановить все фоновые задачи, завершить сохранение внешнего состояния или закрыть существующие подключения.
3. После выполнения метода `StatelessService.onCloseAsync()` объект службы уничтожается.

## <a name="stateful-service-startup"></a>Запуск службы с отслеживанием состояния
Запуск службы с отслеживанием состояния имеет лишь несколько отличий по сравнению со службой без отслеживания состояния.  Далее приведен порядок событий для запуска службы с отслеживанием состояния:

1. Создается служба.
2. Вызывается метод `StatefulServiceBase.onOpenAsync()`. Этот вызов редко переопределяется в службе.
3. Эти события происходят в параллельном режиме:
    - Вызывается метод `StatefulServiceBase.createServiceReplicaListeners()`. 
      - Если служба является первичной, открываются все возвращенные прослушиватели. Для каждого прослушивателя вызывается метод `CommunicationListener.openAsync()`.
      - Если служба является вторичной, то открываются только прослушиватели, помеченные как `listenOnSecondary = true`. Открытые прослушиватели для вторичных служб используются реже.
    - Если сейчас служба является первичной, то вызывается метод `StatefulServiceBase.runAsync()` службы.
4. После завершения всех вызовов `openAsync()` прослушивателя реплик и вызова `runAsync()` вызывается `StatefulServiceBase.onChangeRoleAsync()`. Этот вызов редко переопределяется в службе.

Как и в случае со службами без отслеживания состояния, в службе с отслеживанием состояния между порядком, в котором прослушиватели создаются и открываются, и вызовом `runAsync` отсутствует координация. Если требуется координация, то решение будет во многом схожим. Однако для службы с отслеживанием состояния есть лишь одно дополнение. Предположим, что для вызовов, поступающих в прослушиватели связи, требуется наличие сведений в некоторых [надежных коллекциях](service-fabric-reliable-services-reliable-collections.md). Так как прослушиватели связи могут быть открыты до того, как надежные коллекции станут доступны для чтения или записи, а также до запуска `runAsync`, потребуется дополнительная координация. Простейшее и самое распространенное решение для прослушивателей связи — вернуть код ошибки. Клиент использует этот код для повторного запроса.

## <a name="stateful-service-shutdown"></a>Завершение работы службы с отслеживанием состояния
Как и в случае со службами без отслеживания состояния, события жизненного цикла во время завершения работы совпадают с событиями во время запуска, но происходят в обратном порядке. При завершении работы службы с отслеживанием состояния происходят следующие события.

1. Эти события происходят в параллельном режиме:
    - Закрываются все открытые прослушиватели. Для каждого прослушивателя вызывается метод `CommunicationListener.closeAsync()`.
    - Токен отмены, переданный в `runAsync()`, отменяется. При вызове метода `isCancelled()` токена отмены возвращается значение `true`, а при вызове метода `throwIfCancellationRequested()` токена возвращается `OperationCanceledException`.
2. Как только `closeAsync()` завершается для каждого прослушивателя, также завершается `runAsync()` и вызывается `StatefulServiceBase.onChangeRoleAsync()` службы. Этот вызов редко переопределяется в службе.

   > [!NOTE]  
   > Необходимо подождать завершения метода `runAsync`, если это первичная реплика.

3. После завершения метода `StatefulServiceBase.onChangeRoleAsync()` вызывается метод `StatefulServiceBase.onCloseAsync()`. Этот вызов представляет собой редко используемое переопределение, но оно доступно.
3. После выполнения метода `StatefulServiceBase.onCloseAsync()` объект службы уничтожается.

## <a name="stateful-service-primary-swaps"></a>Переключения первичной реплики службы с отслеживанием состояния
Во время выполнения службы с отслеживанием состояния прослушиватели связи открываются и вызывается метод `runAsync` только для первичных реплик служб с отслеживанием состояния. Вторичные реплики создаются, но не видят последующие вызовы. Пока выполняется служба с отслеживанием состояния, первичная реплика может измениться. События жизненного цикла, которые видит реплика с отслеживанием состояния, зависят от того, что происходит во время переключения: понижение или повышение уровня реплики.

### <a name="for-the-demoted-primary"></a>При понижении уровня первичной реплики
Для Service Fabric требуется первичная реплика с пониженным уровнем, чтобы остановить обработку сообщений и выполнение любой фоновой работы. Это выглядит аналогично завершению работы службы. Отличие в том, что служба не уничтожается и не закрывается, так как остается вторичной. После этого происходят следующие события:

1. Эти события происходят в параллельном режиме:
    - Закрываются все открытые прослушиватели. Для каждого прослушивателя вызывается метод `CommunicationListener.closeAsync()`.
    - Токен отмены, переданный в `runAsync()`, отменяется. В результате проверки метода `isCancelled()` токена отмены возвращается значение `true`. При вызове метода `throwIfCancellationRequested()` токена возвращается `OperationCanceledException`.
2. Как только `closeAsync()` завершается для каждого прослушивателя, также завершается `runAsync()` и вызывается `StatefulServiceBase.onChangeRoleAsync()` службы. Этот вызов редко переопределяется в службе.

### <a name="for-the-promoted-secondary"></a>При повышении уровня вторичной реплики
Аналогичным образом Service Fabric необходимо, чтобы вторичная реплика с повышенным уровнем начала ожидать передачи сообщений и запустила все фоновые задачи, которые необходимо выполнить. Это выглядит аналогично процессу создания службы. Разница в том, что сама реплика уже существует. После этого происходят следующие события:

1. Эти события происходят в параллельном режиме:
    - Вызывается метод `StatefulServiceBase.createServiceReplicaListeners()` и открываются все возвращаемые прослушиватели. Для каждого прослушивателя вызывается метод `CommunicationListener.openAsync()`.
    - Вызывается метод службы `StatefulServiceBase.runAsync()`.
2. После завершения всех вызовов `openAsync()` прослушивателя реплик и вызова `runAsync()` вызывается `StatefulServiceBase.onChangeRoleAsync()`. Этот вызов редко переопределяется в службе.

### <a name="common-issues-during-stateful-service-shutdown-and-primary-demotion"></a>Распространенные проблемы во время завершения работы службы с отслеживанием состояния и понижения уровня первичной реплики
Service Fabric изменяет первичную реплику службы с отслеживанием состояния по нескольким причинам. Наиболее распространенными из них являются [повторная балансировка кластера](service-fabric-cluster-resource-manager-balancing.md) и [обновление приложения](service-fabric-application-upgrade.md). Во время этих операций очень важно, чтобы служба учитывала `cancellationToken`. Это правило также применяется во время штатного завершения работы службы, например, как при ее удалении.

Службы, которые не обрабатывают отмену аккуратно, могут вызывать несколько проблем. Эти операции выполняются медленно, так как Service Fabric ожидает корректную остановку служб. В конечном счете это может привести к сбоям обновлений из-за истечения времени ожидания и откату. Если не использовать токен отмены, это может также нарушить балансировку кластеров. Кластеры становятся несбалансированными, потому что узлы нагружаются. Однако реорганизация служб невозможна, так как их перемещение занимает слишком много времени. 

Так как это службы с отслеживанием состояния, то, скорее всего, они используют [надежные коллекции](service-fabric-reliable-services-reliable-collections.md). Когда в Service Fabric понижается уровень первичной реплики, то в первую очередь отменяется доступ на запись к базовому состоянию. Это приводит ко второму ряду проблем, которые могут повлиять на жизненный цикл службы. Коллекции возвращают исключения на основании времени и операции с репликой (перемещение или завершение работы). Очень важно обрабатывать эти исключения правильно. 

Исключения, порождаемые Service Fabric, делятся на постоянные [(`FabricException`)](https://docs.microsoft.com/java/api/system.fabric.exception) и временные [(`FabricTransientException`)](https://docs.microsoft.com/java/api/system.fabric.exception._fabric_transient_exception). Постоянные исключения должны быть зарегистрированы в журнале и отброшены. Для временных исключений возможен повтор в соответствии с логикой повтора.

Обработка исключений, которые поступают от `ReliableCollections`, в сочетании с событиями жизненного цикла службы является важной частью тестирования и проверки Reliable Services. Мы рекомендуем всегда запускать службу с нагрузкой. Перед развертыванием в рабочей среде вам также необходимо выполнить обновления и [хаотическое тестирование](service-fabric-controlled-chaos.md). Эти простые действия помогут проверить правильность реализации службы и обработки событий жизненного цикла.

## <a name="notes-on-service-lifecycle"></a>Примечания о жизненном цикле службы
* Метод `runAsync()` и вызовы `createServiceInstanceListeners/createServiceReplicaListeners` являются необязательны. В службе может использоваться один из них, оба или ни одного. Например, если служба выполняет всю работу в ответ на вызовы пользователя, реализовывать метод `runAsync()` не нужно. Необходимы только прослушиватели связи и соответствующий код.  Создавать и возвращать прослушиватели связи необязательно. Служба может выполнять только фоновую работу, поэтому достаточно реализовать `runAsync()`.
* Она может успешно завершить `runAsync()` и вернуться из него. Это не является состоянием сбоя, а указывает на то, что фоновая работа службы выполнена. Для надежных служб с отслеживанием состояния метод `runAsync()` будет вызываться снова, если служба понижена с первичной, а затем обратно повышена.
* Если служба выполняет выход из `runAsync()`, порождая какое-либо непредвиденное исключение, произошел сбой. Объект службы завершает работу, и появляется ошибка о работоспособности.
* Несмотря на то что возвращение этих методов не ограничивается по времени, вы не сможете выполнять запись, а значит и выполнять какую-либо действительную задачу. После получения запроса на отмену рекомендуется возвращать методы как можно быстрее. Если служба не отвечает на такие вызовы API в течение приемлемого промежутка времени, Service Fabric может принудительно завершить работу службы. Обычно это происходит только во время обновления приложения или при удалении службы. По умолчанию время ожидания составляет 15 минут.
* Сбои в пути `onCloseAsync()` приводят к вызову `onAbort()`. Это является последней наилучшей возможностью для службы очистить и освободить все запрошенные ресурсы. Обычно такой вызов осуществляется при обнаружении на узле постоянной неисправности или когда платформа Service Fabric не может надежно управлять жизненным циклом экземпляра службы из-за внутренних сбоев.
* `OnChangeRoleAsync()` вызывается, когда реплика службы с отслеживанием состояния меняет роль, например с первичной на вторичную, или наоборот. Основным репликам присваивается статус записи (им разрешено создавать и записывать надежные коллекции), а дополнительным — статус чтения (могут только читать из существующих надежных коллекций). Большинство операций службы с отслеживанием состояния выполняется в основной реплике. Вторичные реплики могут выполнять проверку, предусматривающую только чтение, создавать отчеты, выполнять интеллектуальный анализ данных, а также другие задания, доступные только для чтения.

## <a name="next-steps"></a>Дополнительная информация
* [Обзор надежных служб](service-fabric-reliable-services-introduction.md)
* [Get started with Reliable Services](service-fabric-reliable-services-quick-start-java.md) (Начало работы с Reliable Services)

