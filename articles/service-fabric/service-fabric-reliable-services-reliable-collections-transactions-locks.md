---
title: Транзакции и режимы блокировки в надежных коллекциях Azure Service Fabric | Документы Майкрософт
description: Транзакции и блокировка диспетчера надежных состояний и надежных коллекций Azure Service Fabric.
services: service-fabric
documentationcenter: .net
author: mcoskun
manager: timlt
editor: masnider,rajak
ms.assetid: 62857523-604b-434e-bd1c-2141ea4b00d1
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: conceptual
ms.tgt_pltfrm: na
ms.workload: required
ms.date: 5/1/2017
ms.author: mcoskun
ms.openlocfilehash: 79be861a70abb0331d971b00e753691e77642637
ms.sourcegitcommit: eb75f177fc59d90b1b667afcfe64ac51936e2638
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/16/2018
ms.locfileid: "34207372"
---
# <a name="transactions-and-lock-modes-in-azure-service-fabric-reliable-collections"></a>Транзакции и режимы блокировки в надежных коллекциях Azure Service Fabric

## <a name="transaction"></a>транзакция:
Транзакция — это последовательность операций, выполняемых в одной логической единице работы.
Транзакция должна представлять приведенные ниже свойства ACID (см.: https://technet.microsoft.com/library/ms190612).
* **Атомарность**. Транзакция должна быть атомарной единицей работы. Другими словами, должны выполняться либо все ее изменения данных, либо ни одно из них.
* **Согласованность**. По завершении транзакция должна оставить все данные в согласованном состоянии. Все внутренние структуры данных должны быть правильными на момент завершения транзакции.
* **Изоляция**. Изменения, выполняемые одной параллельной транзакцией, должны быть изолированы от изменений, выполняемых прочими параллельными транзакциями. Уровень изоляции для операций в ITransaction определяется интерфейсом IReliableState, выполняющим операцию.
* **Устойчивость**. После завершения транзакции ее результаты постоянно сохраняются в системе. Изменения сохраняются даже в случае сбоя системы.

### <a name="isolation-levels"></a>Уровни изоляции
Уровень изоляции определяет степень, до которой транзакция должна быть изолирована от изменений, вносимых другими транзакциями.
Надежные коллекции поддерживают два уровня изоляции:

* **Повторяющееся чтение**. Указывает, какие операторы не могут считывать данные, которые были изменены, но еще не зафиксированы другими транзакциями, и что другие транзакции не могут изменять данные, считанные текущей транзакцией, до ее завершения. Дополнительные сведения см. по адресу [https://msdn.microsoft.com/library/ms173763.aspx](https://msdn.microsoft.com/library/ms173763.aspx).
* **Моментальный снимок**. Указывает, что данные, считанные любым оператором в транзакции, согласованы с версией данных, которые существовали в начале транзакции.
  Транзакция может распознать только те изменения данных, которые были зафиксированы до ее начала.
  Изменения данных, произведенные другими транзакциями после запуска текущей транзакции, будут невидны для инструкций, выполняемых в текущей транзакции.
  Это похоже на то, как если бы инструкции в транзакции получили снимок данных, зафиксированных на момент начала транзакции.
  Моментальные снимки согласованы между надежными коллекциями.
  Дополнительные сведения см. по адресу [https://msdn.microsoft.com/library/ms173763.aspx](https://msdn.microsoft.com/library/ms173763.aspx).

Для операций чтения надежные коллекции автоматически выбирают уровень изоляции в зависимости от самой операции и роли реплики в момент создания транзакции.
Ниже приведена таблица уровней изоляции по умолчанию для операций надежного словаря и очереди.

| Операция \ Роль | Первичная | Вторичная |
| --- |:--- |:--- |
| Операция чтения одной сущности |Повторяющаяся операция чтения |Снимок |
| Перечисление, подсчет |Снимок |Снимок |

> [!NOTE]
> Распространенные примеры операций с одной сущностью: `IReliableDictionary.TryGetValueAsync`, `IReliableQueue.TryPeekAsync`.
> 

Надежный словарь и надежная очередь поддерживают мгновенную целостность данных (Read Your Writes, RYW).
Другими словами, каждая операция записи в рамках одной транзакции будет видна для последующей операции чтения, которая выполняется в рамках той же транзакции.

## <a name="locks"></a>Блокировки
В надежных коллекциях все транзакции реализуют строгую двухэтапную блокировку: транзакция не снимает свои установленные блокировки, пока она не завершится прерыванием или фиксацией.

Надежный словарь использует блокировку уровня строки для всех операций с одной сущностью.
Надежная очередь поступается параллелизмом ради строгого соблюдения транзакционного свойства FIFO.
Надежная очередь использует блокировки уровня операции, позволяя одновременно выполнять одну транзакцию с `TryPeekAsync` и (или) `TryDequeueAsync` и одну транзакцию с `EnqueueAsync`.
Обратите внимание, что если `TryPeekAsync` или `TryDequeueAsync` когда-либо обнаружит, что надежная очередь пуста, то для сохранения логики FIFO также заблокирует `EnqueueAsync`.

Операции записи всегда используют монопольные блокировки.
Для операций чтения блокировка зависит от нескольких факторов.
В операциях чтения, выполняемых с уровнем изоляции "Снимок", блокировки не используются.
В повторяющихся операциях чтения используются совмещаемые блокировки (по умолчанию).
Тем не менее, для любой операции чтения, поддерживающей повторяющееся чтение, вместо совмещаемой блокировки пользователь может запросить блокировку изменений.
Блокировка изменений является асимметричной блокировкой, которая используется для предотвращения распространенной формы взаимоблокировки. Взаимоблокировка возникает, когда несколько транзакций блокируют ресурсы для возможного обновления в будущем.

Ниже приведена таблица совместимости блокировок.

| Запрос \ Предоставлено | Без блокировки | Совмещаемая блокировка | Блокировка изменений | Монопольная блокировка |
| --- |:--- |:--- |:--- |:--- |
| Совмещаемая блокировка |Нет конфликтов |Нет конфликтов |Конфликт |Конфликт |
| Блокировка изменений |Нет конфликтов |Нет конфликтов |Конфликт |Конфликт |
| Монопольная блокировка |Нет конфликтов |Конфликт |Конфликт |Конфликт |

В API надежных коллекций для обнаружения взаимоблокировок используется аргумент времени ожидания.
Например, две транзакции (Т1 и Т2) пытаются считать и изменить К1.
Существует вероятность возникновения взаимоблокировки, поскольку в обеих транзакциях используется совмещаемая блокировка.
В этом случае время ожидания для одной или обеих операций будет превышено.

Ситуация с взаимоблокировкой является хорошим примером того, как блокировка изменений может предотвратить возникновение взаимоблокировки.

## <a name="next-steps"></a>Дополнительная информация
* [Работа с Reliable Collections](service-fabric-work-with-reliable-collections.md)
* [Уведомления Reliable Services](service-fabric-reliable-services-notifications.md)
* [Архивация и восстановление (аварийное восстановление) надежных служб](service-fabric-reliable-services-backup-restore.md)
* [Конфигурация диспетчера надежных состояний](service-fabric-reliable-services-configuration.md)
* [Справочник разработчика по надежным коллекциям](https://msdn.microsoft.com/library/azure/microsoft.servicefabric.data.collections.aspx)

