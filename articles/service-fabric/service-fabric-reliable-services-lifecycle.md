---
title: "Общие сведения о жизненном цикле Reliable Services в Azure Service Fabric | Документация Майкрософт"
description: "Сведения о различных событиях жизненного цикла служб Reliable Services в Service Fabric"
services: Service-Fabric
documentationcenter: .net
author: masnider
manager: timlt
editor: vturecek;
ms.assetid: 
ms.service: Service-Fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 08/18/2017
ms.author: masnider
ms.translationtype: HT
ms.sourcegitcommit: 847eb792064bd0ee7d50163f35cd2e0368324203
ms.openlocfilehash: 3ff04f031b2d170ac63fc1c6f4e2b6ba6a6c46bd
ms.contentlocale: ru-ru
ms.lasthandoff: 08/19/2017

---

# <a name="reliable-services-lifecycle-overview"></a>Жизненный цикл Reliable Services
> [!div class="op_single_selector"]
> * [C# в Windows](service-fabric-reliable-services-lifecycle.md)
> * [Java в Linux](service-fabric-reliable-services-lifecycle-java.md)
>
>

Если речь идет о жизненных циклах служб Reliable Services, наиболее важны основные аспекты, а именно:

- во время запуска:
  - создаются службы;
  - они могут создавать и возвращать ни одного или несколько прослушивателей;
  - все возвращаемые прослушиватели открываются, что разрешает взаимодействие со службой;
  - вызывается метод RunAsync службы, позволяя службе выполнять длительную или фоновую работу;
- во время завершения работы:
  - маркер отмены, переданный в RunAsync, отменяется, и прослушиватели закрываются;
  - после этого уничтожается сам объект службы.

Следует отметить некоторые моменты, связанные с точным порядком этих событий. В частности, порядок событий может немного изменяться в зависимости от того, предусматривают ли Reliable Services отслеживание состояния. В случае со службами с отслеживанием состояния приходится иметь дело со сценарием переключения первичной реплики. Во время этой процедуры первичная роль передается другой реплике (или возвращается) без завершения работы службы. И, наконец, следует учитывать условия ошибок и сбоев.

## <a name="stateless-service-startup"></a>Запуск службы без отслеживания состояния
Жизненный цикл службы без отслеживания состояния достаточно прост. Ниже приведен порядок событий.

1. Создается служба.
2. Затем одновременно происходят две вещи:
    - Вызывается метод `StatelessService.CreateServiceInstanceListeners()` и открываются все возвращаемые прослушиватели. Для каждого прослушивателя вызывается метод `ICommunicationListener.OpenAsync()`.
    - Вызывается метод `StatelessService.RunAsync()` службы.
3. Вызывается метод `StatelessService.OnOpenAsync()` службы, если он присутствует. Это редко используемое переопределение, но оно доступно.

Важно отметить, что между вызовами методов для создания и открытия прослушивателей и RunAsync нет упорядоченности. Прослушиватели могут быть открыты перед запуском RunAsync. Аналогичным образом метод RunAsync может быть вызван перед открытием или созданием прослушивателей связи. Если синхронизация не требуется, она остается в качестве упражнения для разработчика. Ниже приведены распространенные решения.

  - Иногда прослушиватели не будут работать, пока не будут сформированы другие сведения или выполнены некоторые задачи. Для служб без отслеживания состояния, работа которых обычно может быть выполнена в других расположениях, например: 
    - в конструкторе службы;
    - во время вызова `CreateServiceInstanceListeners()`;
    - при создании самого прослушивателя.
  - Иногда код в RunAsync не запускается, пока прослушиватели открыты. В этом случае необходима дополнительная координация. Общим решением проблемы является использование некоторого флага в прослушивателях, указывающего, когда их работа завершена. Затем этот флаг проверяется в RunAsync, прежде чем будет продолжена фактическая работа.

## <a name="stateless-service-shutdown"></a>Завершение работы службы без отслеживания состояния
При завершении работы службы без отслеживания состояния те же операции выполняются в обратном порядке.

1. В параллельном режиме:
    - Закрываются все открытые прослушиватели. Для каждого прослушивателя вызывается метод `ICommunicationListener.CloseAsync()`.
    - Токен отмены, переданный в `RunAsync()`, отменяется. В результате проверки свойства `IsCancellationRequested` токена отмены возвращается значение true, а при вызове метода `ThrowIfCancellationRequested` маркера возвращается `OperationCanceledException`.
2. Как только `CloseAsync()` завершается для каждого прослушивателя, а также завершается `RunAsync()`, вызывается метод `StatelessService.OnCloseAsync()` службы, если он присутствует. Обычно `StatelessService.OnCloseAsync()` не переопределяется.
3. После выполнения метода `StatelessService.OnCloseAsync()` объект службы уничтожается.

## <a name="stateful-service-startup"></a>Запуск службы с отслеживанием состояния
Запуск службы с отслеживанием состояния имеет лишь несколько отличий по сравнению со службой без отслеживания состояния. При запуске службы с отслеживанием состояния порядок событий выглядит следующим образом.

1. Создается служба.
2. Вызывается метод `StatefulServiceBase.OnOpenAsync()`. Он редко переопределяется в службе.
3. Ниже приведены действия, которые выполняются параллельно:
    - Вызывается метод `StatefulServiceBase.CreateServiceReplicaListeners()`. 
      - Если служба является первичной репликой, открываются все возвращенные прослушиватели. Для каждого прослушивателя вызывается метод `ICommunicationListener.OpenAsync()`.
      - Если служба является вторичной репликой, то открываются только прослушиватели, помеченные как `ListenOnSecondary = true`. Открытые прослушиватели для вторичных реплик используются реже.
    - Если служба в настоящий момент является первичной репликой, то вызывается метод `StatefulServiceBase.RunAsync()` службы.
4. После завершения всех вызовов `OpenAsync()` прослушивателя реплик и вызова `RunAsync()` вызывается метод `StatefulServiceBase.OnChangeRoleAsync()`. Он редко переопределяется в службе.

Как и в случае со службами без отслеживания состояния, между порядком, в котором прослушиватели создаются и открываются, а также вызовом RunAsync отсутствует координация. Если требуется координация, то решение будет во многом схожим. Есть лишь одно дополнение. Предположим, что для вызовов, поступающих в прослушиватели связи, требуется наличие сведений в некоторых [надежных коллекциях](service-fabric-reliable-services-reliable-collections.md). Так как прослушиватели связи могут быть открыты до того, как надежные коллекции станут доступны для чтения или записи, а также до запуска RunAsync, потребуется дополнительная координация. Простейшее и самое распространенное решение для прослушивателей связи — вернуть код ошибки, который клиент использует для повторного запроса.

## <a name="stateful-service-shutdown"></a>Завершение работы службы с отслеживанием состояния
Как и в случае со службами без отслеживания состояния, события жизненного цикла во время завершения работы совпадают с событиями во время запуска, но происходят в обратном порядке. При завершении работы службы с отслеживанием состояния происходят следующие события.

1. В параллельном режиме:
    - Закрываются все открытые прослушиватели. Для каждого прослушивателя вызывается метод `ICommunicationListener.CloseAsync()`.
    - Токен отмены, переданный в `RunAsync()`, отменяется. В результате проверки свойства `IsCancellationRequested` токена отмены возвращается значение true, а при вызове метода `ThrowIfCancellationRequested` маркера возвращается `OperationCanceledException`.
2. Как только `CloseAsync()` завершается для каждого прослушивателя, а также завершается `RunAsync()`, вызывается `StatefulServiceBase.OnChangeRoleAsync()` службы. (Это редко переопределяется в службе.)
    - Ожидание завершения вызова RunAsync необходимо только в том случае, если реплика службы была первичной.
3. После завершения метода `StatefulServiceBase.OnChangeRoleAsync()` вызывается метод `StatefulServiceBase.OnCloseAsync()`. Это редко используемое переопределение, но оно доступно.
3. После завершения `StatefulServiceBase.OnCloseAsync()` объект службы уничтожается.

## <a name="stateful-service-primary-swaps"></a>Переключения первичной реплики службы с отслеживанием состояния
Во время выполнения службы с отслеживанием состояния только первичные реплики этих служб открывают прослушиватели связи и вызывают метод RunAsync. Вторичные реплики создаются, но не видят последующие вызовы. Пока выполняется служба с отслеживанием состояния, первичная реплика может измениться. Что это означает с точки зрения событий жизненного цикла, которые может видеть реплика? Поведение, которое видит реплика с отслеживанием состояния, зависит от того, что происходит во время переключения: понижение или повышение реплики.

### <a name="for-the-primary-being-demoted"></a>При понижении первичной реплики
Service Fabric требуется, чтобы эта реплика остановила обработку сообщений и выполнение любой фоновой работы. Это выглядит аналогично завершению работы службы. Отличие в том, что служба не уничтожается или закрывается, так как остается вторичной. Вызываются следующие API.

1. В параллельном режиме:
    - Закрываются все открытые прослушиватели. Для каждого прослушивателя вызывается метод `ICommunicationListener.CloseAsync()`.
    - Токен отмены, переданный в `RunAsync()`, отменяется. В результате проверки свойства `IsCancellationRequested` токена отмены возвращается значение true, а при вызове метода `ThrowIfCancellationRequested` маркера возвращается `OperationCanceledException`.
2. Как только `CloseAsync()` завершается для каждого прослушивателя, а также завершается `RunAsync()`, вызывается `StatefulServiceBase.OnChangeRoleAsync()` службы. Он редко переопределяется в службе.

### <a name="for-the-secondary-being-promoted"></a>При повышении вторичной реплики
Аналогичным образом Service Fabric необходимо, чтобы эта реплика начала ожидать передачи сообщений и запустила все необходимые фоновые задачи. Эта процедура соответствует процессу создании службы за исключением того, что сама реплика уже существует. Вызываются следующие API.

1. В параллельном режиме:
    - Вызывается метод `StatefulServiceBase.CreateServiceReplicaListeners()` и открываются все возвращаемые прослушиватели. Для каждого прослушивателя вызывается метод `ICommunicationListener.OpenAsync()`.
    - Вызывается метод `StatefulServiceBase.RunAsync()` службы.
2. После завершения всех вызовов `OpenAsync()` прослушивателя реплик и вызова `RunAsync()` вызывается метод `StatefulServiceBase.OnChangeRoleAsync()`. Он редко переопределяется в службе.

### <a name="common-issues-during-stateful-service-shutdown-and-primary-demotion"></a>Распространенные проблемы во время завершения работы службы с отслеживанием состояния и понижения уровня первичной реплики
Service Fabric изменяет первичную реплику службы с отслеживанием состояния по ряду причин. Наиболее распространенными являются [балансировка кластера](service-fabric-cluster-resource-manager-balancing.md) и [обновление приложения](service-fabric-application-upgrade.md). Во время этих операций (а также во время штатного завершения работы службы, т. е. как при ее удалении) очень важно, чтобы служба учитывала `CancellationToken`. Службы, которые не обрабатывают отмену аккуратно, могут вызывать несколько проблем. В частности, эти операции будут выполняться медленно, так как Service Fabric ожидает корректную остановку служб. В конечном счете это может привести к сбоям обновлений из-за истечения времени ожидания и откату. Если не использовать токен отмены, это может также нарушить балансировку кластеров, так как узлы нагружаются, но реорганизация служб невозможна, так как их перемещение занимает слишком много времени. 

Так как это службы с отслеживанием состояния, то, скорее всего, они используют [надежные коллекции](service-fabric-reliable-services-reliable-collections.md). Когда в Service Fabric понижается уровень первичной реплики, то в первую очередь отменяется доступ на запись к базовому состоянию. Это приводит ко второму ряду проблем, которые могут повлиять на жизненный цикл службы. Коллекции возвращают исключения на основании времени и операции с репликой (перемещение или завершение работы). Эти исключения должны обрабатываться правильно. Исключения, порождаемые Service Fabric, делятся на постоянные [(`FabricException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabricexception?view=azure-dotnet) и временные [(`FabricTransientException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabrictransientexception?view=azure-dotnet). Постоянные исключения должны быть зарегистрированы в журнале и порождены, тогда как для временных исключений возможен повтор породившей их операции в соответствии с логикой повтора.

Обработка исключений, которые поступают от `ReliableCollections`, в сочетании с событиями жизненного цикла службы является важной частью тестирования и проверки надежной службы. Перед развертыванием в рабочей среде рекомендуется запустить службу под нагрузкой во время выполнения обновлений и [хаотического тестирования](service-fabric-controlled-chaos.md). Эти простые действия помогут обеспечить правильную реализацию службы и обработку событий жизненного цикла.


## <a name="notes-on-service-lifecycle"></a>Примечания о жизненном цикле службы
  - Метод `RunAsync()` и вызовы `CreateServiceReplicaListeners/CreateServiceInstanceListeners` являются необязательны. В службе может использоваться один из их, оба или ни одного. Например, если служба выполняет всю работу в ответ на вызовы пользователя, реализовывать метод `RunAsync()` не нужно. Необходимы только прослушиватели связи и соответствующий код. Создание и возвращение прослушивателей связи является необязательным, так как у службы может быть только фоновая работа, поэтому достаточно реализовать `RunAsync()`.
  - Служба может успешно завершить `RunAsync()` и вернуться из него. Завершение не является состоянием сбоя. Завершение `RunAsync()` указывает на то, что фоновая работа службы выполнена. Для надежных служб с отслеживанием состояния `RunAsync()` вызывается снова, если уровень реплики был понижен с первичной до вторичной, а затем обратно повышен до первичной.
  - Если служба выполняет выход из `RunAsync()`, порождая какое-либо непредвиденное исключение, это означает сбой. Объект службы завершает работу, и сообщается об ошибке работоспособности.
  - Несмотря на то, что возвращение этих методов не ограничивается по времени, вы не сможете записать никакие надежные коллекции, а значит, и выполнить какую-либо действительную задачу. После получения запроса на отмену рекомендуется возвращать методы как можно быстрее. Если служба не отвечает на такие вызовы API в течение приемлемого промежутка времени, Service Fabric может принудительно завершить работу службы. Обычно это происходит только во время обновления приложения или при удалении службы. По умолчанию время ожидания составляет 15 минут.
  - Сбои в пути `OnCloseAsync()` приводят к вызову `OnAbort()`, что является последней наилучшей возможностью для службы очистить и освободить все запрошенные ресурсы.

## <a name="next-steps"></a>Дальнейшие действия
- [Обзор надежных служб](service-fabric-reliable-services-introduction.md)
- [Краткое руководство по надежным службам Reliable Services](service-fabric-reliable-services-quick-start.md)
- [Продвинутое использование надежных служб](service-fabric-reliable-services-advanced-usage.md)

