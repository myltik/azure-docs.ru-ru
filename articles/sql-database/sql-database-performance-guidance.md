---
title: Руководство по настройке производительности базы данных SQL Azure | Документация Майкрософт
description: Сведения об использовании рекомендаций для повышения производительности запросов базы данных SQL Azure.
services: sql-database
author: CarlRabeler
manager: craigg
ms.service: sql-database
ms.custom: monitor & tune
ms.topic: conceptual
ms.date: 02/12/2018
ms.author: carlrab
ms.openlocfilehash: 613fc4d914635f46d09552858706975006fcbff6
ms.sourcegitcommit: 266fe4c2216c0420e415d733cd3abbf94994533d
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/01/2018
ms.locfileid: "34650474"
---
# <a name="tuning-performance-in-azure-sql-database"></a>Настройка производительности в Базе данных SQL Azure

База данных SQL Azure предоставляет [рекомендации](sql-database-advisor.md), которые можно использовать для повышения производительности базы данных. Можно также позволить Базе данных SQL Azure [автоматически адаптироваться к вашему приложению](sql-database-automatic-tuning.md) и принимать изменения, повышающие производительность рабочей нагрузки.

В случае, Если какие-либо применимые рекомендации отсутствуют и вы по-прежнему сталкиваетесь с проблемами производительности, можно использовать приведенные ниже методы повышения производительности.
- Увеличьте уровни служб в своей [модели приобретения на основе DTU](sql-database-service-tiers-dtu.md) или [модели приобретения на основе виртуальных ядер (предварительная версия)](sql-database-service-tiers-vcore.md), чтобы предоставить дополнительные ресурсы для базы данных.
- Настройте приложение и примените некоторые рекомендации, которые могут увеличить производительность. 
- Настройте базу данных, изменив индексы и запросы, чтобы повысить эффективность работы с данными.

Это ручные методы, так как необходимо решить, какие [ограничения ресурсов модели на основе DTU](sql-database-dtu-resource-limits.md) и [ограничения ресурсов модели на основе виртуальных ядер (предварительная версия)](sql-database-vcore-resource-limits.md) соответствуют вашим потребностям. В противном случае потребуется переписать код приложения или базы данных и развернуть эти изменения.

## <a name="increasing-performance-tier-of-your-database"></a>Повышение уровня производительности базы данных

База данных SQL Azure предлагает на выбор две модели приобретения, [на основе единиц DTU](sql-database-service-tiers-dtu.md) и [на основе виртуальных ядер (предварительная версия)](sql-database-service-tiers-vcore.md). Каждый уровень службы строго изолирует ресурсы, которые может использовать ваша База данных SQL, и гарантирует соответствующую прогнозируемую производительность. В этой статье представлены рекомендации, с помощью которых вы сможете выбрать уровень служб для своего приложения. Здесь также описываются способы настройки приложения для эффективного использования Базы данных SQL Azure.

> [!NOTE]
> В статье приведены рекомендации по производительности отдельных баз данных в Базе данных SQL Azure. Сведения о производительности пулов эластичных баз данных см. в статье [Когда следует использовать эластичный пул?](sql-database-elastic-pool-guidance.md) Обратите внимание, что многие из рекомендаций по настройке в этой статье можно применить к базам данных в пуле эластичных баз данных, чтобы получить аналогичные преимущества в отношении производительности.
> 

* **Базовый**. Уровень службы "Базовый" обеспечивает предсказуемую почасовую производительность для каждой базы данных. При достаточном количестве ресурсов в базе данных уровня "Базовый" в небольших базах данных без большого количества параллельных запросов поддерживается отличная производительность. Ниже приведены типичные случаи использования уровня служб "Базовый".
  * **Вы только начали работать с базой данных SQL Azure.** Для приложений на первых этапах разработки часто не требуется высокий уровень производительности. Базы данных уровня "Базовый" — идеальная среда для разработки и тестирования баз данных по низкой цене.
  * **У вас есть база данных с одним пользователем.** Для приложений, связывающих одного пользователя с базой данных, обычно не применяются строгие требования к параллелизму и производительности. Таким приложениям, вероятно, подойдет уровень служб "Базовый".
* **Стандартный**. Уровень служб "Стандартный" позволяет более точно прогнозировать производительность и повысить эффективность работы баз данных с множеством параллельных запросов, например для рабочих групп и веб-приложений. Выбрав этот уровень, вы можете определить размер приложения на основе поминутной предсказуемой производительности.
  * **База данных содержит большое количество параллельных запросов.** Для приложений, обслуживающих несколько пользователей одновременно, обычно требуется более высокий уровень производительности. Например, приложения рабочей группы или веб-приложения с низкими или средними требованиями к трафику операций ввода-вывода, поддерживающие параллельную обработку множества запросов, являются хорошими кандидатами для уровня служб "Стандартный".
* **Премиум**: уровень служб "Премиум" обеспечивает предсказуемую посекундную производительность для каждой базы данных уровня "Премиум" или "Критически важный для бизнеса" (предварительная версия). При выборе уровня "Премиум" можно определить размер приложения базы данных на основе пиковой загрузки для этой базы данных. Этот уровень устраняет отклонения производительности, из-за которых небольшие запросы могут выполняться дольше, чем требуется, в операциях, чувствительных к задержке. Эта модель может значительно упростить разработку и проверку приложений, для которых большое значение имеют пиковая нагрузка, отклонения производительности и задержка выполнения запросов. Большинство вариантов использования уровня служб "Премиум" имеют одну или несколько из этих характеристик:
  * **Высокая пиковая нагрузка.** Приложениям, которым для выполнения операций требуется мощный процессор, большой объем памяти или широкие возможности ввода-вывода данных, необходим уровень высокой производительности. Например, если известно, что работа базы данных задействует несколько ядер процессора на длительное время, то для такого приложения, скорее всего, подойдет уровень служб "Премиум".
  * **Множество параллельных запросов.** Некоторые приложения баз данных обслуживают множество параллельных запросов, например веб-сайты с большим объемом трафика. Уровни служб "Базовый" и "Стандартный" накладывают ограничения на число параллельных запросов на базу данных. Приложения, которым требуется больше подключений, должны зарезервировать соответствующий размер, чтобы справиться с максимальным числом запросов.
  * **Минимальная задержка.** Некоторым приложениям требуется минимальное время отклика базы данных. Если определенная хранимая процедура вызывается в рамках более широкого взаимодействия с клиентом, то в 99 % случаев отклик на такой запрос должен выполняться не более чем за 20 миллисекунд. Приложение такого типа эффективно работает с уровнем служб "Премиум", который обеспечивает необходимую вычислительную мощность.

Уровень, который требуется для Базы данных SQL, зависит от требований к пиковой нагрузке для каждого измерения ресурсов. Некоторые приложения могут использовать небольшой объем одного ресурса и значительный — других.

### <a name="service-tier-capabilities-and-limits"></a>Возможности и ограничения уровней служб

На каждом уровне служб необходимо задать уровень производительности, чтобы платить только за потребляемые ресурсы. Вы можете [регулировать объем ресурсов](sql-database-service-tiers-dtu.md), увеличивая или уменьшая его по мере изменения рабочей нагрузки. Например, если рабочая нагрузка базы данных повышается в начале учебного года, то можно повысить уровень производительности на период с июля по сентябрь. Его можно уменьшить после снижения пиковой нагрузки. Вы можете минимизировать издержки, оптимизировав облачную среду в соответствии с сезонными потребностями бизнеса. Кроме того, такая модель подходит для поддержки жизненного цикла программных продуктов. Команда тестирования может увеличивать мощность на время тестирования и снижать ее после его завершения. При использовании модели запроса мощности оплачивается только используемая мощность, а не выделенные редко используемые ресурсы.

### <a name="why-service-tiers"></a>Зачем нужны уровни служб?
Хотя рабочие нагрузки баз данных могут отличаться, цель уровней служб — обеспечить предсказуемость производительности на различных уровнях. Благодаря этим уровням клиенты с высокими требованиями к ресурсам базы данных могут работать в более изолированной вычислительной среде.

## <a name="tune-your-application"></a>Настройка приложения
В традиционной локальной среде SQL Server процесс изначального планирования загрузки часто отделен от процесса запуска приложения в рабочей среде. Сначала приобретаются лицензии на оборудование и продукт, а затем настраивается производительность. При использовании Базы данных SQL Azure рекомендуется объединить процессы настройки и запуска приложения. Оплата только за используемые ресурсы позволяет настраивать приложение на использование минимального объема ресурсов, которые нужны в данный момент, а не выполнять избыточную подготовку согласно прогнозам будущего роста нагрузки на приложение, так как часто такие прогнозы ошибочны. Некоторые пользователи предпочитают не настраивать приложение и вместо этого используют избыточную подготовку ресурсов оборудования. Этот подход может подойти, если вы не желаете изменять ключевое приложение в период высокой нагрузки. Но настройка приложения позволяет минимизировать потребление ресурсов и снизить ежемесячные расходы благодаря новым уровням служб в Базе данных SQL Azure.

### <a name="application-characteristics"></a>Характеристики приложения
Уровни служб Базы данных SQL Azure предназначены для оптимизации стабильности и предсказуемости производительности приложения. Вместе с тем с помощью некоторых рекомендаций по настройке приложения можно настроить приложение для максимально эффективного использования ресурсов на уровне производительности. Многие приложения получают значительный прирост производительности после простого перехода на более высокий уровень производительности или уровень служб, в то время как для лучшей работы других приложений на новом уровне требуется дополнительная настройка. Для повышения производительности приложений со следующими характеристиками необходима дополнительная настройка:

* **Приложения с низкой производительностью из-за "нестабильной" работы.** В эту категорию входят приложения, которые совершают избыточные операции доступа к данным, несмотря на их чувствительность к сетевым задержкам. Возможно, в такие приложения понадобится внести изменения, сократив число операций доступа к данным в Базе данных SQL. Например, производительность приложения можно улучшить за счет пакетной обработки нерегламентированных запросов или перемещения запросов в хранимые процедуры. Дополнительные сведения см. в разделе [Пакетные запросы](#batch-queries).
* **Базы данных с интенсивной рабочей нагрузкой, которые не могут работать на одном сервере.** Базы данных, которым требуется больше ресурсов, чем предоставляет уровень производительности "Премиум", можно оптимизировать за счет масштабирования рабочей нагрузки. Дополнительные сведения см. Дополнительные сведения см. в разделах [Сегментирование баз данных](#cross-database-sharding) и [Функциональное секционирование](#functional-partitioning).
* **Приложения с неоптимальными запросами.** Приложениям, особенно тем, которые находятся на уровне доступа к данным и используют неоптимальные запросы, может не подойти более высокий уровень производительности. К таким запросам относятся запросы, в которых нет предложения WHERE, отсутствуют индексы или используется устаревшая статистика. Больше пользы таким приложениям приносят стандартные методы оптимизации производительности запросов. Дополнительные сведения см. Дополнительные сведения см. в разделах [Отсутствующие индексы](#identifying-and-adding-missing-indexes) и [Настройка запросов и указания на них](#query-tuning-and-hinting).
* **Приложения с неоптимальной схемой доступа к данным.** Если в приложениях есть проблемы параллельного доступа к данным, например при одновременном доступе возникает блокировка, то более высокий уровень производительности, скорее всего, не улучшит их работу. Попробуйте снизить количество циклических запросов к Базе данных SQL Azure за счет кэширования данных на стороне клиента с помощью службы кэша Azure или других технологий кэширования. См. раздел [Кэширование на уровне приложения](#application-tier-caching).

## <a name="tune-your-database"></a>Настройка базы данных
В этом разделе рассматриваются некоторые методы, которые можно использовать для настройки Базы данных SQL Azure с целью повышения производительности приложения и использования наименьшего уровня производительности. Некоторые из этих методов совпадают с традиционными рекомендациями по настройке SQL Server, однако есть и специфические методы настройки базы данных SQL Azure. В некоторых случаях можно изучить использование ресурсов в базе данных, чтобы настроить и улучшить традиционные методы SQL Server для работы в Базе данных SQL Azure.

### <a name="identify-performance-issues-using-azure-portal"></a>Выявление проблем производительности с помощью портала Azure
На портале Azure есть инструменты, с помощью которых можно проанализировать и устранить проблемы производительности в базе данных SQL:

* [Анализ производительности запросов](sql-database-query-performance.md)
* [Помощник по работе с базами данных SQL](sql-database-advisor.md)

На портале Azure содержатся дополнительные сведения об этих средствах и способах их использования. Для более эффективной диагностики и устранения неполадок рекомендуется сначала попробовать средства на портале Azure. В особых случаях для отсутствующих индексов и запросов мы рекомендуем использовать методы настройки вручную, которые описываются ниже.

Дополнительные сведения о выявлении проблем в Базе данных SQL Azure приведены в статье о [мониторинге производительности](sql-database-single-database-monitor.md).

### <a name="identifying-and-adding-missing-indexes"></a>Определение и добавление недостающих индексов
Одна из распространенных проблем производительности баз данных OLTP связана с физической схемой базы данных. Часто схемы базы данных создаются и поставляются без проверки масштабируемости по нагрузке или объему данных. К сожалению, производительность плана запроса, приемлемая при небольшом масштабе, может существенно снижаться при использовании объема данных уровня большой компании. Самый распространенный источник проблем связан с отсутствием индексов, которые позволили бы сортировать и ограничивать данные в запросе. Часто при этом сканируется вся таблица, в то время как поиска по индексу было бы достаточно.

В этом примере в выбранном плане запроса используется сканирование, хотя здесь было бы достаточно поиска.

    DROP TABLE dbo.missingindex;
    CREATE TABLE dbo.missingindex (col1 INT IDENTITY PRIMARY KEY, col2 INT);
    DECLARE @a int = 0;
    SET NOCOUNT ON;
    BEGIN TRANSACTION
    WHILE @a < 20000
    BEGIN
        INSERT INTO dbo.missingindex(col2) VALUES (@a);
        SET @a += 1;
    END
    COMMIT TRANSACTION;
    GO
    SELECT m1.col1
    FROM dbo.missingindex m1 INNER JOIN dbo.missingindex m2 ON(m1.col1=m2.col1)
    WHERE m1.col2 = 4;

![План запроса c отсутствующими индексами](./media/sql-database-performance-guidance/query_plan_missing_indexes.png)

База данных SQL Azure может помочь выявить условия, при которых индекс становится необходимым. Динамические административные представления, встроенные в Базу данных SQL Azure, учитывают во время компиляции запроса случаи, когда индекс мог бы значительно снизить стоимость, связанную с выполнением запроса. Во время выполнения запроса База данных SQL отслеживает, как часто выполнялся план запроса, а также вычисляет разницу между выполненным планом запроса и возможным планом с индексом. Эти представления можно использовать, чтобы быстро выяснить, какие изменения схемы базы данных могли бы существенно уменьшить рабочую нагрузку для базы данных.

Этот запрос можно использовать для оценки потенциально отсутствующих индексов:

    SELECT CONVERT (varchar, getdate(), 126) AS runtime,
        mig.index_group_handle, mid.index_handle,
        CONVERT (decimal (28,1), migs.avg_total_user_cost * migs.avg_user_impact *
                (migs.user_seeks + migs.user_scans)) AS improvement_measure,
        'CREATE INDEX missing_index_' + CONVERT (varchar, mig.index_group_handle) + '_' +
                  CONVERT (varchar, mid.index_handle) + ' ON ' + mid.statement + '
                  (' + ISNULL (mid.equality_columns,'')
                  + CASE WHEN mid.equality_columns IS NOT NULL
                              AND mid.inequality_columns IS NOT NULL
                         THEN ',' ELSE '' END + ISNULL (mid.inequality_columns, '')
                  + ')'
                  + ISNULL (' INCLUDE (' + mid.included_columns + ')', '') AS create_index_statement,
        migs.*,
        mid.database_id,
        mid.[object_id]
    FROM sys.dm_db_missing_index_groups AS mig
    INNER JOIN sys.dm_db_missing_index_group_stats AS migs
        ON migs.group_handle = mig.index_group_handle
    INNER JOIN sys.dm_db_missing_index_details AS mid
        ON mig.index_handle = mid.index_handle
    ORDER BY migs.avg_total_user_cost * migs.avg_user_impact * (migs.user_seeks + migs.user_scans) DESC

В этом примере при выполнении запроса возникло такое предложение:

    CREATE INDEX missing_index_5006_5005 ON [dbo].[missingindex] ([col2])  

После его создания инструкция SELECT выбирает другой план, в котором используется поиск вместо сканирования, а затем выполняет план более эффективно.

![План запроса c исправленными индексами](./media/sql-database-performance-guidance/query_plan_corrected_indexes.png)

Важно понимать, что пропускная способность общей среды более ограничена, чем пропускная способность выделенного сервера. Вы можете минимизировать избыточное число операций ввода-вывода и максимально использовать ресурсы каждого уровня производительности, доступные в рамках уровней службы "База данных SQL Azure". Улучшение физической схемы базы данных может значительно уменьшить задержку для определенных запросов, улучшить пропускную способность при параллельных запросах, обрабатываемых на единицу масштабирования, и минимизировать затраты, необходимые на выполнение одного запроса. Дополнительные сведения о динамических административных представлениях для отсутствующих индексов см. в разделе [sys.dm_db_missing_index_details](https://msdn.microsoft.com/library/ms345434.aspx).

### <a name="query-tuning-and-hinting"></a>Настройка запросов и указания на них
Оптимизатор запросов в Базе данных SQL Azure напоминает традиционный оптимизатор запросов SQL Server. Большинство рекомендаций по настройке запросов и ограничения оптимизатора запросов применимы к Базе данных SQL Azure. Настроив запросы в Базе данных SQL Azure, можно снизить общие требования к ресурсам. Кроме того, с помощью настройки можно снизить затраты на приложение, так как в результате можно будет использовать более низкий уровень производительности.

Примером является то, как оптимизатор запросов вносит параметры "на лету". Это распространено в SQL Server и также применяется к Базе данных SQL Azure. Во время компиляции оптимизатор запросов вычисляет текущее значение параметра с целью создания более оптимального плана запроса. Хотя такая стратегия часто позволяет создать более быстрый план запроса, чем план, скомпилированный без известных значений параметров, сейчас в SQL Server и Базе данных SQL Azure она работает несовершенно. Иногда параметр не вносится или вносится, но созданный план является неэффективным для полного набора значений параметров в рабочей нагрузке. Майкрософт предусматривает использование указаний запросов (директив), которые позволяют указать, следует ли изменить поведение по умолчанию. Часто использование указаний позволяет устранить проблемы, когда работа SQL Server и Базы данных SQL Azure не подходит для конкретной рабочей нагрузки.

В следующем примере показано, как обработчик запросов может создать план, который не соответствует требованиям к производительности и ресурсам. В этом примере также показано, что при использовании указания запроса можно сократить время выполнения запроса и снизить требования к ресурсам для Базы данных SQL.

    DROP TABLE psptest1;
    CREATE TABLE psptest1(col1 int primary key identity, col2 int, col3 binary(200));

    DECLARE @a int = 0;
    SET NOCOUNT ON;
    BEGIN TRANSACTION
    WHILE @a < 20000
    BEGIN
        INSERT INTO psptest1(col2) values (1);
        INSERT INTO psptest1(col2) values (@a);
        SET @a += 1;
    END
    COMMIT TRANSACTION
    CREATE INDEX i1 on psptest1(col2);
    GO

    CREATE PROCEDURE psp1 (@param1 int)
    AS
    BEGIN
        INSERT INTO t1 SELECT * FROM psptest1
        WHERE col2 = @param1
        ORDER BY col2;
    END
    GO

    CREATE PROCEDURE psp2 (@param2 int)
    AS
    BEGIN
        INSERT INTO t1 SELECT * FROM psptest1 WHERE col2 = @param2
        ORDER BY col2
        OPTION (OPTIMIZE FOR (@param2 UNKNOWN))
    END
    GO

    CREATE TABLE t1 (col1 int primary key, col2 int, col3 binary(200));
    GO

Код установки создает таблицу с неравномерным распределением данных. Оптимальный план запроса зависит от выбранного параметра. К сожалению, при кэшировании плана запрос не всегда повторно компилируется в зависимости от наиболее подходящего значения параметра. Таким образом, может получиться так, что будет кэширован неоптимальный план, который будет использоваться во многих случаях, когда можно было бы использовать более эффективный план. После этого план запроса создает две хранимые процедуры, которые идентичны друг другу, за исключением того, что одна из них содержит специальное указание запроса.

**Пример, часть 1.**

    -- Prime Procedure Cache with scan plan
    EXEC psp1 @param1=1;
    TRUNCATE TABLE t1;

    -- Iterate multiple times to show the performance difference
    DECLARE @i int = 0;
    WHILE @i < 1000
    BEGIN
        EXEC psp1 @param1=2;
        TRUNCATE TABLE t1;
        SET @i += 1;
    END

**Пример, часть 2.**

(Мы советуем подождать около 10 минут, прежде чем приступить ко второй части примера, чтобы в итоговых данных телеметрии была очевидная разница.)

    EXEC psp2 @param2=1;
    TRUNCATE TABLE t1;

    DECLARE @i int = 0;
    WHILE @i < 1000
    BEGIN
        EXEC psp2 @param2=2;
        TRUNCATE TABLE t1;
        SET @i += 1;
    END

Каждая часть примера пытается выполнить параметризованную вставку 1000 раз (это необходимо для создания достаточной нагрузки). При выполнении хранимых процедур обработчик запросов проверяет значение параметра, переданное в процедуру во время первой компиляции ("вставка на лету"). Обработчик кэширует результирующий план и использует его в дальнейшем, даже если значение параметра будет другим. Оптимальный план может подойти не для всех случаев. Иногда нужно указывать оптимизатору, какой план выбрать, чтобы этот план был относительно универсальным, а не просто подходящим для определенного случая, когда впервые происходит компиляция запроса. В этом примере изначальный план создает сканирование, при котором считываются все строки, чтобы найти значение, которое отвечает параметру.

![Настройка запроса с использованием плана сканирования](./media/sql-database-performance-guidance/query_tuning_1.png)

Так как процедура выполнена с использованием значения 1, результирующий план был оптимальным для значения 1, но неоптимальным для всех остальных значений в таблице. Если вы будете выбирать каждый план случайным образом, скорее всего, результат не будет оптимальным, так как план будет выполняться медленнее и задействовать больше ресурсов.

При выполнении теста с параметром `SET STATISTICS IO` со значением `ON` логическое сканирование в этом примере будет проходить в фоновом режиме. Вы можете увидеть, что план выполнил 1148 операций чтения (что является неэффективным, если обычно нужно вернуть только одну строку).

![Настройка запроса с использованием логического сканирования](./media/sql-database-performance-guidance/query_tuning_2.png)

Во второй части примера используется указание запроса, которое позволяет дать оптимизатору инструкцию использовать конкретное значение во время компиляции. В этом случае обработчик запросов принудительно игнорирует значение, которое передается в качестве параметра, и вместо этого использует значение `UNKNOWN`. Это значение со средней частотой в таблице (независимо от искажения распределения). В результате мы получим план на основе поиска, который работает быстрее и использует меньше ресурсов, чем план из части 1 этого примера.

![Настройка запроса с помощью указания запроса](./media/sql-database-performance-guidance/query_tuning_3.png)

Просмотреть результат можно в таблице **sys.resource_stats** (между временем выполнения теста и появлением данных в таблице есть задержка). В этом примере первая часть выполнялась в рамках временного окна 22:25:00, а вторая часть — в 22:35:00. В первой части использовано больше ресурсов, чем во второй (в силу повышения эффективности).

    SELECT TOP 1000 *
    FROM sys.resource_stats
    WHERE database_name = 'resource1'
    ORDER BY start_time DESC

![Пример результатов настройки запроса](./media/sql-database-performance-guidance/query_tuning_4.png)

> [!NOTE]
> В этом примере преднамеренно использовались небольшие значения, однако последствия неоптимальных параметров могут быть существенными, особенно для больших баз данных. Разница для быстрых и медленных запросов в некоторых случаях может достигать от нескольких секунд до нескольких часов.
> 
> 

Вы можете просмотреть таблицу **sys.resource_stats**, чтобы определить, использует ли один тест больше ресурсов, чем другой. При сравнении данных между тестами необходимо установить интервалы, чтобы они не группировались в одном 5-минутном окне в представлении **sys.resource_stats**. Цель расчетов — минимизировать общее использование ресурсов, а не пиковую нагрузку. Обычно оптимизация части кода с целью уменьшения задержки выполнения также приводит к сокращению использования ресурсов. Убедитесь, что изменения, внесенные в приложение, необходимы и что они не оказывают негативное влияние на работу приложения при использовании указаний запроса.

Если рабочая нагрузка содержит ряд повторяющихся запросов, то часто бывает целесообразно отследить и проверить оптимальность планов, так как это позволит уменьшить минимальный размер ресурсов, необходимых базе данных. После проверки иногда пересматривайте планы, чтобы убедиться, что их производительность не ухудшилась. Дополнительные сведения об указаниях запроса (Transact-SQL) см. [в этой статье](https://msdn.microsoft.com/library/ms181714.aspx).

### <a name="cross-database-sharding"></a>Сегментирование баз данных
Так как База данных SQL Azure работает на стандартном оборудовании, ограничения емкости для отдельной базы данных будут ниже, чем в традиционной локальной среде SQL Server. Некоторые пользователи используют сегментирование баз данных, если размеры отдельной базы данных в Базе данных SQL Azure недостаточны. Большинство клиентов, использующих сегментирование в Базе данных SQL Azure, разбивают данные одного измерения на несколько баз данных. При использовании этого подхода необходимо понимать, что часто приложения OLTP выполняют транзакции, которые применимы только к одной строке или небольшой группе строк внутри одной схемы.

> [!NOTE]
> База данных SQL теперь предоставляет библиотеку для упрощения сегментирования. Дополнительные сведения см. в статье [Обзор клиентской библиотеки для эластичных баз данных](sql-database-elastic-database-client-library.md).
> 
> 

Например, если база данных содержит сведения об имени клиента, заказе и цене (как можно увидеть в стандартном примере базы данных Northwind, который используется для SQL Server), эти данные можно разбить на несколько баз данных, группируя вместе сведения о клиенте и заказе. Это гарантирует, что данные клиента останутся в пределах отдельной базы данных. Приложение должно разбивать заказчиков по разным базам данных и эффективно распределять нагрузку. В результате можно не только не превышать имеющееся ограничение максимального размера базы данных, но и обрабатывать в Базе данных SQL Azure рабочие нагрузки, которые существенно превышают ограничения различных уровней производительности, если каждая отдельная база данных будет работать в соответствии с ограничениями DTU.

Несмотря на то что сегментирование баз данных не снижает общую нагрузку для решения, такой подход очень эффективен для поддержки очень больших решений, распределенных по нескольким базам данных. Каждую базу данных можно запускать на разных уровнях производительности для поддержки очень больших "эффективных" баз данных с высокими требованиями к ресурсам.

### <a name="functional-partitioning"></a>Функциональное секционирование
Пользователи SQL Server часто объединяют несколько функций в отдельной базе данных. Например, если приложение содержит логику управления запасами склада, то база данных может содержать логику, связанную с запасами, отслеживанием заказов на покупку, хранимыми процедурами, индексированными или материализованными представлениями для управления ежемесячными отчетами. Такой подход позволяет легко администрировать базы данных и выполнять такие операции, как резервное копирование. Однако в этом случае нужно также изменить размер оборудования, чтобы распределять пиковую нагрузку функций одного приложения.

Если в Базе данных SQL Azure используется масштабируемая архитектура, лучше распределить функции приложения по разным базам данных. При использовании этого метода приложения масштабируются независимо друг от друга. По мере повышения нагрузки на приложение (и нагрузки на базу данных) администратор сможет определить уровни производительности отдельно для каждой функции одного приложения. Такая архитектура позволит приложению расширяться за пределы одного сервера за счет распределения нагрузки по разным серверам.

### <a name="batch-queries"></a>Пакетные запросы
Для приложений, которые получают доступ к данным с использованием частых нерегламентированных запросов большого объема, время отклика значительно увеличивается за счет взаимодействия по сети между уровнем приложения и уровнем Базы данных SQL Azure. Даже если приложение и База данных SQL Azure находятся в одном центре обработки данных, сетевая задержка между ними может увеличиться пропорционально количеству операций доступа к данным. Чтобы уменьшить количество циклических операций доступа к данным, попробуйте выполнить пакетную обработку нерегламентированных запросов или скомпилировать их в качестве хранимых процедур. Если выполнить пакетную обработку нерегламентированных запросов, несколько запросов будут отсылаться как один большой пакет в Базу данных SQL Azure за одну операцию. Выполнив компилирование нерегламентированных запросов в одну хранимую процедуру, можно достигнуть того же результата, что и при пакетной обработке. Использование хранимой процедуры также позволяет расширить возможности кэширования планов запросов в Базе данных SQL Azure, чтобы снова использовать хранимую процедуру.

Некоторые приложения требуют большого количества операций записи.  Иногда можно уменьшить общую нагрузку операций ввода-вывода на базы данных путем правильной пакетной обработки операций записи. Часто для этого нужно просто использовать явные транзакции вместо автоматических в хранимых процедурах и пакетах нерегламентированных запросов. Оценку различных подходов см. в статье [Как повысить производительность приложений базы данных SQL с помощью пакетной обработки](https://msdn.microsoft.com/library/windowsazure/dn132615.aspx). Поэкспериментируйте со своей рабочей нагрузкой, чтобы найти оптимальную модель пакетной обработки. Необходимо учитывать, что гарантии согласованности транзакций разных моделей могут немного отличаться. Чтобы определить наиболее оптимальную рабочую нагрузку, которая минимизирует использование ресурсов, необходимо добиться правильного сочетания компромиссов согласованности и производительности.

### <a name="application-tier-caching"></a>Кэширование на уровне приложения
Некоторые приложения базы данных содержат рабочие нагрузки, выполняющие много операций чтения. Уровни кэширования могут снизить нагрузку на базу данных, а вслед за ней и уровень производительности, необходимый для поддержки базы данных с помощью Базы данных SQL Azure. [Кэш Redis для Azure](https://azure.microsoft.com/services/cache/)позволяет при рабочих нагрузках с большим количеством операций чтения считывать данные один раз (или, в зависимости от конфигурации, один раз на каждом сервере) и хранить их вне Базы данных SQL. Это помогает снизить нагрузку на базу данных (загрузка ЦП и число операций ввода-вывода), однако это может повлиять на согласованность транзакций, так как данные в кэше могут быть не синхронизированы с данными в базе данных. Для многих приложений определенный уровень несогласованности приемлем, однако это подходит не для всех рабочих нагрузок. Мы советуем внимательно изучить требования к приложению, прежде чем использовать стратегию кэширования на уровне приложения.

## <a name="next-steps"></a>Дополнительная информация
* Дополнительные сведения об уровнях служб на основе DTU см. в разделах [Модель приобретения на основе DTU для базы данных SQL Azure](sql-database-service-tiers-dtu.md) и [Ограничения модели для ресурсов службы "База данных SQL Azure" на основе DTU](sql-database-dtu-resource-limits.md).
* Дополнительные сведения об уровнях служб на основе виртуальных ядер см. в разделах [Модель приобретения на основе виртуальных ядер для базы данных SQL Azure (предварительная версия)](sql-database-service-tiers-vcore.md) и [Ограничения для службы "База данных SQL Azure" в модели приобретения на основе виртуальных ядер (предварительная версия)](sql-database-vcore-resource-limits.md).
* Дополнительные сведения о пулах эластичных баз данных Azure см. в статье [Что такое пул эластичных БД Azure?](sql-database-elastic-pool.md)
* Сведения о производительности и пулах эластичных баз данных см. в статье [Когда следует использовать эластичный пул?](sql-database-elastic-pool-guidance.md)

