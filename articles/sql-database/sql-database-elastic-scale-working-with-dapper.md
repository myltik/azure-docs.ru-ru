---
title: Использование клиентской библиотеки эластичной базы данных с Dapper | Документация Майкрософт
description: Использование клиентской библиотеки эластичной базы данных с Dapper.
services: sql-database
manager: craigg
author: stevestein
ms.service: sql-database
ms.custom: scale out apps
ms.topic: conceptual
ms.date: 04/01/2018
ms.author: sstein
ms.openlocfilehash: 6619f2dfe5f58cd23dbd0ffe6e2b545b803f3acc
ms.sourcegitcommit: 266fe4c2216c0420e415d733cd3abbf94994533d
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/01/2018
ms.locfileid: "34647934"
---
# <a name="using-elastic-database-client-library-with-dapper"></a>Использование клиентской библиотеки эластичной базы данных с Dapper
Документ предназначен для разработчиков, которые используют Dapper для создания приложений, но также хотят применять [инструменты эластичной базы данных](sql-database-elastic-scale-introduction.md), чтобы создавать приложения, реализующие сегментирование для развертывания уровня данных.  В документе показаны изменения, которые следует внести в приложениях на базе Dapper, для интеграции со средствами эластичной базы данных. Внимание уделяется совмещению методов управления сегментами эластичной базы данных и маршрутизации, зависящей от данных, с помощью Dapper. 

**Пример кода.** [Elastic DB Tools for Azure SQL - Dapper Integration](https://code.msdn.microsoft.com/Elastic-Scale-with-Azure-e19fc77f) (Средства эластичной базы данных для базы данных SQL Azure — интеграция с Dapper).

Интеграция **Dapper** и **DapperExtensions** с клиентской библиотекой эластичной базы данных для базы данных SQL Azure — это просто. Приложения могут использовать данные в зависимости от маршрутизации путем создания и открытия новых объектов [SqlConnection](http://msdn.microsoft.com/library/system.data.sqlclient.sqlconnection.aspx), чтобы использовать вызов [OpenConnectionForKey](http://msdn.microsoft.com/library/azure/dn807226.aspx) из [клиентской библиотеки](http://msdn.microsoft.com/library/azure/dn765902.aspx). Это ограничивает внесение изменений в приложении местами создания и открытия новых подключений. 

## <a name="dapper-overview"></a>Обзор Dapper
**Dapper** — это объектно-реляционный модуль сопоставления. Оно сопоставляет объекты .NET в приложении с объектами в реляционной базе данных (и наоборот). В первой части примера кода показано, как можно интегрировать клиентскую библиотеку эластичной базы данных с приложениями, созданными с помощью Dapper. Во второй части примера кода показано, как выполнить интеграцию при одновременном использовании Dapper и DapperExtensions.  

Средство сопоставления в Dapper предоставляет методы расширения для подключений к базе данных, упрощающие отправку операторов T-SQL для выполнения базы данных или создания адресуемых ей запросов. Например, Dapper упрощает сопоставление объектов .NET и параметров операторов SQL для вызовов **Execute** и использование результатов SQL-запросов объектов .NET с помощью вызовов **Query** из Dapper. 

При использовании DapperExtensions больше не требуется предоставлять операторы SQL. Методы расширения для подключений к базе данных, такие как **GetList** или **Insert**, создают инструкции SQL в фоновом режиме.

Другое преимущество использования Dapper и DapperExtensions заключается в том, что приложение контролирует создание подключения к базе данных. Это позволяет взаимодействовать с клиентской библиотекой эластичной базы данных, действующей в качестве посредника при подключении к базе данных, на основе сопоставления шардлетов с базами данных.

Сведения о получении сборок Dapper см. в статье [Dapper dot net 1.50.2](http://www.nuget.org/packages/Dapper/) (Dapper .NET 1.50.2). Сведения о расширениях Dapper см. в статье [DapperExtensions 1.5.0](http://www.nuget.org/packages/DapperExtensions).

## <a name="a-quick-look-at-the-elastic-database-client-library"></a>Краткий обзор клиентской библиотеки эластичной базы данных
Клиентская библиотека эластичной базы данных позволяет определять разделы данных приложения, которые называются *шардлетами*, сопоставлять их с базами данных и определять с помощью *ключей сегментирования*. Вы можете использовать любое количество баз данных и распределять свои шардлеты между этими базами данных. Сопоставление значений ключей сегментирования с базами данных хранится в сопоставлении сегментов, которое обеспечивается API-интерфейсами библиотеки. Эта функция называется **управление сопоставлением сегментов**. Сопоставление сегментов также выступает в качестве посредника подключений к базе данных для запросов с ключом сегментирования. Эта функция называется **маршрутизацией, зависящей от данных**.

![Сопоставления сегментов и маршрутизация, зависящая от данных][1]

Диспетчер сопоставления сегментов защищает пользователей от получения несогласованных представлений данных шардлета, которые могут иметь место при выполнении параллельных операций управления шардлетом в базе данных. Для этого сопоставления сегментов опосредуют подключения к базе данных для приложения, созданного с помощью библиотеки. Так как операции управления сегментами могут повлиять на шардлет, функция сопоставления сегментов может завершать подключение к базе данных автоматически. 

Вместо стандартных способов создания подключений для Dapper необходимо использовать метод [OpenConnectionForKey](http://msdn.microsoft.com/library/azure/dn824099.aspx). Это гарантирует, что при перемещении данных между сегментами выполняется полная проверка и надлежащее управление сегментами.

### <a name="requirements-for-dapper-integration"></a>Требования к интеграции Dapper
Во время работы одновременно с клиентской библиотекой эластичной базы данных и интерфейсами API Dapper цель заключается в том, чтобы сохранить следующие свойства.

* **Развертывание.** Необходимо добавлять базы данных в уровень данных сегментированного приложения и удалять их из него согласно потребностям приложения в ресурсах. 
* **Согласованность.** Так как приложение масштабируется путем сегментирования, необходимо выполнять маршрутизацию, зависящую от данных. Для этого понадобится использовать возможности маршрутизации, зависящей от данных. В частности, необходимо сохранить гарантии проверки и согласованности, предоставляемые с помощью подключений, которые проходят через диспетчер сопоставления сегментов, во избежание повреждения или получения неправильных результатов запросов. Это гарантирует, что подключения к заданному шардлету отклоняются или останавливаются, если (например) в настоящее время шардлет перемещается в другой сегмент с помощью API для разделения и объединения.
* **Сопоставление объектов.** Необходимо сохранить удобство сопоставлений, предоставляемое Dapper, для преобразования между классами в приложении и базовыми структурами базы данных. 

В следующем разделе приведены рекомендации по этим требованиям для приложений, созданных с помощью **Dapper** и **DapperExtensions**.

## <a name="technical-guidance"></a>Техническое руководство
### <a name="data-dependent-routing-with-dapper"></a>Маршрутизация, зависящая от данных, с помощью Dapper
При использовании Dapper приложение, как правило, отвечает за создание и открытие подключений к базе данных. Если присвоить приложению тип T, Dapper возвращает результаты запроса в качестве коллекции .NET типа T. Dapper сопоставляет данные в строках результатов T-SQL с объектами типа T. Аналогичным образом Dapper сопоставляет объекты .NET в значениях или параметрах SQL для операторов языка обработки данных (DML). Dapper обеспечивает эти функциональные возможности с помощью методов расширения в регулярном объекте [SqlConnection](http://msdn.microsoft.com/library/system.data.sqlclient.sqlconnection.aspx) из библиотек ADO.NET для клиента SQL. Подключения SQL, возвращенные API-интерфейсами эластичного масштабирования для DDR, также являются регулярными объектами [SqlConnection](http://msdn.microsoft.com/library/system.data.sqlclient.sqlconnection.aspx). Это позволяет использовать расширения Dapper непосредственно для типа объекта, возвращаемого API-интерфейсом клиентской библиотеки для DDR, так как он также является простым подключением клиента SQL.

Эти наблюдения упрощают использование подключений, которые проходят через клиентскую библиотеку эластичной базы данных для Dapper.

В этом примере кода (из соответствующего примера) показан подход, в котором приложение предоставляет ключ сегментирования библиотеке, чтобы подключение прошло через посредника к правильному сегменту.   

    using (SqlConnection sqlconn = shardingLayer.ShardMap.OpenConnectionForKey(
                     key: tenantId1, 
                     connectionString: connStrBldr.ConnectionString, 
                     options: ConnectionOptions.Validate))
    {
        var blog = new Blog { Name = name };
        sqlconn.Execute(@"
                      INSERT INTO
                            Blog (Name)
                            VALUES (@name)", new { name = blog.Name }
                        );
    }

Чтобы вызвать [OpenConnectionForKey](http://msdn.microsoft.com/library/azure/dn807226.aspx) , API-интерфейс заменяет создание и открытие подключения клиента SQL по умолчанию. Метод [OpenConnectionForKey](http://msdn.microsoft.com/library/azure/dn807226.aspx) при вызове принимает аргументы, которые требуются для маршрутизации, зависящей от данных. 

* сопоставление сегментов для доступа к интерфейсам маршрутизации, зависящей от данных;
* ключ сегментирования для определения шардлета;
* учетные данные (имя пользователя и пароль) для подключения к сегменту.

Объект сопоставления сегментов создает открытое подключение к сегменту, в котором содержится шардлет, соответствующий заданному ключу сегментирования. Клиентские API-интерфейсы эластичной базы данных также помечают подключение тегом для реализации гарантий согласованности. Так как при вызове [OpenConnectionForKey](http://msdn.microsoft.com/library/azure/dn807226.aspx) возвращается регулярный объект подключения клиента SQL, последующий вызов метода расширения **Execute** из Dapper выполняется по стандартной схеме.

Запросы формируются в целом одинаково: сначала открывается подключение с помощью [OpenConnectionForKey](http://msdn.microsoft.com/library/azure/dn807226.aspx) из клиентского API-интерфейса, а затем используются регулярные методы расширения Dapper для сопоставления результатов SQL-запроса в объектах .NET:

    using (SqlConnection sqlconn = shardingLayer.ShardMap.OpenConnectionForKey(
                    key: tenantId1, 
                    connectionString: connStrBldr.ConnectionString, 
                    options: ConnectionOptions.Validate ))
    {    
           // Display all Blogs for tenant 1
           IEnumerable<Blog> result = sqlconn.Query<Blog>(@"
                                SELECT * 
                                FROM Blog
                                ORDER BY Name");

           Console.WriteLine("All blogs for tenant id {0}:", tenantId1);
           foreach (var item in result)
           {
                Console.WriteLine(item.Name);
            }
    }

Обратите внимание, что блок **using** с подключением DDR ограничивает все операции базы данных в пределах блока к одному сегменту, в котором хранится tenantId1. Запрос возвращает только блоги, хранящиеся в текущем сегменте, а не в любых других сегментах. 

## <a name="data-dependent-routing-with-dapper-and-dapperextensions"></a>Маршрутизация, зависящая от данных, с использованием Dapper и DapperExtensions
В Dapper включена экосистема дополнительных расширений, которые могут обеспечивать дополнительное удобство и предоставлять абстракцию из базы данных при разработке приложений баз данных. И примером таких расширений является DapperExtensions. 

При использовании DapperExtensions в приложении способ создания подключений к базе данных и управления ими не меняется. Приложение все еще отвечает за открытие подключений, а методы расширения ожидают регулярные объекты подключений клиента SQL. Мы можем использовать [OpenConnectionForKey](http://msdn.microsoft.com/library/azure/dn807226.aspx) , как описано выше. Единственное изменение заключается в том, что больше не нужно писать операторы T-SQL, как показано в следующих примерах кода.

    using (SqlConnection sqlconn = shardingLayer.ShardMap.OpenConnectionForKey(
                    key: tenantId2, 
                    connectionString: connStrBldr.ConnectionString, 
                    options: ConnectionOptions.Validate))
    {
           var blog = new Blog { Name = name2 };
           sqlconn.Insert(blog);
    }

А вот пример кода для запроса: 

    using (SqlConnection sqlconn = shardingLayer.ShardMap.OpenConnectionForKey(
                    key: tenantId2, 
                    connectionString: connStrBldr.ConnectionString, 
                    options: ConnectionOptions.Validate))
    {
           // Display all Blogs for tenant 2
           IEnumerable<Blog> result = sqlconn.GetList<Blog>();
           Console.WriteLine("All blogs for tenant id {0}:", tenantId2);
           foreach (var item in result)
           {
               Console.WriteLine(item.Name);
           }
    }

### <a name="handling-transient-faults"></a>Обработка временных сбоев
Команда Microsoft Patterns & Practices опубликовала [блок приложений обработки временных сбоев](http://msdn.microsoft.com/library/hh680934.aspx), чтобы позволить разработчикам приложений устранять распространенные временные сбои при выполнении в облаке. Дополнительные сведения см. в статье [4 - Perseverance, Secret of All Triumphs: Using the Transient Fault Handling Application Block](http://msdn.microsoft.com/library/dn440719.aspx) (4. Настойчивость — секрет всех побед. Использование блока приложения для обработки временных ошибок).

В примере кода для защиты от временных сбоев используется библиотека временных сбоев. 

    SqlDatabaseUtils.SqlRetryPolicy.ExecuteAction(() =>
    {
       using (SqlConnection sqlconn = 
          shardingLayer.ShardMap.OpenConnectionForKey(tenantId2, connStrBldr.ConnectionString, ConnectionOptions.Validate))
          {
              var blog = new Blog { Name = name2 };
              sqlconn.Insert(blog);
          }
    });

Политика **SqlDatabaseUtils.SqlRetryPolicy** в приведенном выше коде определена как **SqlDatabaseTransientErrorDetectionStrategy** с числом попыток, равным 10, и 5-секундным временем ожидания между повторами попытки. При использовании транзакций убедитесь, что при возникновении временного сбоя область повтора переходит к началу транзакции.

## <a name="limitations"></a>Ограничения
Подходы, описанные в данном документе, имеют несколько ограничений:

* В примере кода для этого документа не показано, как управлять схемой для разных сегментов.
* Предполагается, что вся обработка в базе данных для выполнения запроса ведется в пределах одного сегмента, который идентифицируется ключом сегментирования, предоставленном в запросе. Тем не менее, это не всегда так, например, в случае, если невозможно сделать ключ сегментирования доступным. Для решения этой проблемы клиентская библиотека эластичной базы данных включает класс [MultiShardQuery](http://msdn.microsoft.com/library/azure/microsoft.azure.sqldatabase.elasticscale.query.multishardexception.aspx). Этот класс реализует абстракцию подключения для выполнения запросов нескольких сегментов. Использование MultiShardQuery вместе с EF выходит за рамки данного документа

## <a name="conclusion"></a>Заключение
Приложения, использующие Dapper и DapperExtensions, могут легко использовать преимущества средств эластичной базы данных SQL Azure. С помощью шагов, описанных в этом документе, приложения могут использовать возможности инструмента для маршрутизации, зависящей от данных. Для этого требуется изменить создание и открытие новых объектов [SqlConnection](http://msdn.microsoft.com/library/system.data.sqlclient.sqlconnection.aspx), чтобы использовать вызов [OpenConnectionForKey](http://msdn.microsoft.com/library/azure/dn807226.aspx) клиентской библиотеки эластичной базы данных. Это ограничивает внесение требуемых изменений в приложении местами создания и открытия новых подключений. 

[!INCLUDE [elastic-scale-include](../../includes/elastic-scale-include.md)]

<!--Image references-->
[1]: ./media/sql-database-elastic-scale-working-with-dapper/dapperimage1.png
