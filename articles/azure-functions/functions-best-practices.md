---
title: Рекомендации по Функциям Azure | Документация Майкрософт
description: Ознакомьтесь с рекомендациями и шаблонами для Функций Azure.
services: functions
documentationcenter: na
author: wesmc7777
manager: cfowler
editor: ''
tags: ''
keywords: Функции Azure, шаблоны, рекомендация, функции, обработка событий, объекты webhook, динамические вычисления, бессерверная архитектура
ms.assetid: 9058fb2f-8a93-4036-a921-97a0772f503c
ms.service: functions
ms.devlang: multiple
ms.topic: article
ms.tgt_pltfrm: multiple
ms.workload: na
ms.date: 10/16/2017
ms.author: glenga
ms.custom: H1Hack27Feb2017
ms.openlocfilehash: 19ca9d70f769a19556d131d1d131f1bc9d107ef0
ms.sourcegitcommit: 48ab1b6526ce290316b9da4d18de00c77526a541
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/23/2018
---
# <a name="optimize-the-performance-and-reliability-of-azure-functions"></a>Оптимизация производительности и надежности Функций Azure

В этой статье описано, как повысить производительность и надежность [бессерверных](https://azure.microsoft.com/overview/serverless-computing/) приложений-функций. 

## <a name="general-best-practices"></a>Общие рекомендации

Ниже приведены рекомендации по созданию и разработке бессерверных решений с помощью службы "Функции Azure".

### <a name="avoid-long-running-functions"></a>Избегайте длительных функций

Крупные длительные функции могут вызывать непредвиденные проблемы времени ожидания. Функция может стать крупной, если она содержит множество зависимостей Node.js. Импорт зависимостей может также привести к замедлению загрузки, что, в свою очередь, приводит к непредвиденным проблемам времени ожидания. Зависимости можно загрузить явно и неявно. Один модуль, загруженный в коде, может загрузить собственные дополнительные модули.  

По возможности выполняйте рефакторинг крупных функций и перерабатывайте их на более мелкие совместимые наборы функций, которые работают сообща и быстро возвращают ответ. Например, для функции веб-перехватчика или триггера HTTP может потребоваться подтверждение в течение ограниченного промежутка времени. Чаще всего для веб-перехватчиков требуется немедленный ответ. Полезные данные триггера HTTP можно передать в очередь для обработки с помощью функции триггера очереди. Такой подход позволяет отложить фактическую работу и сразу возвратить ответ.


### <a name="cross-function-communication"></a>Взаимодействие функций

[Устойчивые функции](durable-functions-overview.md) и [Azure Logic Apps](../logic-apps/logic-apps-overview.md) используются для управления переходами состояний и обмена данными между несколькими функциями.

Если для интеграции нескольких функций не используются устойчивые функции или Logic Apps, для обмена данными между функциями лучше всего использовать очереди хранилища,  так как они дешевле и их гораздо проще подготовить к работе. 

Размер отдельных сообщений в очереди хранилища ограничен до 64 КБ. Если между функциями нужно передать сообщения большего размера, можно использовать очередь служебной шины Azure, которая поддерживает сообщения размером до 256 КБ на уровне "Стандартный" и 1 МБ на уровне "Премиум".

Если перед обработкой сообщений их нужно отфильтровать, ознакомьтесь со статьями о служебной шине.

Для поддержки обмена крупными сообщениями используются концентраторы событий.


### <a name="write-functions-to-be-stateless"></a>Создавайте функции без отслеживания состояния 

По возможности функции должны быть без отслеживания состояния и идемпотентными. Свяжите любые необходимые сведения о состоянии со своими данными. Например, с обрабатываемым заказом скорее всего будет связан элемент `state`. Функция может обработать заказ, основываясь на этом состоянии, но в ней самой при этом не отслеживается состояние. 

Идемпотентные функции рекомендуется использовать с триггерами таймера. Например, если какой-либо компонент нужно выполнять раз в день, пропишите его таким образом, чтобы он выполнялся в любое время в течение дня с тем же результатом. Функцию можно закрыть, если в определенный день ничего не нужно делать. Кроме того, если предыдущее выполнение завершилось ошибкой, следующее выполнение должно начаться с прерванного момента.


### <a name="write-defensive-functions"></a>Создавайте защищенные функции

Предположим, что в любое время в функции может возникнуть исключение. Реализуйте в функции возможность продолжения с предыдущей точки сбоя во время следующего выполнения. Давайте рассмотрим сценарий, в котором необходимо сделать следующее:

1. Запросить 10 000 строк в базе данных.
2. Создать сообщение очереди для каждой из этих строк для дальнейшей обработки.
 
В зависимости от сложности системы, подчиненные службы могут работать неправильно, могут происходить сбои в работе сети или нарушения лимитов квоты и т. д. Все это может в любое время повлиять на функцию. Функции необходимо подготавливать к таким проблемам.

Как отреагирует ваш код при сбое после вставки 5000 элементов в очередь для обработки? Отслеживайте элементы в наборе, работа с которым завершена. В противном случае их можно вставить позже. Это может серьезно повлиять на рабочий процесс. 

Если элемент очереди уже обработан, разрешите холостой цикл выполнения функции.

Воспользуйтесь предоставленными возможностями защиты для компонентов, используемых на платформе Функций Azure. Например, ознакомьтесь с разделом **Обработка подозрительных сообщений очереди** в документации по [триггерам и привязкам очереди службы хранилища Azure](functions-bindings-storage-queue.md#trigger---poison-messages). 

## <a name="scalability-best-practices"></a>Рекомендации по масштабируемости

То, как выполняется масштабирование экземпляров приложения-функции, зависит от нескольких факторов. Дополнительные сведения см. в документации по [масштабированию функций](functions-scale.md).  Ниже приведены рекомендации по оптимальному масштабированию приложения-функции.

### <a name="dont-mix-test-and-production-code-in-the-same-function-app"></a>Не используйте тестовый и рабочий код в одном приложении-функции

Функции в приложении-функции совместно используют ресурсы. Например, память. Если приложение-функция используется в рабочей среде, не добавляйте в нее тестовые функции и ресурсы. Это может вызвать непредвиденные затраты во время выполнения кода в рабочей среде.

Следите за тем, что вы загружаете в рабочие приложения-функции. Память усредняется для каждой функции в приложении.

При наличии общей сборки, указанной в нескольких функциях .Net, поместите ее в общую папку. Создайте ссылку на сборку с помощью оператора, аналогичного следующему, если вы используете скрипты C# (CSX-файлы): 

    #r "..\Shared\MyAssembly.dll". 

В противном случае очень просто случайно развернуть несколько тестовых версий одного двоичного файла, которые действуют по-разному в разных функциях.

Не используйте подробное ведение журнала в рабочем коде. Это отрицательно сказывается на производительности.

### <a name="use-async-code-but-avoid-blocking-calls"></a>Использование асинхронного кода без блокирующих вызовов

Рекомендуется применять метод асинхронного программирования. Но никогда не используйте ссылки на свойство `Result` и не вызывайте метод `Wait` для экземпляра `Task`. Применение этого подхода может привести к нехватке потоков.

[!INCLUDE [HTTP client best practices](../../includes/functions-http-client-best-practices.md)]

### <a name="receive-messages-in-batch-whenever-possible"></a>По возможности получайте сообщения в пакетном режиме

Некоторые триггеры, например триггер концентратора событий, позволяют получать сообщения в пакетном режиме в рамках одного вызова.  Пакетная обработка сообщений обеспечивает более высокую производительность.  Вы можете настроить максимальный размер пакета в файле `host.json`, как описано в [справочной документации по host.json](functions-host-json.md).

При работе с C# тип функций можно изменить на строго типизированный массив.  Например, вместо `EventData sensorEvent` можно использовать сигнатуру метода `EventData[] sensorEvent`.  При работе с другими языками необходимо явно задать свойство кратности, указав в файле `function.json`значение `many`. Так вы включите пакетную обработку, [как показано здесь](https://github.com/Azure/azure-webjobs-sdk-templates/blob/df94e19484fea88fc2c68d9f032c9d18d860d5b5/Functions.Templates/Templates/EventHubTrigger-JavaScript/function.json#L10).

### <a name="configure-host-behaviors-to-better-handle-concurrency"></a>Настройте поведение узла для обеспечения оптимального параллелизма

Файл `host.json` в приложении-функции позволяет настраивать среду выполнения узла и поведение триггера.  Кроме настройки поведения пакетной обработки, вы можете управлять параллелизмом определенного числа триггеров.  Часто настройка этих параметров помогает масштабировать каждый экземпляр согласно требованиям вызванных функций.

Параметры в файле узлов применяются ко всем функциям приложения в пределах *одного экземпляра* функции. Например, если у вас есть приложение-функция с двумя функциями HTTP, настроенная на обработку 25 параллельных запросов, любой запрос к одному из триггеров HTTP будет считаться одним из общих 25 параллельных запросов.  Если это приложение-функция масштабировать до 10 экземпляров, две функции смогут эффективно обрабатывать 250 параллельных запросов (10 экземпляров х 25 параллельных запросов для каждой функции).

**Варианты параллелизма узла HTTP**

[!INCLUDE [functions-host-json-http](../../includes/functions-host-json-http.md)]

Другие параметры конфигурации узла см. в [документации по конфигурации узлов](functions-host-json.md).

## <a name="next-steps"></a>Дополнительная информация
Для получения дополнительных сведений см. следующие ресурсы:

Так как Функции Azure используют службу приложений Azure, необходимо также ознакомиться с рекомендациями для нее.
* [Шаблоны и методики оптимизации производительности HTTP](https://docs.microsoft.com/azure/architecture/antipatterns/improper-instantiation/)
