---
title: Управление версиями в устойчивых функциях — Azure
description: Сведения о том, как выполнять управление в расширении устойчивых функций для Функций Azure.
services: functions
author: cgillum
manager: cfowler
editor: ''
tags: ''
keywords: ''
ms.service: functions
ms.devlang: multiple
ms.topic: article
ms.tgt_pltfrm: multiple
ms.workload: na
ms.date: 09/29/2017
ms.author: azfuncdf
ms.openlocfilehash: 0a86e4a87f5ec23c284aa4e5cfb2c67622b3ebe9
ms.sourcegitcommit: 6699c77dcbd5f8a1a2f21fba3d0a0005ac9ed6b7
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/11/2017
ms.locfileid: "22991289"
---
# <a name="versioning-in-durable-functions-azure-functions"></a>Управление версиями в устойчивых функциях (Функции Azure)

Функции добавляются, удаляются и изменяются на протяжении времени существования приложения. [Устойчивые функции](durable-functions-overview.md) позволяют связывать функции ранее недоступными способами, и это влияет на управление версиями.

## <a name="how-to-handle-breaking-changes"></a>Как управлять критическими изменениями

Есть несколько критических изменений, о которых следует знать. В этой статье рассматриваются самые распространенные из них. Общим для них является то, что на новую и имеющуюся функции оркестрации влияют изменения кода функции.

### <a name="changing-activity-function-signatures"></a>Изменение сигнатур функций действий

Изменение сигнатуры относится к изменению имени, входных или выходных данных функции. Если для функции действия применено такое изменение, это может привести к нарушению функции оркестратора, которая зависит от этого. Обновление функции оркестратора для применения этого изменения может привести к нарушению работы имеющихся активных экземпляров.

Предположим, что у вас есть следующая функция.

```csharp
[FunctionName("FooBar")]
public static Task Run([OrchestrationTrigger] DurableOrchestrationContext context)
{
    bool result = await context.CallActivityAsync<bool>("Foo");
    await context.CallActivityAsync("Bar", result);
}
```

Эта упрощенная функция принимает результаты **Foo** и передает их в **Bar**. Предположим, что нужно изменить возвращаемое значение **Foo** с `bool` на `int` для поддержки более широкого набора итоговых значений. Результат должен выглядеть следующим образом:

```csharp
[FunctionName("FooBar")]
public static Task Run([OrchestrationTrigger] DurableOrchestrationContext context)
{
    int result = await context.CallActivityAsync<int>("Foo");
    await context.CallActivityAsync("Bar", result);
}
```

Это изменение никак не сказывается на всех новых экземплярах функции оркестратора, но нарушает работу активных экземпляров. Например, рассмотрим случай, когда экземпляр оркестрации вызывает **Foo**, ему сначала возвращается логическое значение, а затем контрольные точки. Если на этой точке развернуто изменение сигнатуры, экземпляр с контрольной точкой завершится ошибкой сразу после возобновления работы и воспроизведения вызова `context.CallActivityAsync<int>("Foo")`. Это происходит, так как результатом в таблице журнала является `bool`, а новый код пытается десериализировать его в `int`.

Это лишь один из примеров того, как изменения сигнатуры могут нарушить работу имеющихся экземпляров. Как правило, изменение способа вызова функции для оркестратора может привести к проблемам.

### <a name="changing-orchestrator-logic"></a>Изменение логики оркестратора

Другой класс проблем с управлением версиями связан с изменением кода функции оркестратора способом, который может сбить с толку логику воспроизведения для активных экземпляров.

Рассмотрим следующую функцию оркестратора:

```csharp
[FunctionName("FooBar")]
public static Task Run([OrchestrationTrigger] DurableOrchestrationContext context)
{
    bool result = await context.CallActivityAsync<bool>("Foo");
    await context.CallActivityAsync("Bar", result);
}
```

Теперь предположим, что нужно внести небольшое изменение, чтобы добавить другой вызов функции.

```csharp
[FunctionName("FooBar")]
public static Task Run([OrchestrationTrigger] DurableOrchestrationContext context)
{
    bool result = await context.CallActivityAsync<bool>("Foo");
    if (result)
    {
        await context.CallActivityAsync("SendNotification");
    }

    await context.CallActivityAsync("Bar", result);
}
```

Это изменение добавит новый вызов функции в **SendNotification** между **Foo** и **Bar**. Изменения сигнатуры отсутствуют. Проблема возникает, когда имеющийся экземпляр возобновляет работу после вызова **Bar**. Во время воспроизведения, если при исходном вызове **Foo** возвращается значение `true`, то воспроизведение функции оркестратора приводит к вызову **SendNotification**, который находится вне его журнала выполнений. В результате платформа устойчивых задач завершается сбоем с `NonDeterministicOrchestrationException` из-за выполнения вызова **SendNotification** вместо **Bar**.

## <a name="mitigation-strategies"></a>Стратегии устранения рисков

Ниже приведены некоторые стратегии для устранения проблем с управлением версиями:

* ничего не предпринимать;
* остановить все активные экземпляры;
* выполнить параллельное развертывание.

### <a name="do-nothing"></a>Ничего не предпринимать

Самая простая реакция на критическое изменение — позволить активным экземплярам оркестрации завершиться сбоем. Новые экземпляры успешно выполняют измененный код.

Является ли это проблемой, зависит от важности активных экземпляров. Эта проблема не критична, если вы активно выполняете разработку и активные экземпляры не имеют значения. Тем не менее необходимо обрабатывать исключения и ошибки в конвейере диагностики. Если вы хотите этого избежать, необходимо рассмотреть другие варианты управления версиями.

### <a name="stop-all-in-flight-instances"></a>Остановка всех активных экземпляров

Другим вариантом является остановка всех активных экземпляров. Это можно сделать путем очистки содержимого внутренних очередей **управления** и **рабочих элементов**. Экземпляры не удаляются, но они не будут отображаться в телеметрии вместе с сообщениями о сбое. Это идеально подходит для быстрой разработки прототипов.

> [!WARNING]
> Со временем сведения об этих очередях могут изменяться, поэтому не рекомендуется использовать этот метод для рабочих нагрузок.

### <a name="side-by-side-deployments"></a>Выполнение параллельного развертывания

Параллельное развертывание с более старыми версиями — наиболее отказоустойчивый способ обеспечить безопасное развертывание критических изменений. Это можно сделать с помощью любого из следующих способов:

* Развертывание всех обновлений в качестве совершенно новых функций (новые имена).
* Развертывание всех обновлений в качестве нового приложения-функции с помощью другой учетной записи хранения.
* Развертывание новой копии приложения-функции с обновленным именем `TaskHub`. Рекомендуем использовать этот метод.

### <a name="how-to-change-task-hub-name"></a>Как изменить имя центра задач

Имя центра задач можно настроить в файле *host.json* следующим образом:

```json
{
    "durableTask": {
        "HubName": "MyTaskHubV2"
    }
}
```

По умолчанию используется значение `DurableFunctionsHub`.

Все сущности в службе хранилища Azure именуются на основе значения конфигурации `HubName`. Задавая новое имя для центра задач, вы гарантируете, что для новой версии приложения будут созданы отдельные очереди и таблица журнала.

Мы советуем развертывать новую версию приложения-функции в новый [слот развертывания](https://blogs.msdn.microsoft.com/appserviceteam/2017/06/13/deployment-slots-preview-for-azure-functions/). Слоты развертывания позволяют параллельно запускать несколько копий приложения-функции, при этом только один слот может быть активным *рабочим* слотом. Предоставить новую логику оркестрации для имеющейся инфраструктуры может быть так же просто, как заменить новую версию в рабочем слоте.

> [!NOTE]
> Эта стратегия оптимально подходит при использовании триггеров HTTP и веб-перехватчика для функций оркестратора. Для триггеров, отличных от HTTP, таких как очереди или концентраторы событий, определение триггера должно основываться на параметре приложения, который обновляется в рамках операции замены.

## <a name="next-steps"></a>Дополнительная информация

> [!div class="nextstepaction"]
> [Узнайте, как управлять проблемами с производительностью и масштабированием](durable-functions-perf-and-scale.md)
