---
title: Контрольные точки и воспроизведение в устойчивых функциях — Azure
description: Сведения о работе контрольных точек и воспроизведении в расширении устойчивых функций для Функций Azure.
services: functions
author: cgillum
manager: cfowler
editor: ''
tags: ''
keywords: ''
ms.service: functions
ms.devlang: multiple
ms.topic: article
ms.tgt_pltfrm: multiple
ms.workload: na
ms.date: 09/29/2017
ms.author: azfuncdf
ms.openlocfilehash: 39cdb9b2c6eae9a3176aedc64b8d187e298fdfdd
ms.sourcegitcommit: e221d1a2e0fb245610a6dd886e7e74c362f06467
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/07/2018
ms.locfileid: "33764576"
---
# <a name="checkpoints-and-replay-in-durable-functions-azure-functions"></a>Контрольные точки и воспроизведение в устойчивых функциях (Функции Azure)

Одним из ключевых атрибутов устойчивых функций является **надежное выполнение**. Функции оркестратора и функции действий могут выполняться на разных виртуальных машинах в центре обработки данных. Эти виртуальные машины или базовая сетевая инфраструктура не полностью надежные.

Несмотря на это устойчивые функции гарантируют надежное выполнение оркестрации. Они используют очереди хранилища, чтобы управлять вызовом функции, а также создают контрольные точки в журнале выполнения в таблицах хранилища (с помощью конструктивных шаблонов облачных решений, также известных как [шаблоны источников событий](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing)). Этот журнал затем воспроизводится, чтобы автоматически перестроить состояние в памяти функции оркестратора.

## <a name="orchestration-history"></a>Журнал оркестраций

Предположим, что у вас есть следующая функция оркестратора:

#### <a name="c"></a>C#

```csharp
[FunctionName("E1_HelloSequence")]
public static async Task<List<string>> Run(
    [OrchestrationTrigger] DurableOrchestrationContext context)
{
    var outputs = new List<string>();

    outputs.Add(await context.CallActivityAsync<string>("E1_SayHello", "Tokyo"));
    outputs.Add(await context.CallActivityAsync<string>("E1_SayHello", "Seattle"));
    outputs.Add(await context.CallActivityAsync<string>("E1_SayHello", "London"));

    // returns ["Hello Tokyo!", "Hello Seattle!", "Hello London!"]
    return outputs;
}
```

#### <a name="javascript-functions-v2-only"></a>JavaScript (только для решения "Функции" версии 2)

```javascript
const df = require("durable-functions");

module.exports = df(function*(context) {
    const output = [];
    output.push(yield context.df.callActivityAsync("E1_SayHello", "Tokyo"));
    output.push(yield context.df.callActivityAsync("E1_SayHello", "Seattle"));
    output.push(yield context.df.callActivityAsync("E1_SayHello", "London"));

    return output;
});
```

В каждой инструкции `await` (C#) или `yield` (JavaScript) платформа устойчивых задач создает контрольные точки состояния выполнения функции в хранилище таблиц. Это состояние также называется *журналом оркестрации*.

## <a name="history-table"></a>Таблица журнала

Как правило, платформа устойчивых задач выполняет следующие действия в каждой контрольной точке:

1. Сохраняет журнал выполнения в таблицах службы хранилища Azure.
2. Помещает в очередь сообщения для функций, которые хочет вызвать оркестратор.
3. Помещает в очередь сообщения для самого оркестратора, например сообщения устойчивого таймера.

После создания контрольной точки функцию оркестратора можно удалить из памяти, пока для нее не появится работа.

> [!NOTE]
> Служба хранилища Azure не предоставляет никаких гарантий выполнения транзакций между сохранением данных в хранилище таблиц и очередях. Для обработки ошибок поставщик хранилища устойчивых функций использует шаблоны *итоговой согласованности*. Эти шаблоны позволяют избежать потери данных в случае аварийного завершения или потери возможности подключения в середине контрольной точки.

По завершении приведенный выше журнал функций будет выглядеть примерно следующим образом в хранилище таблиц Azure (следующий пример приведен в сокращенном виде):

| PartitionKey (InstanceId)                     | EventType             | Timestamp               | Входные данные | ИМЯ             | Результат                                                    | Status | 
|----------------------------------|-----------------------|----------|--------------------------|-------|------------------|-----------------------------------------------------------|---------------------| 
| eaee885b | OrchestratorStarted   | 2017-05-05T18:45:32.362Z |       |                  |                                                           |                     | 
| eaee885b | ExecutionStarted      | 2017-05-05T18:45:28.852Z | null  | E1_HelloSequence |                                                           |                     | 
| eaee885b | TaskScheduled         | 2017-05-05T18:45:32.670Z |       | E1_SayHello      |                                                           |                     | 
| eaee885b | OrchestratorCompleted | 2017-05-05T18:45:32.670Z |       |                  |                                                           |                     | 
| eaee885b | OrchestratorStarted   | 2017-05-05T18:45:34.232Z |       |                  |                                                           |                     | 
| eaee885b | TaskCompleted         | 2017-05-05T18:45:34.201Z |       |                  | """Hello Tokyo!"""                                        |                     | 
| eaee885b | TaskScheduled         | 2017-05-05T18:45:34.435Z |       | E1_SayHello      |                                                           |                     | 
| eaee885b | OrchestratorCompleted | 2017-05-05T18:45:34.435Z |       |                  |                                                           |                     | 
| eaee885b | OrchestratorStarted   | 2017-05-05T18:45:34.857Z |       |                  |                                                           |                     | 
| eaee885b | TaskCompleted         | 2017-05-05T18:45:34.763Z |       |                  | """Hello Seattle!"""                                      |                     | 
| eaee885b | TaskScheduled         | 2017-05-05T18:45:34.857Z |       | E1_SayHello      |                                                           |                     | 
| eaee885b | OrchestratorCompleted | 2017-05-05T18:45:34.857Z |       |                  |                                                           |                     | 
| eaee885b | OrchestratorStarted   | 2017-05-05T18:45:35.032Z |       |                  |                                                           |                     | 
| eaee885b | TaskCompleted         | 2017-05-05T18:45:34.919Z |       |                  | """Hello London!"""                                       |                     | 
| eaee885b | ExecutionCompleted    | 2017-05-05T18:45:35.044Z |       |                  | "[""Hello Tokyo!"",""Hello Seattle!"",""Hello London!""]" | Завершено           | 
| eaee885b | OrchestratorCompleted | 2017-05-05T18:45:35.044Z |       |                  |                                                           |                     | 

Некоторые сведения о значениях столбцов:
* **PartitionKey.** Содержит идентификатор экземпляра оркестрации.
* **EventType.** Предоставляет тип события. Принимается один из следующих типов:
    * **OrchestrationStarted.** Функция оркестратора, которая возобновлена после состояния ожидания или выполняется впервые. Столбец `Timestamp` используется, чтобы заполнить детерминированное значение для API [CurrentUtcDateTime](https://azure.github.io/azure-functions-durable-extension/api/Microsoft.Azure.WebJobs.DurableOrchestrationContext.html#Microsoft_Azure_WebJobs_DurableOrchestrationContext_CurrentUtcDateTime).
    * **ExecutionStarted.** Функция оркестратора, которая начала выполнение впервые. Это событие также содержит входные данные функции в столбце `Input`.
    * **TaskScheduled.** Функция действия была запланирована. Имя функции действия сохраняется в столбце `Name`.
    * **TaskCompleted.** Функция действия выполнена. Результаты функции находятся в столбце `Result`.
    * **TimerCreated.** Устойчивый таймер создан. Столбец `FireAt` содержит запланированное время в формате UTC, когда истекает срок действия таймера.
    * **TimerFired.** Активирован устойчивый таймер.
    * **EventRaised.** Внешнее событие было отправлено в экземпляр оркестрации. Столбец `Name` содержит имя события, а столбец `Input` — полезные данные события.
    * **OrchestratorCompleted.** Функция оркестратора находится в состоянии ожидания.
    * **ContinueAsNew.** Функция оркестратора выполнена и автоматически перезапущена с новым состоянием. Столбец `Result` содержит значение, которое используется в качестве входных данных в перезапущенном экземпляре.
    * **ExecutionCompleted.** Функция оркестратора выполнена (или завершилась сбоем). Выходные данные функции или сведения об ошибке хранятся в столбце `Result`.
* **Timestamp.** Метка времени события журнала в формате UTC.
* **Name.** Имя вызванной функции.
* **Input.** Входные данные функции в формате JSON.
* **Result.** Выходные данные функции (то есть ее возвращаемое значение).

> [!WARNING]
> Хотя это удобно использовать в качестве средства отладки, не используйте в таблице никакие зависимости. Они могут измениться при развитии расширения устойчивых функций.

Каждый раз, когда функция возобновляется из состояния `await`, платформа устойчивых задач повторно выполняет функцию оркестратора с нуля. При каждом повторном выполнении она учитывает журнал выполнения, чтобы определить, выполнялась ли асинхронная операция.  Если операция выполнялась, платформа немедленно воспроизводит выходные данные этой операции и переходит к следующему объекту с состоянием `await`. Этот процесс продолжается, пока весь журнал не будет воспроизведен. После этого все локальные переменные в функции оркестратора восстанавливают свои прежние значения.

## <a name="orchestrator-code-constraints"></a>Ограничения кода оркестратора

Поведение воспроизведения ограничивает тип кода, который может быть записан в функцию оркестратора.

* Код оркестратора должен быть **детерминированным**. Он будет воспроизведен несколько раз и должен каждый раз выдавать одинаковый результат. Например, не должно быть прямых вызовов, чтобы получить текущие дату и время, получить случайные числа, создать случайные значения GUID, а также вызовов удаленных конечных точек.

  Если коду оркестратора нужно получить текущие значения даты и времени, он должен использовать API [CurrentUtcDateTime](https://azure.github.io/azure-functions-durable-extension/api/Microsoft.Azure.WebJobs.DurableOrchestrationContext.html#Microsoft_Azure_WebJobs_DurableOrchestrationContext_CurrentUtcDateTime), который безопасен для воспроизведения.

  В функциях действий должны выполняться недетерминированные операции. Сюда входят любые взаимодействия с другими входными или выходными привязками. Это гарантирует, что все недетерминированные значения будут создаваться один раз при первом выполнении и сохранятся в журнал выполнения. Последующие выполнения будут автоматически использовать сохраненные значения.

* Код оркестратора не должен иметь **блокировки**. Например, это означает отсутствие операций ввода-вывода и вызовов `Thread.Sleep` или эквивалентных API.

  Если для оркестратора требуется задержка, он может использовать API [CreateTimer](https://azure.github.io/azure-functions-durable-extension/api/Microsoft.Azure.WebJobs.DurableOrchestrationContext.html#Microsoft_Azure_WebJobs_DurableOrchestrationContext_CreateTimer_).

* Код оркестратора никогда не должен **запускать асинхронную операцию**, разве что с помощью API [DurableOrchestrationContext](https://azure.github.io/azure-functions-durable-extension/api/Microsoft.Azure.WebJobs.DurableOrchestrationContext.html). Например, запрещено использовать `Task.Run`, `Task.Delay` или `HttpClient.SendAsync`. Платформа устойчивых задач выполняет код оркестратора в одном потоке и не может взаимодействовать с другими потоками, которые могут планироваться другими асинхронными API.

* **Следует избегать бесконечных циклов** в коде оркестратора. Так как платформа устойчивых задач сохраняет журнал выполнения в ходе работы функции оркестрации, бесконечный цикл может привести к нехватке памяти для экземпляра оркестратора. Для сценариев с бесконечным циклом используйте API, например [ContinueAsNew](https://azure.github.io/azure-functions-durable-extension/api/Microsoft.Azure.WebJobs.DurableOrchestrationContext.html#Microsoft_Azure_WebJobs_DurableOrchestrationContext_ContinueAsNew_), чтобы перезапустить выполнение функции и отменить предыдущий журнал выполнения.

Хотя эти ограничения могут показаться пугающими, на практике им легко следовать. Платформа устойчивых задач пытается обнаружить нарушения приведенных выше правил и выдает исключение `NonDeterministicOrchestrationException`. Тем не менее это поведение обнаружения является лучшим вариантом и вы не должны от него зависеть.

> [!NOTE]
> Все эти правила применяются только к функциям, активированным привязкой `orchestrationTrigger`. Функции действий, активированные привязкой `activityTrigger`, и функции, использующие привязку`orchestrationClient`, не имеют таких ограничений.

## <a name="durable-tasks"></a>Устойчивые задачи

> [!NOTE]
> Этот раздел содержит сведения о внутренней реализации платформы устойчивых задач. Вы можете использовать устойчивые функции, не зная эту информацию. Она предназначена только для того, чтобы помочь вам понять поведение воспроизведения.

Задачи, которые могут безопасно ожидаться в функциях оркестратора, иногда называются *устойчивыми задачами*. Создание этих задач и управление ими осуществляется с помощью платформы устойчивых задач. Примерами являются задачи, возвращаемые `CallActivityAsync`, `WaitForExternalEvent`, и `CreateTimer`.

Управление этими *устойчивыми задачами* выполняется внутренне с помощью списка объектов `TaskCompletionSource`. Во время воспроизведения эти задачи создаются как часть выполнения кода оркестратора и завершаются, когда диспетчер перечисляет соответствующие события журнала. Это все выполняется синхронно с помощью одного потока до тех пор, пока весь журнал не будет воспроизведен. Для всех устойчивых задач, не завершенных до конца воспроизведения журнала, выполняются соответствующие действия. Например, сообщение может быть поставлено в очередь для вызова функции действия.

Описанное здесь поведение выполнения должно помочь вам понять, почему код функции оркестратора никогда не должен ожидать неустойчивые задачи. Поток диспетчера не может ожидать их завершения, а любой обратный вызов этой задачи может повредить состояние отслеживания функции оркестратора. Чтобы этого избежать, выполняются некоторые проверки среды выполнения.

Чтобы получить дополнительные сведения о том, как платформа устойчивых задач выполняет функции оркестратора, ознакомьтесь с [исходным кодом устойчивых задач на сайте GitHub](https://github.com/Azure/durabletask). В частности, просмотрите сведения о [TaskOrchestrationExecutor.cs](https://github.com/Azure/durabletask/blob/master/src/DurableTask.Core/TaskOrchestrationExecutor.cs) и [TaskOrchestrationContext.cs](https://github.com/Azure/durabletask/blob/master/src/DurableTask.Core/TaskOrchestrationContext.cs)

## <a name="next-steps"></a>Дополнительная информация

> [!div class="nextstepaction"]
> [Узнайте больше об управлении экземплярами](durable-functions-instance-management.md)
