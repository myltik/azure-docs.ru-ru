---
title: "Работа с прокси в Функциях Azure | Документация Майкрософт"
description: "Общие сведения об использовании прокси Функций Azure"
services: functions
documentationcenter: 
author: mattchenderson
manager: cfowler
editor: 
ms.assetid: 
ms.service: functions
ms.workload: na
ms.tgt_pltfrm: na
ms.devlang: multiple
ms.topic: article
ms.date: 04/11/2017
ms.author: mahender
ms.translationtype: Human Translation
ms.sourcegitcommit: 5e92b1b234e4ceea5e0dd5d09ab3203c4a86f633
ms.openlocfilehash: 102e54627a8fee721d3ed85e86a8009e706bb5b1
ms.contentlocale: ru-ru
ms.lasthandoff: 05/10/2017

---
# <a name="work-with-azure-functions-proxies-preview"></a>Работа с прокси в Функциях Azure (предварительная версия)

> [!NOTE] 
> Сейчас доступна предварительная версия прокси Функций Azure. Предварительная версия предоставляется бесплатно, но на выполнение прокси распространяется стандартная тарификация Функций. Дополнительные сведения см. на странице [цен на Функции Azure](https://azure.microsoft.com/pricing/details/functions/).

В этой статье описано, как настроить прокси Функций Azure и работать с ними. Эта функция позволяет указать конечные точки в приложении-функции, реализуемые другим ресурсом. Эти прокси можно использовать для разбиения большого API-интерфейса на несколько приложений-функций (как в архитектуре микрослужб), сохраняя при этом единую область API для клиентов.

[!INCLUDE [intro](../../includes/functions-bindings-intro.md)]


## <a name="enable"></a>Включение прокси-серверов Функций Azure

По умолчанию прокси не включены. Вы можете создавать прокси, когда функция отключена, но они не будут выполняться. Чтобы включить прокси-серверы, сделайте следующее:

1. Откройте [портал Azure] и перейдите к своему приложению-функции.
2. Выберите **Параметры приложения-функции**.
3. Включите **параметр** **Включить прокси-серверы для функций Azure (предварительная версия)**.

Вы можете также возвращаться сюда для обновления среды выполнения прокси по мере появления новых функций.


## <a name="create"></a>Создание прокси-сервера

В этом разделе показано, как создать прокси-сервер на портале Функций.

1. Откройте [портал Azure] и перейдите к своему приложению-функции.
2. В левой области выберите **Создать прокси-сервер**.
3. Задайте имя прокси.
4. Настройте конечную точку в этом приложении-функции, указав **шаблон маршрута** и **методы HTTP**. Поведение этих параметров соответствует правилам для [триггеров HTTP].
5. Задайте **URL-адрес внутреннего сервера** для другой конечной точки. Ею может быть функция в другом приложении-функции или другой API. Значение не обязательно должно быть статическим и может ссылаться на [параметры приложения] и [параметры исходного запроса клиента].
6. Щелкните **Создать**.

Прокси теперь существует в виде новой конечной точки в приложении-функции. С точки зрения клиента это аналогично HttpTrigger в Функциях Azure. Можно испытать новый прокси, скопировав URL-адрес прокси и протестировав его с помощью избранного клиента HTTP.

## <a name="modify-requests-responses"></a>Изменение запросов и ответов

Прокси-серверы для Функций Azure позволяют изменять запросы и ответы из внутреннего сервера. При таком преобразовании используются переменные, указанные в разделе [Использование переменных].

### <a name="modify-backend-request"></a>Изменение запроса внутреннего сервера

По умолчанию запрос внутреннего сервера инициализируется в качестве копии исходного запроса. Кроме настройки URL-адреса внутреннего сервера вы также можете изменить метод, заголовки и параметры строки запроса HTTP. Измененные значения могут ссылаться на [параметры приложения] и [параметры исходного запроса клиента].

Сейчас на портале не предусмотрена возможность изменения запросов внутреннего сервера. Чтобы узнать, как использовать эту возможность в файле proxies.json, ознакомьтесь с разделом [Определение объекта requestOverrides].

### <a name="modify-response"></a>Изменение ответа

По умолчанию ответ клиента инициализируется в качестве копии ответа внутреннего сервера. Вы можете изменить код состояния, описание, заголовки и текст ответа. Измененные значения могут ссылаться на [параметры приложения], [параметры исходного запроса клиента] и [параметры ответа внутреннего сервера].

Сейчас на портале не предусмотрена возможность изменения ответов. Чтобы узнать, как использовать эту возможность в файле proxies.json, ознакомьтесь с разделом [Определение объекта responseOverrides].

## <a name="using-variables"></a>Использование переменных

Использовать статическую конфигурацию для прокси-сервера необязательно. Вы можете настроить для него использование переменных из исходного запроса, ответа внутреннего сервера или параметров приложения.

### <a name="request-parameters"></a>Ссылки на параметры запроса

Параметры запроса можно использовать в качестве входных данных для свойства URL-адреса внутреннего сервера или в рамках изменения запросов и ответов. Некоторые параметры могут быть связаны с шаблоном маршрута, указанным в основной конфигурации прокси-сервера, тогда как другие задаются в соответствии со свойствами входящих запросов.

#### <a name="route-template-parameters"></a>Параметры шаблона маршрута
Параметры, используемые в шаблоне маршрута, указываются по именам, которые заключаются в фигурные скобки — {}.

Например, если прокси-сервер использует шаблон маршрута, подобный `/pets/{petId}`, URL-адрес внутреннего сервера может содержать значение `{petId}`, как в `https://<AnotherApp>.azurewebsites.net/api/pets/{petId}`. Если шаблон маршрута заканчивается подстановочным знаком, например `/api/{*restOfPath}`, значение `{restOfPath}` будет строковым представлением остальных сегментов пути входящего запроса.

#### <a name="additional-request-parameters"></a>Дополнительные параметры запроса
В дополнение к параметрам шаблона маршрута вы можете использовать следующие значения конфигурации:

* **{request.method}.** Метод HTTP, используемый в исходном запросе.
* **{request.headers.\<имя_заголовка\>}.** Заголовок, который можно считать из исходного запроса. Замените *\<имя_заголовка\>* именем заголовка, который вы собираетесь считать. Если заголовок не включен в запрос, в качестве значения будет отображаться пустая строка.
* **{request.querystring.\<имя_параметра\>}.** Параметр строки запроса, который можно считать из исходного запроса. Замените *\<имя_параметра\>* именем параметра, который вы собираетесь считать. Если параметр не включен в запрос, в качестве значения будет отображаться пустая строка.

### <a name="response-parameters"></a>Ссылки на параметры ответа внутреннего сервера

Параметры ответа можно использовать при изменении ответов для клиента. Следующие значения можно использовать в качестве значений конфигурации:

* **{backend.response.statusCode}.** Код состояния HTTP, возвращаемый для ответа внутреннего сервера.
* **{backend.response.statusReason}.** Код состояния HTTP, возвращаемый для ответа внутреннего сервера.
* **{backend.response.headers.\<имя_заголовка\>}.** Заголовок, который можно считать из ответа внутреннего сервера. Замените *\<имя_заголовка\>* именем заголовка, который вы собираетесь считать. Если заголовок не включен в запрос, в качестве значения будет отображаться пустая строка.

### <a name="use-appsettings"></a>Ссылки на параметры приложения

Вы также можете ссылаться на [параметры приложения, определенные для приложения-функции](https://docs.microsoft.com/azure/azure-functions/functions-how-to-use-azure-function-app-settings#develop), поставив знаки процента (%) перед именем параметра и после него.

Например, в URL-адресе внутреннего сервера *https://%ORDER_PROCESSING_HOST%/api/orders* %ORDER_PROCESSING_HOST% будет заменено значением параметра ORDER_PROCESSING_HOST.

> [!TIP] 
> Используйте параметры приложения для внутренних узлов при наличии нескольких развертываний или тестовых сред. Таким образом, вы будете всегда обращаться к правильному внутреннему серверу в этой среде.

## <a name="advanced-configuration"></a>Расширенная конфигурация

Настроенные прокси хранятся в файле proxies.json, расположенном в корневом каталоге приложения-функции. Вы можете вручную изменить этот файл и развернуть его как часть приложения, используя любой из [методов развертывания](https://docs.microsoft.com/azure/azure-functions/functions-continuous-deployment), поддерживаемых Функциями. Для обработки файла функция должна быть [включена](#enable). 

> [!TIP] 
> Вы также можете работать с файлом proxies.json на портале, если вы не настроили ни один из методов развертывания. Перейдите к приложению-функции и выберите **Функции платформы**, а затем — **Редактор службы приложений**. Так вы сможете просмотреть всю структуру файла приложения-функции и внести изменения.

Файл proxies.json определяется объектом прокси, который состоит из именованных прокси и их определений. При необходимости для автозавершения кода можно ссылаться на [схему JSON](http://json.schemastore.org/proxies), если ваш редактор поддерживает такую возможность. Например, файл может выглядеть следующим образом:

```json
{
    "$schema": "http://json.schemastore.org/proxies",
    "proxies": {
        "proxy1": {
            "matchCondition": {
                "methods": [ "GET" ],
                "route": "/api/{test}"
            },
            "backendUri": "https://<AnotherApp>.azurewebsites.net/api/<FunctionName>"
        }
    }
}
```

Каждый прокси имеет понятное имя, как например *proxy1* в предыдущем примере. Соответствующий объект определения прокси определяется следующими свойствами:

* **matchCondition** (обязательное) — объект, который определяет запросы, активирующие выполнение этого прокси-сервера. Он содержит два свойства, используемые совместно с [триггеров HTTP]:
    * _methods_ — массив методов HTTP, на которые отвечает прокси-сервер. Если свойство не указано, прокси-сервер будет отвечать на все методы HTTP в маршруте.
    * _route_ (обязательное) — шаблон маршрута, определяющий URL-адреса запросов, на которые будет отвечать прокси-сервер. В отличие от триггеров HTTP значение по умолчанию отсутствует.
* **backendUri** — URL-адрес внутреннего ресурса, к которому должен быть отправлен запрос. Это значение может ссылаться на параметры приложения и параметры исходного запроса клиента. Если это свойство не включено, Функции Azure вернут ответ HTTP 200 OK.
* **requestOverrides.** Объект, определяющий преобразование запросов внутреннего сервера. Ознакомьтесь с разделом [Определение объекта requestOverrides].
* **responseOverrides.** Объект, определяющий преобразование ответа клиента. Ознакомьтесь с разделом [Определение объекта responseOverrides].

> [!NOTE] 
> Свойство route прокси-сервера Функций Azure не учитывает свойство routePrefix конфигурации узла Функций. Если вы хотите включить префикс, например /api, он должен быть включен в свойство route.

### <a name="requestOverrides"></a>Определение объекта requestOverrides

Объект requestOverrides определяет изменения, внесенные в запрос во время вызова внутреннего ресурса. Объект определяется следующими свойствами:

* **backend.request.method.** Метод HTTP, используемый для вызова внутреннего сервера.
* **backend.request.querystring.\<имя_параметра\>.** Параметр строки запроса, который можно задать для вызова внутреннего сервера. Замените *\<имя_параметра\>* именем параметра, который вы собираетесь задать. Если указана пустая строка, параметр не включается в запрос внутреннего сервера.
* **backend.request.headers.\<имя_заголовка\>.** Заголовок, который можно задать для вызова внутреннего сервера. Замените *\<имя_заголовка\>* именем заголовка, который вы собираетесь задать. Если указана пустая строка, заголовок не включается в запрос внутреннего сервера.

Значения могут ссылаться на параметры приложения и параметры исходного запроса клиента.

Пример конфигурации может выглядеть следующим образом:

```json
{
    "$schema": "http://json.schemastore.org/proxies",
    "proxies": {
        "proxy1": {
            "matchCondition": {
                "methods": [ "GET" ],
                "route": "/api/{test}"
            },
            "backendUri": "https://<AnotherApp>.azurewebsites.net/api/<FunctionName>",
            "requestOverrides": {
                "backend.request.headers.Accept": "application/xml",
                "backend.request.headers.x-functions-key": "%ANOTHERAPP_API_KEY%"
            }
        }
    }
}
```

### <a name="responseOverrides"></a>Определение объекта responseOverrides

Объект requestOverrides определяет изменения, внесенные в ответ, который передается обратно к клиенту. Объект определяется следующими свойствами:

* **response.statusCode.** Код состояния HTTP, который будет возвращен клиенту.
* **response.statusReason.** Описание HTTP, которое будет возвращено клиенту.
* **response.body.** Строковое представление текста, который будет возвращен клиенту.
* **response.headers.\<имя_заголовка\>.** Заголовок, который можно задать для ответа клиенту. Замените *\<имя_заголовка\>* именем заголовка, который вы собираетесь задать. Если указана пустая строка, заголовок не включается в ответ.

Значения могут ссылаться на параметры приложения, параметры исходного запроса клиента и параметры ответа внутреннего сервера.

Пример конфигурации может выглядеть следующим образом:

```json
{
    "$schema": "http://json.schemastore.org/proxies",
    "proxies": {
        "proxy1": {
            "matchCondition": {
                "methods": [ "GET" ],
                "route": "/api/{test}"
            },
            "responseOverrides": {
                "response.body": "Hello, {test}",
                "response.headers.Content-Type": "text/plain"
            }
        }
    }
}
```
> [!NOTE] 
> В этом примере текст задается напрямую, поэтому задавать свойство `backendUri` не требуется. В примере показано, как можно использовать прокси-серверы Функций Azure для имитации API.

[портал Azure]: https://portal.azure.com
[триггеров HTTP]: https://docs.microsoft.com/azure/azure-functions/functions-bindings-http-webhook#http-trigger
[Modify the back-end request]: #modify-backend-request
[Modify the response]: #modify-response
[Определение объекта requestOverrides]: #requestOverrides
[Определение объекта responseOverrides]: #responseOverrides
[параметры приложения]: #use-appsettings
[Использование переменных]: #using-variables
[параметры исходного запроса клиента]: #request-parameters
[параметры ответа внутреннего сервера]: #response-parameters

