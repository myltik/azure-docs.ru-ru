---
title: Проверка подлинности. Средство моделирования угроз Microsoft Azure | Документация Майкрософт
description: Устранение угроз, обнаруженных с помощью средства моделирования угроз
services: security
documentationcenter: na
author: RodSan
manager: RodSan
editor: RodSan
ms.assetid: na
ms.service: security
ms.workload: na
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 08/17/2017
ms.author: rodsan
ms.openlocfilehash: 1ac614156755b9b29db7c968c708a5cff706f7a8
ms.sourcegitcommit: 9890483687a2b28860ec179f5fd0a292cdf11d22
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/24/2018
ms.locfileid: "28019676"
---
# <a name="security-frame-authentication--mitigations"></a>Механизм безопасности. Проверка подлинности | Устранение рисков 
| Продукт или служба | Статья |
| --------------- | ------- |
| **Веб-приложение**    | <ul><li>[Рассмотрите возможность использования стандартного механизма проверки подлинности в веб-приложениях](#standard-authn-web-app)</li><li>[Приложения должны надежно обрабатывать сценарии неудачной проверки подлинности](#handle-failed-authn)</li><li>[Включите проверку подлинности повышенного уровня или адаптивную проверку подлинности](#step-up-adaptive-authn)</li><li>[Интерфейсы администрирования должны быть заблокированы соответствующим образом](#admin-interface-lockdown)</li><li>[Реализуйте безопасный механизм восстановления пароля](#forgot-pword-fxn)</li><li>[Настройте применение политик учетных записей и паролей](#pword-account-policy)</li><li>[Реализуйте элементы управления для предотвращения перечисления имен пользователей](#controls-username-enum)</li></ul> |
| **База данных** | <ul><li>[По возможности используйте проверку подлинности Windows для подключения к SQL Server](#win-authn-sql)</li><li>[По возможности используйте проверку подлинности Azure Active Directory для подключения к базе данных SQL](#aad-authn-sql)</li><li>[Если используется режим проверки подлинности SQL, обеспечьте применение политики учетных записей и паролей на сервере SQL Server](#authn-account-pword)</li><li>[Не используйте проверку подлинности SQL в автономных базах данных](#autn-contained-db)</li></ul> |
| **Концентратор событий Azure** | <ul><li>[Используйте учетные данные проверки подлинности на уровне отдельного устройства с помощью маркеров SaS](#authn-sas-tokens)</li></ul> |
| **Граница доверия Azure** | <ul><li>[Включите Многофакторную идентификацию Azure для администраторов Azure](#multi-factor-azure-admin)</li></ul> |
| **Граница доверия Service Fabric** | <ul><li>[Запретите анонимный доступ к кластеру Service Fabric](#anon-access-cluster)</li><li>[Сертификат Service Fabric для обмена данными между клиентом и узлом должен отличаться от простого сертификата для обмена данными между узлами](#fabric-cn-nn)</li><li>[Используйте AAD для проверки подлинности клиентов в кластерах Service Fabric](#aad-client-fabric)</li><li>[Нужно использовать сертификаты Service Fabric, полученные из утвержденного Центра сертификации](#fabric-cert-ca)</li></ul> |
| **Сервер удостоверений** | <ul><li>[Используйте стандартные сценарии проверки подлинности, поддерживаемые сервером удостоверений](#standard-authn-id)</li><li>[Переопределите кэш маркеров сервера удостоверений по умолчанию масштабируемым альтернативным кэшем](#override-token)</li></ul> |
| **Граница доверия между компьютерами** | <ul><li>[Двоичные файлы развернутого приложения должны иметь цифровую подпись](#binaries-signed)</li></ul> |
| **WCF** | <ul><li>[Включите проверку подлинности при подключении к очередям MSMQ в WCF](#msmq-queues)</li><li>[WCF: не присваивайте атрибуту message clientCredentialType значение None](#message-none)</li><li>[WCF: не присваивайте атрибуту transport clientCredentialType значение None](#transport-none)</li></ul> |
| **Веб-интерфейс API** | <ul><li>[Для защиты веб-API нужно использовать стандартные методы проверки подлинности](#authn-secure-api)</li></ul> |
| **Azure AD** | <ul><li>[Используйте стандартные сценарии проверки подлинности, поддерживаемые Azure Active Directory](#authn-aad)</li><li>[Переопределите кэш маркера ADAL по умолчанию масштабируемым альтернативным кэшем](#adal-scalable)</li><li>[Для предотвращения воспроизведения маркеров проверки подлинности ADAL нужно использовать свойство TokenReplayCache](#tokenreplaycache-adal)</li><li>[Используйте библиотеки ADAL для управления запросами маркеров от клиентов OAuth2 к AAD (или к локальной службе AD)](#adal-oauth2)</li></ul> |
| **Полевой шлюз Интернета вещей** | <ul><li>[Проверяйте подлинность устройств, подключаемых к полевому шлюзу](#authn-devices-field)</li></ul> |
| **Облачный шлюз Интернета вещей** | <ul><li>[Устройства, подключаемые к облачному шлюзу, должны проходить проверку подлинности](#authn-devices-cloud)</li><li>[Используйте учетные данные проверки подлинности на уровне отдельного устройства](#authn-cred)</li></ul> |
| **Хранилище Azure** | <ul><li>[Анонимный доступ на чтение должен быть предоставлен только к необходимым контейнерам и большим двоичным объектам](#req-containers-anon)</li><li>[Предоставьте ограниченный доступ к объектам в службе хранилища Azure с помощью SAS или SAP](#limited-access-sas)</li></ul> |

## <a id="standard-authn-web-app"></a>Рассмотрите возможность использования стандартного механизма проверки подлинности в веб-приложениях

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-приложение | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальный |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | Недоступно  |
| Сведения | <p>Проверка подлинности — это процесс, во время которого сущность подтверждает свою подлинность с помощью учетных данных, таких как имя пользователя и пароль. Существует множество протоколов проверки подлинности, включая следующие:</p><ul><li>Client certificates</li><li>на основе Windows;</li><li>на основе форм;</li><li>федерация: ADFS;</li><li>федерация: Azure AD;</li><li>федерация: сервер удостоверений.</li></ul><p>Рассмотрите возможность использования стандартного механизма проверки подлинности для идентификации исходного процесса.</p>|

## <a id="handle-failed-authn"></a>Приложения должны надежно обрабатывать сценарии неудачной проверки подлинности

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-приложение | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальный |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | Недоступно  |
| Сведения | <p>Приложения, которые явно проверяют подлинность пользователей, должны безопасно обрабатывать сценарии неудачной проверки подлинности. Механизм проверки подлинности должен:</p><ul><li>запрещать доступ к привилегированным ресурсам при сбое проверки подлинности;</li><li>отображать общее сообщение об ошибке после неудачной проверки подлинности и запрета доступа.</li></ul><p>Проверьте, обеспечивает ли механизм проверки подлинности следующее:</p><ul><li>защиту привилегированных ресурсов после неудачных попыток входа;</li><li>отображение общего сообщения об ошибке после неудачной проверки подлинности и запрета доступа;</li><li>отключение учетных записей после слишком большого количества неудачных попыток.</li><ul>|

## <a id="step-up-adaptive-authn"></a>Включите проверку подлинности повышенного уровня или адаптивную проверку подлинности

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-приложение | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальный |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | Недоступно  |
| Сведения | <p>Убедитесь, что приложение имеет дополнительную авторизацию (проверку подлинности повышенного уровня или адаптивную проверку подлинности через службу Многофакторной идентификации, например с отправкой одноразового пароля в SMS, сообщении электронной почты и т. д. или запрос повторной проверки подлинности), которую пользователь должен пройти, прежде чем получить доступ к конфиденциальной информации. Это правило также применяется для внесения критически важных изменений в учетную запись или в действие.</p><p>Это означает, что адаптация проверки подлинности должна быть реализована таким образом, чтобы приложение правильно применяло контекстно-зависимую авторизацию и не допускало несанкционированные манипуляции, например путем изменения параметров.</p>|

## <a id="admin-interface-lockdown"></a>Интерфейсы администрирования должны быть заблокированы соответствующим образом

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-приложение | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальный |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | Недоступно  |
| Сведения | Для начала предоставьте доступ к интерфейсу администрирования только для исходного диапазона IP-адресов. Если это решение невозможно, рекомендуется применить проверку подлинности повышенного уровня или адаптивную проверку подлинности для входа в интерфейс администрирования. |

## <a id="forgot-pword-fxn"></a>Реализуйте безопасный механизм восстановления пароля

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-приложение | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальный |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | Недоступно  |
| Сведения | <p>Прежде всего убедитесь, что в случае потери паролей и для восстановления по другим причинам отправляется ссылка, содержащая маркер активации с ограниченным временем действия, а не сам пароль. Также перед отправкой ссылки может потребоваться дополнительная проверка подлинности на основе программных маркеров (SMS-маркер, собственное мобильное приложение и т. д.). Во-вторых, вам не следует блокировать учетные записи пользователей во время процедуры получения нового пароля.</p><p>Это может привести к атаке типа "отказ в обслуживании" всякий раз, когда злоумышленник решит намеренно блокировать пользователей с помощью автоматизированных атак. В-третьих, сообщение, которое отображается во время выполнения запроса нового пароля, должно быть обобщенным во избежание перечисления имен пользователей. В-четвертых, всегда запрещайте использовать старые пароли и реализуйте политику надежных паролей.</p> |

## <a id="pword-account-policy"></a>Настройте применение политик учетных записей и паролей

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-приложение | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальный |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | Недоступно  |
| Сведения | <p>Политика паролей и учетных записей должна быть реализована в соответствии с политикой организации и рекомендациями.</p><p>Для защиты от атак методом прямого подбора и подбора на основе словаря необходимо реализовать политику надежных паролей, чтобы пользователи создавали сложные пароли (например, длиной не менее 12 символов, а также содержащие алфавитно-цифровые или специальные символы).</p><p>Политики блокировки учетных записей можно реализовать следующим образом:</p><ul><li>**Мягкая блокировка.** Может быть хорошим вариантом для защиты пользователей от атак методом прямого подбора. Например, всякий раз, когда пользователь вводит неверный пароль три раза подряд, приложение может заблокировать учетную запись на минуту, чтобы замедлить процесс прямого подбора пароля, сделав его менее выгодным для злоумышленника. Если в этом случае реализовать жесткую блокировку, это приведет к "отказу в обслуживании" и окончательно заблокирует учетные записи. Кроме того, приложение может создать одноразовый пароль и отправить его пользователю по внештатному каналу (по электронной почте, SMS и т. д.). Как вариант, можно реализовать проверку CAPTCHA по достижении порогового значения числа неудачных попыток.</li><li>**Жесткая блокировка.** Этот тип блокировки следует применять всякий раз при обнаружении атаки пользователя на ваше приложение. В качестве контрмеры можно окончательно заблокировать его учетную запись до тех пор, пока группа реагирования не проведет экспертизу. После этой процедуры вы можете разблокировать учетную запись пользователя или принять в отношении него дальнейшие юридические меры. Такой подход не позволит злоумышленнику продолжить атаки на приложение и инфраструктуру.</li></ul><p>Для защиты от атак на прогнозируемые учетные записи и учетные записи по умолчанию все ключи и пароли должны быть заменяемыми, а также быть созданы или заменены с момента их создания.</p><p>Если приложение автоматически создает пароли, они должны создаваться случайным образом и иметь высокий уровень энтропии.</p>|

## <a id="controls-username-enum"></a>Реализуйте элементы управления для предотвращения перечисления имен пользователей

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-приложение | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальный |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | Недоступно  |
| **Действия** | Во избежание перечисления имен пользователей все сообщения об ошибках должны быть обобщенными. Иногда не удается избежать утечки информации при использовании определенного компонента или функции, например страницы регистрации пользователя. В таких случаях, чтобы предотвратить автоматизированные атаки, необходимо использовать методы ограничения скорости обращений к странице, например CAPTCHA. |

## <a id="win-authn-sql"></a>По возможности используйте проверку подлинности Windows для подключения к SQL Server

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | База данных | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Локальные |
| **Атрибуты**              | Версия SQL: все |
| **Справочные материалы**              | [Выбор режима проверки подлинности](https://msdn.microsoft.com/library/ms144284.aspx) |
| **Действия** | Проверка подлинности Windows использует протокол безопасности Kerberos, политику паролей с применением проверки сложности для надежности паролей, поддерживает блокировку учетных записей и ограничение срока действия паролей.|

## <a id="aad-authn-sql"></a>По возможности используйте проверку подлинности Azure Active Directory для подключения к базе данных SQL

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | База данных | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | SQL Azure |
| **Атрибуты**              | Версия SQL: 12 |
| **Справочные материалы**              | [Подключение к базе данных SQL с использованием проверки подлинности Azure Active Directory](https://azure.microsoft.com/documentation/articles/sql-database-aad-authentication/) |
| **Действия** | **Минимальная версия.** Чтобы разрешить базе данных SQL использовать проверку подлинности AAD в каталоге Майкрософт, необходимо использовать базу данных SQL Azure версии 12. |

## <a id="authn-account-pword"></a>Если используется режим проверки подлинности SQL, обеспечьте применение политики учетных записей и паролей на сервере SQL Server

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | База данных | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальный |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [Политика паролей](https://technet.microsoft.com/library/ms161959(v=sql.110).aspx) |
| **Действия** | При использовании проверки подлинности SQL Server создаются имена входа, которые не основаны на учетных записях Windows. Имя пользователя и пароль создаются и хранятся в SQL Server. SQL Server может использовать механизмы политики паролей Windows. К паролям, используемым в SQL Server, можно применить те же политики ограничения срока действия и сложности, которые применяются в Windows. |

## <a id="autn-contained-db"></a>Не используйте проверку подлинности SQL в автономных базах данных

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | База данных | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Локальное, SQL Azure |
| **Атрибуты**              | Версия SQL: MSSQL2012, версия SQL: 12 |
| **Справочные материалы**              | [Рекомендации по обеспечению безопасности автономных баз данных](http://msdn.microsoft.com/library/ff929055.aspx) |
| **Действия** | Отсутствие принудительной политики паролей может увеличить вероятность установки слабых учетных данных в автономной базе данных. Используйте проверку подлинности Windows. |

## <a id="authn-sas-tokens"></a>Используйте учетные данные проверки подлинности на уровне отдельного устройства с помощью маркеров SaS

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | концентратору событий Azure | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальный |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [Обзор проверки подлинности концентраторов событий и модели безопасности](https://azure.microsoft.com/documentation/articles/event-hubs-authentication-and-security-model-overview/) |
| **Действия** | <p>В основе модели безопасности концентраторов событий лежит сочетание издателей событий и маркеров подписанных URL-адресов (SAS). Имя издателя представляет идентификатор устройства, которое получает маркер. Это поможет связать маркеры, созданные с помощью соответствующих устройств.</p><p>Все сообщения помечаются отправителем на стороне службы, что дает возможность обнаруживать попытки подделки происхождения в полезных данных. При проверке подлинности устройств создавайте маркер SaS для каждого устройства с использованием уникального издателя.</p>|

## <a id="multi-factor-azure-admin"></a>Включите Многофакторную идентификацию Azure для администраторов Azure

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Граница доверия Azure | 
| **Этап SDL**               | Развертывание |  
| **Применимые технологии** | Универсальный |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [Что такое Многофакторная идентификация Azure?](https://azure.microsoft.com/documentation/articles/multi-factor-authentication/) |
| **Действия** | <p>Многофакторная идентификация Azure (MFA) — это метод аутентификации, который требует применения более одного метода проверки и добавляет критически важный второй уровень безопасности для операций входа и транзакций пользователя. Во время работы он требует использования двух и более методов проверки следующего характера:</p><ul><li>Что-то, что известно вам (обычно это пароль).</li><li>Что-то, что у вас есть (доверенное устройство, которое непросто дублируется, такое как телефон).</li><li>Что-то, относящееся непосредственно к вам (биометрические данные).</li><ul>|

## <a id="anon-access-cluster"></a>Запретите анонимный доступ к кластеру Service Fabric

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Граница доверия Service Fabric | 
| **Этап SDL**               | Развертывание |  
| **Применимые технологии** | Универсальный |
| **Атрибуты**              | Среда: Azure  |
| **Справочные материалы**              | [Сценарии защиты кластера Service Fabric](https://azure.microsoft.com/documentation/articles/service-fabric-cluster-security) |
| **Действия** | <p>Кластеры всегда должны быть защищены для предотвращения подключения к ним неавторизованных пользователей, особенно в тех случаях, когда на кластере выполняются рабочие нагрузки в рабочей среде.</p><p>При создании кластера Service Fabric убедитесь, что для режима безопасности задано значение "seсure", и настройте требуемый сертификат сервера X.509. Создание незащищенного кластера позволит любому анонимному пользователю подключаться к нему, если конечные точки управления кластером общедоступны через Интернет.</p>|

## <a id="fabric-cn-nn"></a>Сертификат Service Fabric для обмена данными между клиентом и узлом должен отличаться от простого сертификата для обмена данными между узлами

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Граница доверия Service Fabric | 
| **Этап SDL**               | Развертывание |  
| **Применимые технологии** | Универсальный |
| **Атрибуты**              | Среда: Azure, автономная |
| **Справочные материалы**              | [Сценарии защиты кластера Service Fabric](https://azure.microsoft.com/documentation/articles/service-fabric-cluster-security/#_client-to-node-certificate-security), [Безопасное подключение к кластеру](https://azure.microsoft.com/documentation/articles/service-fabric-connect-to-secure-cluster/) |
| **Действия** | <p>Безопасность обмена данными между клиентами и узлами на основе сертификатов настраивается при создании кластера (на портале Azure, с помощью шаблонов Resource Manager или автономного шаблона JSON). Для этого указывается сертификат клиента администрирования и (или) пользовательский сертификат клиента.</p><p>Эти сертификаты должны отличаться от основного и дополнительного сертификатов, указанных для защиты обмена данными между узлами.</p>|

## <a id="aad-client-fabric"></a>Используйте AAD для проверки подлинности клиентов в кластерах Service Fabric

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Граница доверия Service Fabric | 
| **Этап SDL**               | Развертывание |  
| **Применимые технологии** | Универсальный |
| **Атрибуты**              | Среда: Azure |
| **Справочные материалы**              | [Рекомендации по обеспечению безопасности](https://azure.microsoft.com/documentation/articles/service-fabric-cluster-security/#security-recommendations) |
| **Действия** | Для защиты доступа к конечным точкам управления, помимо сертификатов клиентов, кластеры под управлением Azure также могут использовать Azure Active Directory (AAD). Чтобы обеспечить безопасность обмена данными между узлами в кластерах Azure, рекомендуется использовать безопасность AAD для аутентификации клиентов и сертификатов.|

## <a id="fabric-cert-ca"></a>Нужно использовать сертификаты Service Fabric, полученные из утвержденного Центра сертификации

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Граница доверия Service Fabric | 
| **Этап SDL**               | Развертывание |  
| **Применимые технологии** | Универсальный |
| **Атрибуты**              | Среда: Azure |
| **Справочные материалы**              | [Сертификаты X.509 и Service Fabric](https://azure.microsoft.com/documentation/articles/service-fabric-cluster-security/#x509-certificates-and-service-fabric) |
| **Действия** | <p>Для проверки подлинности узлов и клиентов Service Fabric использует сертификаты сервера X.509.</p><p>При использовании сертификатов в Service Fabric следует учитывать некоторые важные моменты:</p><ul><li>Сертификаты, которые используются в кластерах, выполняющих рабочие нагрузки в рабочей среде, следует создать с помощью правильно настроенной службы сертификации Windows Server или получить из утвержденного центра сертификации. Центр сертификации может быть утвержденным внешним центром сертификации или правильно управляемой внутренней инфраструктурой открытых ключей (PKI).</li><li>Никогда не используйте в рабочей среде какие-либо временные или тестовые сертификаты, созданные с помощью таких инструментов, как MakeCert.exe.</li><li>Можно использовать самозаверяющий сертификат, но это следует делать только для тестовых кластеров, а не в рабочей среде.</li></ul>|

## <a id="standard-authn-id"></a>Используйте стандартные сценарии проверки подлинности, поддерживаемые сервером удостоверений

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Сервер удостоверений | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальный |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [IdentityServer3. Общая картина](https://identityserver.github.io/Documentation/docsv2/overview/bigPicture.html) |
| **Действия** | <p>Ниже приведены типичные взаимодействия, поддерживаемые сервером удостоверений.</p><ul><li>Браузеры взаимодействуют с веб-приложениями.</li><li>Веб-приложения взаимодействуют с веб-API (иногда самостоятельно, иногда от имени пользователя).</li><li>Браузерные приложения взаимодействуют с веб-API.</li><li>Собственные приложения взаимодействуют с веб-API.</li><li>Серверные приложения взаимодействуют с веб-API.</li><li>Веб-API взаимодействуют с веб-API (иногда самостоятельно, иногда от имени пользователя).</li></ul>|

## <a id="override-token"></a>Переопределите кэш маркеров сервера удостоверений по умолчанию масштабируемым альтернативным кэшем

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Сервер удостоверений | 
| **Этап SDL**               | Развертывание |  
| **Применимые технологии** | Универсальный |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [Развертывание сервера удостоверений. Кэширование](https://identityserver.github.io/Documentation/docsv2/advanced/deployment.html) |
| **Действия** | <p>Сервер удостоверений имеет простой встроенный кэш, работающий в памяти. Хотя он хорошо подходит для небольших собственных приложений, он не масштабируется для приложений среднего уровня и приложений уровня сервера по следующим причинам.</p><ul><li>Доступ к этим приложениям осуществляют несколько пользователей одновременно. Если сохранять все маркеры доступа в одном хранилище, могут возникнуть трудности с изоляцией, которые вызовут проблемы при увеличении масштаба. При множестве пользователей с количеством маркеров, равным количеству ресурсов, к которым приложение обращается от их имени, может стать больше ресурсоемких операций поиска сопоставлений.</li><li>Эти приложения обычно развертываются в распределенной топологии, где несколько узлов должны иметь доступ к одному кэшу.</li><li>Кэшированные маркеры должны выдерживать перезапуски и деактивации процесса.</li><li>По указанным выше причинам при реализации веб-приложений рекомендуется переопределить кэш маркеров сервера удостоверений по умолчанию масштабируемым альтернативным кэшем, например кэшем Redis для Azure.</li></ul>|

## <a id="binaries-signed"></a>Двоичные файлы развернутого приложения должны иметь цифровую подпись

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Отношения доверия между компьютерами | 
| **Этап SDL**               | Развертывание |  
| **Применимые технологии** | Универсальный |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | Недоступно  |
| **Действия** | Убедитесь, что все двоичные файлы развернутого приложения имеют цифровую подпись, что дает возможность проверить их целостность.|

## <a id="msmq-queues"></a>Включите проверку подлинности при подключении к очередям MSMQ в WCF

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | WCF | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальные, .NET Framework 3 |
| **Атрибуты**              | Недоступно |
| **Справочные материалы**              | [MSDN](https://msdn.microsoft.com/library/ff648500.aspx) |
| **Действия** | Если при подключении к очередям MSMQ программе не удается включить проверку подлинности, злоумышленник может анонимно отправить сообщения в очередь для обработки. Если для подключения к очереди MSMQ, которая используется для доставки сообщения в другую программу, проверка подлинности отсутствует, злоумышленник может анонимно отправить вредоносное сообщение.|

### <a name="example"></a>Пример
Элемент `<netMsmqBinding/>` расположенного ниже файла конфигурации WCF указывает WCF отключить проверку подлинности при подключении к очереди MSMQ для доставки сообщений.
```
<bindings>
    <netMsmqBinding>
        <binding>
            <security>
                <transport msmqAuthenticationMode=""None"" />
            </security>
        </binding>
    </netMsmqBinding>
</bindings>
```
Настройте в MSMQ обязательную проверку подлинности сертификата или домена Windows для всех входящих или исходящих сообщений.

### <a name="example"></a>Пример
Элемент `<netMsmqBinding/>` расположенного ниже файла конфигурации WCF указывает WCF включить проверку подлинности сертификата при подключении к очереди MSMQ. Клиент проходит проверку подлинности с использованием сертификатов X.509. Сертификат клиента должен присутствовать в хранилище сертификатов сервера.
```
<bindings>
    <netMsmqBinding>
        <binding>
            <security>
                <transport msmqAuthenticationMode=""Certificate"" />
            </security>
        </binding>
    </netMsmqBinding>
</bindings>
```

## <a id="message-none"></a>WCF: не присваивайте атрибуту message clientCredentialType значение None

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | WCF | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | .NET Framework 3 |
| **Атрибуты**              | Тип учетных данных клиента: None |
| **Справочные материалы**              | [MSDN](https://msdn.microsoft.com/library/ff648500.aspx), [Fortify](https://vulncat.fortify.com/en/vulncat/index.html) |
| **Действия** | Отсутствие проверки подлинности означает, что каждый может получить доступ к этой службе. Служба, которая не выполняет проверку подлинности своих клиентов, предоставляет доступ всем пользователям. Настройте в приложении проверку подлинности учетных данных клиента. Это можно сделать, задав для атрибута message clientCredentialType значение Windows или Certificate. |

### <a name="example"></a>Пример
```
<message clientCredentialType=""Certificate""/>
```

## <a id="transport-none"></a>WCF: не присваивайте атрибуту transport clientCredentialType значение None

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | WCF | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальные, .NET Framework 3 |
| **Атрибуты**              | Тип учетных данных клиента: None |
| **Справочные материалы**              | [MSDN](https://msdn.microsoft.com/library/ff648500.aspx), [Fortify](https://vulncat.fortify.com/en/vulncat/index.html) |
| **Действия** | Отсутствие проверки подлинности означает, что каждый может получить доступ к этой службе. Служба, которая не выполняет проверку подлинности своих клиентов, предоставляет доступ к своим функциям всем пользователям. Настройте в приложении проверку подлинности учетных данных клиента. Это можно сделать, задав для атрибута transport clientCredentialType значение Windows или Certificate. |

### <a name="example"></a>Пример
```
<transport clientCredentialType=""Certificate""/>
```

## <a id="authn-secure-api"></a>Для защиты веб-API нужно использовать стандартные методы проверки подлинности

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Веб-интерфейс API | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальный |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [Проверка подлинности и авторизация в веб-API ASP.NET](http://www.asp.net/web-api/overview/security/authentication-and-authorization-in-aspnet-web-api), [сведения о внешних службах проверки подлинности с веб-API ASP.NET (C#)](http://www.asp.net/web-api/overview/security/external-authentication-services) |
| **Действия** | <p>Проверка подлинности — это процесс, во время которого сущность подтверждает свою подлинность с помощью учетных данных, таких как имя пользователя и пароль. Существует множество протоколов проверки подлинности, включая следующие:</p><ul><li>Client certificates</li><li>на основе Windows;</li><li>на основе форм;</li><li>федерация: ADFS;</li><li>федерация: Azure AD;</li><li>федерация: сервер удостоверений.</li></ul><p>Ссылки в разделе справочных сведений предоставляют низкоуровневые сведения о том, как можно реализовать каждую схему проверки подлинности для защиты веб-API.</p>|

## <a id="authn-aad"></a>Используйте стандартные сценарии проверки подлинности, поддерживаемые Azure Active Directory

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Azure AD | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальный |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [Сценарии аутентификации в Azure Active Directory](https://azure.microsoft.com/documentation/articles/active-directory-authentication-scenarios/), [Примеры кода Azure Active Directory](https://azure.microsoft.com/documentation/articles/active-directory-code-samples/), [Руководство разработчика по Azure Active Directory](https://azure.microsoft.com/documentation/articles/active-directory-developers-guide/) |
| **Действия** | <p>Azure Active Directory (Azure AD) упрощает аутентификацию для разработчиков, предоставляя удостоверение как услугу, благодаря поддержке стандартных протоколов, например OAuth 2.0 и OpenID Connect. Ниже приведены пять основных сценариев приложений, которые поддерживает служба Azure AD.</p><ul><li>Из веб-браузера в веб-приложение. Пользователю нужно войти в веб-приложение, защиту которого выполняет Azure AD.</li><li>Одностраничное приложение (SPA). Пользователю нужно войти в одностраничное приложение, защиту которого выполняет Azure AD.</li><li>Из собственного приложения в веб-интерфейс API. Собственному приложению, которое выполняется на телефоне, планшете или ПК, требуется проверить подлинность пользователя для получения ресурсов из веб-интерфейса API, защиту которого обеспечивает Azure AD.</li><li>Из веб-приложения в веб-интерфейс API. Веб-приложению требуется получать ресурсы из веб-интерфейса API, защиту которого обеспечивает Azure AD.</li><li>Из управляющей программы или серверного приложения в веб-интерфейс API. Управляющей программе (демону) или серверному приложению, в котором нет веб-интерфейса пользователя, требуется получить ресурсы из веб-интерфейса API, защиту которого обеспечивает Azure AD.</li></ul><p>Используйте ссылки в разделе справочных сведений, чтобы получить низкоуровневые сведения о реализации.</p>|

## <a id="adal-scalable"></a>Переопределите кэш маркера ADAL по умолчанию масштабируемым альтернативным кэшем

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Azure AD | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальный |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [Современная проверка подлинности с помощью Azure Active Directory для веб-приложений](https://blogs.msdn.microsoft.com/microsoft_press/2016/01/04/new-book-modern-authentication-with-azure-active-directory-for-web-applications/), [запись блога об использовании Redis в качестве кэша маркеров ADAL](https://blogs.msdn.microsoft.com/mrochon/2016/09/19/using-redis-as-adal-token-cache/)  |
| **Действия** | <p>Кэш по умолчанию, который использует ADAL, — это работающий в памяти кэш, который зависит от статического хранилища и доступен на уровне процессов. Хотя он подходит для собственных приложений, он не масштабируется для приложений среднего уровня и приложений уровня сервера по следующим причинам.</p><ul><li>Доступ к этим приложениям осуществляют несколько пользователей одновременно. Если сохранять все маркеры доступа в одном хранилище, могут возникнуть трудности с изоляцией, которые вызовут проблемы при увеличении масштаба. При множестве пользователей с количеством маркеров, равным количеству ресурсов, к которым приложение обращается от их имени, может стать больше ресурсоемких операций поиска сопоставлений.</li><li>Эти приложения обычно развертываются в распределенной топологии, где несколько узлов должны иметь доступ к одному кэшу.</li><li>Кэшированные маркеры должны выдерживать перезапуски и деактивации процесса.</li></ul><p>По указанным выше причинам при реализации веб-приложений рекомендуется переопределить кэш маркеров ADAL по умолчанию масштабируемым альтернативным кэшем, например кэшем Redis для Azure.</p>|

## <a id="tokenreplaycache-adal"></a>Для предотвращения воспроизведения маркеров проверки подлинности ADAL нужно использовать свойство TokenReplayCache

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Azure AD | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальный |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [Современная проверка подлинности с помощью Azure Active Directory для веб-приложений](https://blogs.msdn.microsoft.com/microsoft_press/2016/01/04/new-book-modern-authentication-with-azure-active-directory-for-web-applications/) |
| **Действия** | <p>Свойство TokenReplayCache позволяет разработчикам определять кэш воспроизведения маркеров, хранилище, которое можно использовать для сохранения маркеров, чтобы предотвратить использование повторяющихся маркеров.</p><p>Эта мера защиты от распространенных атак с использованием воспроизведения маркеров. Злоумышленник, который перехватывает маркер, отправленный при входе в систему, может попытаться снова отправить его в приложение ("воспроизвести" его), чтобы создать новый сеанс. Например, в потоке предоставления кода OIDC после успешной проверки подлинности пользователя запрос к конечной точке "/signin-oidc" проверяющей стороны выполняется с параметрами "id_token", "code" и "state".</p><p>Проверяющая сторона проверяет запрос и создает новый сеанс. Если злоумышленник перехватил и воспроизвел этот запрос, он может успешно создать сеанс, выдав себя за пользователя. Наличие специального утверждения в OpenID Connect может ограничить, но не полностью исключить подобные атаки. Чтобы защитить свои приложения, разработчики могут реализовать интерфейс ITokenReplayCache и присвоить экземпляр свойству TokenReplayCache.</p>|

### <a name="example"></a>Пример
```csharp
// ITokenReplayCache defined in ADAL
public interface ITokenReplayCache
{
bool TryAdd(string securityToken, DateTime expiresOn);
bool TryFind(string securityToken);
}
```

### <a name="example"></a>Пример
Ниже приведен пример реализации интерфейса ITokenReplayCache. (Выполните соответствующие настройки и реализуйте платформу кэширования конкретного проекта.)
```csharp
public class TokenReplayCache : ITokenReplayCache
{
    private readonly ICacheProvider cache; // Your project-specific cache provider
    public TokenReplayCache(ICacheProvider cache)
    {
        this.cache = cache;
    }
    public bool TryAdd(string securityToken, DateTime expiresOn)
    {
        if (this.cache.Get<string>(securityToken) == null)
        {
            this.cache.Set(securityToken, securityToken);
            return true;
        }
        return false;
    }
    public bool TryFind(string securityToken)
    {
        return this.cache.Get<string>(securityToken) != null;
    }
}
```
Ссылку на реализованный кэш нужно добавить в параметрах OIDC с помощью свойства TokenValidationParameters следующим образом.
```csharp
OpenIdConnectOptions openIdConnectOptions = new OpenIdConnectOptions
{
    AutomaticAuthenticate = true,
    ... // other configuration properties follow..
    TokenValidationParameters = new TokenValidationParameters
    {
        TokenReplayCache = new TokenReplayCache(/*Inject your cache provider*/);
    }
}
```

Чтобы проверить эффективность данной конфигурации, войдите в локальное приложение, защищенное с помощью OIDC, и запишите запрос к конечной точке `"/signin-oidc"` в Fiddler. Если защита не включена, воспроизведение этого запроса в Fiddler приведет к созданию нового файла cookie сеанса. При воспроизведении запроса после добавления защиты с помощью свойства TokenReplayCache приложение выдаст исключение следующего типа: `SecurityTokenReplayDetectedException: IDX10228: The securityToken has previously been validated, securityToken: 'eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6Ik1uQ19WWmNBVGZNNXBPWWlKSE1iYTlnb0VLWSIsImtpZCI6Ik1uQ1......`

## <a id="adal-oauth2"></a>Используйте библиотеки ADAL для управления запросами маркеров от клиентов OAuth2 к AAD (или к локальной службе AD)

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Azure AD | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальный |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | [ADAL](https://azure.microsoft.com/documentation/articles/active-directory-authentication-libraries/) |
| **Действия** | <p>Библиотека проверки подлинности Azure AD (ADAL) позволяет разработчикам клиентских приложений легко проверять подлинность пользователей в облачной или локальной Active Directory (AD) и получать маркеры доступа для защиты вызовов API.</p><p>ADAL имеет множество функций, которые упрощают проверку подлинности для разработчиков. К ним относятся поддержка асинхронных операций, настраиваемый кэш маркеров, в котором хранятся маркеры доступа и маркеры обновления, автоматическое обновление маркера, когда срок действия маркера доступа истекает и маркер обновления доступен, и многие другие функции.</p><p>ADAL берет на себя большую часть сложных операций и позволяет разработчику сосредоточиться на бизнес-логике своего приложения и легко защитить ресурсы, не будучи экспертом в области безопасности. Отдельные библиотеки доступны для .NET, JavaScript (клиент и Node.js), iOS, Android и Java.</p>|

## <a id="authn-devices-field"></a>Проверяйте подлинность устройств, подключаемых к полевому шлюзу

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Полевой шлюз Интернета вещей | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальный |
| **Атрибуты**              | Недоступно  |
| **Справочные материалы**              | Недоступно  |
| **Действия** | Настройте полевой шлюз таким образом, чтобы он выполнял проверку подлинности каждого устройства, прежде чем получать от них данные и упрощать взаимодействие вышестоящих объектов с облачным шлюзом. Кроме того, настройте подключение устройств с помощью учетных данных на уровне отдельного устройства, чтобы уникально идентифицировать отдельные устройства.|

## <a id="authn-devices-cloud"></a>Устройства, подключаемые к облачному шлюзу, должны проходить проверку подлинности

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Облачный шлюз Интернета вещей | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальное, C#, Node.js  |
| **Атрибуты**              | Н/д, выбор шлюза: Центр Интернета вещей Azure |
| **Справочные материалы**              | Н/д, [Приступая к работе с Центром Интернета вещей Azure (.NET)](https://azure.microsoft.com/documentation/articles/iot-hub-csharp-csharp-getstarted/), [Приступая к работе с Центром Интернета вещей Azure (Node)](https://azure.microsoft.com/documentation/articles/iot-hub-node-node-getstarted), [Поддерживаемые сертификаты X.509](https://azure.microsoft.com/documentation/articles/iot-hub-sas-tokens/), [репозиторий Git](https://github.com/Azure/azure-iot-sdks/tree/master/node) |
| **Действия** | <ul><li>**Универсальное.** Выполняйте проверку подлинности устройства с использованием протокола TLS или IPSec. Инфраструктура должна поддерживать общие ключи для тех устройств, которые не выполняют полное асимметричное шифрование. Используйте Azure AD, OAuth.</li><li>**C#.** При создании экземпляра DeviceClient по умолчанию метод Create создает экземпляр DeviceClient, который использует протокол AMQP для связи с Центром Интернета вещей. Для использования протокола HTTPS используйте переопределение метода Create, чтобы указать протокол. Если вы используете протокол HTTPS, вам также следует добавить в свой проект пакет NuGet `Microsoft.AspNet.WebApi.Client`, чтобы включить пространство имен `System.Net.Http.Formatting`.</li></ul>|

### <a name="example"></a>Пример
```csharp
static DeviceClient deviceClient;

static string deviceKey = "{device key}";
static string iotHubUri = "{iot hub hostname}";

var messageString = "{message in string format}";
var message = new Message(Encoding.ASCII.GetBytes(messageString));

deviceClient = DeviceClient.Create(iotHubUri, new DeviceAuthenticationWithRegistrySymmetricKey("myFirstDevice", deviceKey));

await deviceClient.SendEventAsync(message);
```

### <a name="example"></a>Пример
**Проверка подлинности Node.js**
#### <a name="symmetric-key"></a>Симметричный ключ
* Создайте Центр Интернета вещей в Azure.
* Создайте запись в реестре удостоверений устройств.
    ```javascript
    var device = new iothub.Device(null);
    device.deviceId = <DeviceId >
    registry.create(device, function(err, deviceInfo, res) {})
    ```
* Создайте виртуальное устройство.
    ```javascript
    var clientFromConnectionString = require('azure-iot-device-amqp').clientFromConnectionString;
    var Message = require('azure-iot-device').Message;
    var connectionString = 'HostName=<HostName>DeviceId=<DeviceId>SharedAccessKey=<SharedAccessKey>';
    var client = clientFromConnectionString(connectionString);
    ```
#### <a name="sas-token"></a>Маркер SAS
* Создается в системе при использовании симметричного ключа, но его также можно создать и использовать явным образом.
* Определите протокол: `var Http = require('azure-iot-device-http').Http;`
* Создайте маркер SAS:
    ```javascript
    resourceUri = encodeURIComponent(resourceUri.toLowerCase()).toLowerCase();
    var deviceName = "<deviceName >";
    var expires = (Date.now() / 1000) + expiresInMins * 60;
    var toSign = resourceUri + '\n' + expires;
    // using crypto
    var decodedPassword = new Buffer(signingKey, 'base64').toString('binary');
    const hmac = crypto.createHmac('sha256', decodedPassword);
    hmac.update(toSign);
    var base64signature = hmac.digest('base64');
    var base64UriEncoded = encodeURIComponent(base64signature);
    // construct authorization string
    var token = "SharedAccessSignature sr=" + resourceUri + "%2fdevices%2f"+deviceName+"&sig="
    + base64UriEncoded + "&se=" + expires;
    if (policyName) token += "&skn="+policyName;
    return token;
    ```
* Подключитесь с помощью маркера SAS: 
    ```javascript
    Client.fromSharedAccessSignature(sas, Http); 
    ```
#### <a name="certificates"></a>Сертификаты
* Создайте самозаверяющий сертификат X509 с помощью любого средства, такого как OpenSSL, чтобы создать файлы CERT и KEY для хранения сертификата и ключа соответственно.
* Подготовьте устройство, которое принимает безопасное подключение с использованием сертификатов.
    ```javascript
    var connectionString = '<connectionString>';
    var registry = iothub.Registry.fromConnectionString(connectionString);
    var deviceJSON = {deviceId:"<deviceId>",
    authentication: {
        x509Thumbprint: {
        primaryThumbprint: "<PrimaryThumbprint>",
        secondaryThumbprint: "<SecondaryThumbprint>"
        }
    }}
    var device = deviceJSON;
    registry.create(device, function (err) {});
    ```
* Подключите устройство с помощью сертификата.
    ```javascript
    var Protocol = require('azure-iot-device-http').Http;
    var Client = require('azure-iot-device').Client;
    var connectionString = 'HostName=<HostName>DeviceId=<DeviceId>x509=true';
    var client = Client.fromConnectionString(connectionString, Protocol);
    var options = {
        key: fs.readFileSync('./key.pem', 'utf8'),
        cert: fs.readFileSync('./server.crt', 'utf8')
    }; 
    // Calling setOptions with the x509 certificate and key (and optionally, passphrase) will configure the client //transport to use x509 when connecting to IoT Hub
    client.setOptions(options);
    //call fn to execute after the connection is set up
    client.open(fn);
    ```

## <a id="authn-cred"></a>Используйте учетные данные проверки подлинности на уровне отдельного устройства

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Облачный шлюз Интернета вещей  | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальный |
| **Атрибуты**              | Выбор шлюза: Центр Интернета вещей Azure |
| **Справочные материалы**              | [Маркеры безопасности Центра Интернета вещей Azure](https://azure.microsoft.com/documentation/articles/iot-hub-sas-tokens/) |
| **Действия** | Используйте учетные данные проверки подлинности с помощью маркеров SAS на основе ключа устройства или сертификата клиента для каждого отдельного устройства вместо политик общего доступа на уровне Центра Интернета вещей. Это предотвратит повторное использование маркеров проверки подлинности одного устройства или полевого шлюза другим устройством. |

## <a id="req-containers-anon"></a>Анонимный доступ на чтение должен быть предоставлен только к необходимым контейнерам и большим двоичным объектам

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Хранилище Azure | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальный |
| **Атрибуты**              | Тип хранилища: большой двоичный объект |
| **Справочные материалы**              | [Управление анонимным доступом на чтение к контейнерам и большим двоичным объектам](https://azure.microsoft.com/documentation/articles/storage-manage-access-to-resources/), [Использование подписанных URL-адресов (SAS): общие сведения о модели SAS](https://azure.microsoft.com/documentation/articles/storage-dotnet-shared-access-signature-part-1/) |
| **Действия** | <p>По умолчанию контейнер и все большие двоичные объекты внутри него доступны только владельцу учетной записи хранения. Чтобы предоставить анонимным пользователями доступ на их чтение, следует разрешить общий доступ к контейнеру. Анонимные пользователи могут считывать данные большого двоичного объекта из общедоступного контейнера, при этом их запросы не будут проходить аутентификацию.</p><p>Доступны следующие возможности управления доступом к контейнеру.</p><ul><li>Полный общий доступ на чтение: контейнер и данные больших двоичных объектов можно считывать с помощью анонимного запроса. Клиенты могут перечислять BLOB-объекты внутри контейнера с помощью анонимного запроса, но не могут перечислять контейнеры в учетной записи хранения.</li><li>Общий доступ на чтение только для больших двоичных объектов: данные больших двоичных объектов в этом контейнере можно считать с помощью анонимного запроса, но данные контейнера недоступны. Клиенты не могут перечислять большие двоичные объекты внутри с помощью анонимного запроса.</li><li>Без общего доступа для чтения: контейнер и данные больших двоичных объектов может считывать только владелец учетной записи.</li></ul><p>Анонимный доступ лучше всего подходит для сценариев, когда определенные большие двоичные объекты нужно сделать всегда доступными для анонимного доступа на чтение. Для осуществления детального контроля можно создать подписанный URL-адрес, который позволит делегировать ограниченный доступ на определенный временной интервал, используя разные разрешения. Проверьте, чтобы случайно не был предоставлен анонимный доступ к контейнерам и большим двоичным объектам, которые могут содержать конфиденциальные данные.</p>|

## <a id="limited-access-sas"></a>Предоставьте ограниченный доступ к объектам в службе хранилища Azure с помощью SAS или SAP

| Название                   | Сведения      |
| ----------------------- | ------------ |
| **Компонент**               | Хранилище Azure | 
| **Этап SDL**               | Создание |  
| **Применимые технологии** | Универсальный |
| **Атрибуты**              | Недоступно |
| **Справочные материалы**              | [Использование подписанных URL-адресов (SAS): общие сведения о модели SAS](https://azure.microsoft.com/documentation/articles/storage-dotnet-shared-access-signature-part-1/), [Подписанные URL-адреса. Часть 2: создание и использование подписанного URL-адреса в службе BLOB-объектов](https://azure.microsoft.com/documentation/articles/storage-dotnet-shared-access-signature-part-2/), [сведения о делегировании доступа к объектам в учетной записи с помощью подписанных URL-адресов и хранимых политик доступа](https://azure.microsoft.com/documentation/articles/storage-security-guide/#_how-to-delegate-access-to-objects-in-your-account-using-shared-access-signatures-and-stored-access-policies) |
| **Действия** | <p>Подписанный URL-адрес (SAS) — это эффективное средство для предоставления другим клиентам ограниченного доступа к объектам в вашей учетной записи хранения без предоставления ключа доступа к вашей учетной записи. Подпись общего доступа — это URI, который в своих параметрах запроса содержит все сведения, необходимые доступа к ресурсу хранилища с прохождением проверки подлинности. Для доступа к ресурсам хранилища с помощью SAS клиенту достаточно передать SAS в соответствующий конструктор или метод.</p><p>Подпись общего доступа можно использовать, когда доступ к ресурсам в вашей учетной записи хранения требуется предоставить клиенту, которому нельзя доверить ключ учетной записи. Ключи вашей учетной записи хранения включают в себя как первичный, так и вторичный ключ, и оба этих ключа предоставляют административный доступ к вашей учетной записи и всем ее ресурсам. Предоставление любого из ключей учетной записи делает ее уязвимой вредоносного или небрежного использования. Подписи общего доступа обеспечивают безопасную альтернативу, позволяющую другим клиентам считывать, записывать и удалять данные в вашей учетной записи хранения в соответствии с выданными вами разрешениями и без потребности в ключе учетной записи.</p><p>Если у вас есть логически связанный и относительно постоянный набор параметров, лучше использовать хранимую политику доступа. Та как подписанный URL-адрес, полученный на основе хранимой политики доступа, можно отозвать немедленно, рекомендуется использовать хранимые политики доступа всегда, когда это возможно.</p>|