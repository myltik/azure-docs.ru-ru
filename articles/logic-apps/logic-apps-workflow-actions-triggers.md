---
title: "Триггеры и действия для рабочих процессов в Azure Logic Apps | Документация Майкрософт"
description: "Дополнительные сведения о типах триггеров и действий, которые можно использовать для создания и автоматизации рабочих процессов с помощью Azure Logic Apps."
services: logic-apps
author: MandiOhlinger
manager: anneta
editor: 
documentationcenter: 
ms.assetid: 86a53bb3-01ba-4e83-89b7-c9a7074cb159
ms.service: logic-apps
ms.workload: integration
ms.tgt_pltfrm: na
ms.devlang: multiple
ms.topic: article
ms.date: 11/17/2016
ms.author: LADocs; mandia
ms.openlocfilehash: 981bf5555d1941509e787adf656fe6310dd43cb9
ms.sourcegitcommit: 059dae3d8a0e716adc95ad2296843a45745a415d
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/09/2018
---
# <a name="triggers-and-actions-for-logic-app-workflows"></a>Триггеры и действия для рабочих процессов приложений логики

Все приложения логики запускаются триггером с последующими действиями. В этой статье описываются типы триггеров и действий, которые можно использовать для создания интеграции систем и автоматизации бизнес-процессов с помощью приложений логики. 
  
## <a name="triggers-overview"></a>Общие сведения о триггерах 

Все приложения логики запускаются триггером, который указывает вызовы, способные запускать выполнение приложения логики. Ниже приведены два способа инициировать запуск рабочего процесса:  

* с помощью опрашивающего триггера;  
* с помощью извещающего триггера, который вызывает [REST API службы рабочих процессов](https://docs.microsoft.com/rest/api/logic/workflows).  
  
Все триггеры содержат следующие элементы верхнего уровня:  
  
```json
"trigger-name": {
    "type": "trigger-type",
    "inputs": { call-settings },
    "recurrence": {  
        "frequency": "Second|Minute|Hour|Day|Week|Month",
        "interval": recurrence-interval-based-on-frequency
    },
    "conditions": [ array-of-required-conditions ],
    "splitOn": "property-used-for-creating-separate-workflows",
    "operationOptions": "operation-options-for-trigger"
}
```

### <a name="trigger-types-and-inputs"></a>Типы и входные данные триггеров  

Каждый тип триггера имеет свой интерфейс и свои *входные данные*, которые определяют его поведение. 

| Тип триггера | ОПИСАНИЕ | 
| ------------ | ----------- | 
| **Периодичность** | Активируется на основе определенного расписания. Можно задать дату и время в будущем для срабатывания триггера. Основываясь на частоте, можно также указать время и дни, когда должен запускаться рабочий процесс. | 
| **Запрос**  | Превращает приложение логики в конечную точку, которую можно вызвать, Также называется "ручным" триггером. | 
| **HTTP** | Проверяет или *опрашивает* конечную веб-точку HTTP. Конечная точка HTTP должна соответствовать определенному условию триггера — используя шаблон асинхронных операций 202 или возвращая массив. | 
| **ApiConnection** | Опрашивает, как и триггер HTTP, но использует [интерфейсы API, управляемые Майкрософт](../connectors/apis-list.md). | 
| **HTTPWebhook** | Превращает приложение логики в вызываемую конечную точку, как и триггер запросов, но вызывает определенный URL-адрес для регистрации и отмены регистрации. |
| **ApiConnectionWebhook** | Работает по принципу триггера **HTTPWebhook**, но использует интерфейсы API, управляемые Майкрософт. | 
||| 

Дополнительные сведения см. в статье [Схема языка определения рабочих процессов в Azure Logic Apps](../logic-apps/logic-apps-workflow-definition-language.md). 
  
## <a name="recurrence-trigger"></a>Триггер повторения  

Этот триггер выполняется на основе указанных вами параметров повторения и расписания и предоставляет простой способ регулярного запуска рабочего процесса. Ниже приведен пример простого триггера повторения, который запускается ежедневно.

```json
"myRecurrenceTrigger": {
    "type": "Recurrence",
    "recurrence": {
        "frequency": "Day",
        "interval": 1
    }
}
```
Вы также можете запланировать дату и время, когда триггер будет срабатывать. Например, чтобы еженедельный отчет запускался каждый понедельник, можно запланировать запуск приложения логики на определенный понедельник, как в этом примере: 

```json
"myRecurrenceTrigger": {
    "type": "Recurrence",
    "recurrence": {
        "frequency": "Week",
        "interval": "1",
        "startTime" : "2017-09-18T00:00:00Z"
    }
}
```

Ниже приведено определение для этого триггера. 

```json
"myRecurrenceTrigger": {
    "type": "Recurrence",
    "recurrence": {
        "frequency": "second|minute|hour|day|week|month",
        "interval": recurrence-interval-based-on-frequency,
        "schedule": {
            // Applies only when frequency is Day or Week. Separate values with commas.
            "hours": [ one-or-more-hour-marks ], 
            // Applies only when frequency is Day or Week. Separate values with commas.
            "minutes": [ one-or-more-minute-marks ], 
            // Applies only when frequency is Week. Separate values with commas.
            "weekDays": [ "Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday" ] 
        },
        "startTime": "start-date-time-with-format-YYYY-MM-DDThh:mm:ss",
        "timeZone": "specify-time-zone"
    }
}
```

| Имя элемента | Обязательно | type | ОПИСАНИЕ | 
| ------------ | -------- | ---- | ----------- | 
| frequency | Yes | Строка | Единица времени для указания частоты срабатывания триггера. Используйте только одно из этих значений: second (секунда), minute (минута), hour (час), day (день), week (неделя) или month (месяц). | 
| interval | Yes | Целое число  | Положительное целое число, которое описывает, как часто выполняется рабочий процесс с учетом заданной частоты. <p>Ниже приведены минимальный и максимальный интервалы. <p>— Месяц: 1–16 месяцев; </br>— День: 1–500 дней; </br>— Час: 1–12 000 часов; </br>— Минута: 1–72 000 минут; </br>- Second: 1–9 999 999 секунд.<p>Например, если интервал равен 6, а значение частоты — month, то повтор будет происходить каждые 6 месяцев. | 
| timeZone | Нет  | Строка | Применяется только при указании времени начала, так как этот триггер не принимает [смещение от UTC](https://en.wikipedia.org/wiki/UTC_offset). Укажите часовой пояс, который необходимо применить. | 
| startTime | Нет  | Строка | Укажите дату и время начала в таком формате: <p>ГГГГ-ММ-ДДTчч:мм:сс, если указан часовой пояс, <p>-или- <p>ГГГГ-ММ-ДДTчч:мм:ссZ, если часовой пояс не указан. <p>Например, если требуется указать 18 сентября 2017 г. в 14:00, то используйте 2017-09-18T14:00:00 и укажите часовой пояс, такой как "Стандартное тихоокеанское время". Или укажите 2017-09-18T14:00:00Z без часового пояса. <p>**Примечание.** Это время начала должно соответствовать [спецификации даты и времени ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) в [формате UTC](https://en.wikipedia.org/wiki/Coordinated_Universal_Time), но без [смещения от UTC](https://en.wikipedia.org/wiki/UTC_offset). Если не указать часовой пояс, то необходимо в конце добавить букву Z без пробелов. Эта буква Z ссылается на соответствующее [судовое время](https://en.wikipedia.org/wiki/Nautical_time). <p>В простых расписаниях время начала определяет первый случай выполнения задания, а в сложных расписаниях триггер срабатывает не раньше, чем наступит время начала. Дополнительные сведения о дате и времени начала см. в статье [Начало работы с триггером повторения](../connectors/connectors-native-recurrence.md). | 
| weekDays | Нет  | Строка или массив строк | Если для параметра `frequency` задать значение Week, то можно указать один или несколько дней, разделенных запятыми. В эти дни будет запускаться рабочий процесс: Monday (Понедельник), Tuesday (Вторник), Wednesday (Среда), Thursday (Четверг), Friday (Пятница), Saturday (Суббота) и Sunday (Воскресенье). | 
| hours | Нет  | Целое число или массив целых чисел | Если для параметра `frequency` задать значение Day или Week, то можно указать одно или несколько целых чисел от 0 до 23, разделенных запятыми. В эти часы будет запускаться рабочий процесс. <p>Например, если указать 10, 12 и 14, вы получите часовые метки 10:00, 12:00 и 14:00. | 
| minutes | Нет  | Целое число или массив целых чисел | Если для параметра `frequency` задать значение Day или Week, то можно указать одно или несколько целых чисел от 0 до 59, разделенных запятыми. В эти минуты часа будет запускаться рабочий процесс. <p>Например, если указать 30 минут и использовать предыдущий пример для часов, то вы получите 10:30, 12:30 и 14:30. | 
|||||| 

Например, в этом триггере повторения указано, что приложение логики должно выполняться еженедельно каждый понедельник в 10:30, 12:30 и 14:30 по стандартному тихоокеанскому времени, начиная не ранее 9 сентября 2017 г. с 14:00:

``` json
{
    "triggers": {
        "myRecurrenceTrigger": {
            "type": "Recurrence",
            "recurrence": {
                "frequency": "Week",
                "interval": 1,
                "schedule": {
                    "hours": [
                        10,
                        12,
                        14
                    ],
                    "minutes": [
                        30
                    ],
                    "weekDays": [
                        "Monday"
                    ]
                },
               "startTime": "2017-09-07T14:00:00",
               "timeZone": "Pacific Standard Time"
            }
        }
    }
}
```

Дополнительные сведения, а также примеры повторений и времени начала см. в статье [Начало работы с триггером повторения](../connectors/connectors-native-recurrence.md).

## <a name="request-trigger"></a>Триггер запросов

Этот триггер служит в качестве конечной точки, которую можно использовать для вызова приложения логики с помощью HTTP-запроса. Триггер запроса выглядит следующим образом:  
  
```json
"myRequestTrigger": {
    "type": "Request",
    "kind": "Http",
    "inputs": {
        "schema": {
            "type": "Object",
            "properties": {
                "myInputProperty1": { "type" : "string" },
                "myInputProperty2": { "type" : "number" }
            },
            "required": [ "myInputProperty1" ]
        }
    }
} 
```

Этот триггер также содержит необязательное свойство, которое называется *schema*.
  
| Имя элемента | Обязательно | type | ОПИСАНИЕ |
| ------------ | -------- | ---- | ----------- |
| schema | Нет  | Объект. | Схема JSON, которая проверяет входящий запрос. Используется, чтобы указать, на какие свойства ссылаться последующим действиям рабочего процесса. | 
||||| 

Для вызова этой конечной точки необходимо вызвать API *listCallbackUrl*. См. сведения в статье [Рабочие процессы](https://docs.microsoft.com/rest/api/logic/workflows).

## <a name="http-trigger"></a>Триггер HTTP  

Триггеры HTTP опрашивают указанную конечную точку и проверяют ответ, чтобы определить, следует ли выполнять рабочий процесс. Объект `inputs` принимает следующие параметры, необходимые для создания HTTP-вызова:  

| Имя элемента | Обязательно | type | ОПИСАНИЕ | 
| ------------ | -------- | ---- | ----------- | 
| метод | Yes | Строка | Использует один из этих методов HTTP: GET, POST, PUT, DELETE, PATCH или HEAD. | 
| uri | Yes| Строка | Конечная точка HTTP или HTTPS, которую проверяет триггер. Максимальный размер строки: 2 КБ. | 
| Запросы | Нет  | Объект. | Представляет любые параметры запроса, которые необходимо включить в URL-адрес. <p>Например, `"queries": { "api-version": "2015-02-01" }` добавляет `?api-version=2015-02-01` в URL-адрес. | 
| headers | Нет  | Объект. | Представляет каждый заголовок, который отправляется в запросе. <p>Например, чтобы задать язык и тип запроса: <p>`"headers": { "Accept-Language": "en-us", "Content-Type": "application/json" }` | 
| текст | Нет  | Объект. | Представляет полезные данные, отправляемые конечной точке. | 
| retryPolicy | Нет  | Объект. | Используйте этот объект, чтобы настроить поведение повтора при возникновении ошибок 4xx или 5xx. Дополнительные сведения см. в разделе [Политики повтора](../logic-apps/logic-apps-exception-handling.md). | 
| authentication | Нет  | Объект. | Представляет метод, который должен использоваться запросом для аутентификации. Дополнительные сведения см. в статье [Исходящая проверка подлинности планировщика](../scheduler/scheduler-outbound-authentication.md). <p>Помимо планировщика, имеется еще одно поддерживаемое свойство: `authority`. По умолчанию его значение равно `https://login.windows.net`, если не указано другое. Также можно использовать другое значение, например `https://login.windows\-ppe.net`. | 
||||| 
 
Для эффективной работы с приложением логики триггеру HTTP требуется, чтобы API HTTP соответствовал определенному шаблону. Триггер распознает следующие свойства:  
  
| Ответ | Обязательно | ОПИСАНИЕ | 
| -------- | -------- | ----------- |  
| Код состояния | Yes | Код состояния 200 (ОК) инициирует запуск. Другие коды состояния не вызывают запуск. | 
| Заголовок retry-after | Нет  | Количество секунд перед повторным опросом конечной точки приложением логики. | 
| Заголовок Location | Нет  | URL-адрес для вызова во время следующего интервала опроса. Если не указан, используется исходный URL-адрес. | 
|||| 

Ниже приведены некоторые примеры поведений для различных типов запросов.
  
| Код ответа | Повтор через | Поведение | 
| ------------- | ----------- | -------- | 
| 200 | {нет} | Выполняется рабочий процесс, затем после определенного количества повторений снова проверяется, не добавились ли данные. | 
| 200 | 10 с | Выполняется рабочий процесс, затем через 10 секунд снова проверяется, не добавились ли данные. |  
| 202 | 60 секунд | Рабочий процесс не запускается. Следующая попытка происходит через одну минуту с учетом определенного повторения. Если определенное повторение составляет менее минуты, то приоритет имеет заголовок retry-after. В противном случае используется определенное повторение. | 
| 400 | {нет} | Недопустимый запрос, рабочий процесс не запускается. Если параметр `retryPolicy` не задан, то используется политика по умолчанию. После достижения количества попыток триггер снова проверяет наличие данных после определенного числа повторений. | 
| 500 | {нет}| Ошибка сервера, рабочий процесс не запускается. Если параметр `retryPolicy` не задан, то используется политика по умолчанию. После достижения количества попыток триггер снова проверяет наличие данных после определенного числа повторений. | 
|||| 

Ниже приведены выходные данные триггера HTTP. 
  
| Имя элемента | type | ОПИСАНИЕ |
| ------------ | ---- | ----------- |
| headers | Объект. | Заголовки HTTP-ответа. | 
| текст | Объект. | Текст HTTP-ответа. | 
|||| 

## <a name="api-connection-trigger"></a>Триггер подключения API  

Триггер подключения API по своей функциональности аналогичен триггеру HTTP. Однако параметры для определения действия различаются. Вот пример:   
  
```json
"myDailyReportTrigger": {
    "type": "ApiConnection",
    "inputs": {
        "host": {
            "api": {
                "runtimeUrl": "https://myarticles.example.com/"
            }
        },
        "connection": {
            "name": "@parameters('$connections')['myconnection'].name"
        }
    },  
    "method": "POST",
    "body": {
        "category": "awesomest"
    }
}
```

| Имя элемента | Обязательно | type | ОПИСАНИЕ | 
| ------------ | -------- | ---- | ----------- | 
| host | Yes | Объект. | Шлюз, где размещено приложение API, и его идентификатор. | 
| метод | Yes | Строка | Использует один из этих методов HTTP: GET, POST, PUT, DELETE, PATCH или HEAD. | 
| Запросы | Нет  | Объект. | Представляет любые параметры запроса, которые необходимо включить в URL-адрес. <p>Например, `"queries": { "api-version": "2015-02-01" }` добавляет `?api-version=2015-02-01` в URL-адрес. | 
| headers | Нет  | Объект. | Представляет каждый заголовок, который отправляется в запросе. <p>Например, чтобы задать язык и тип запроса: <p>`"headers": { "Accept-Language": "en-us", "Content-Type": "application/json" }` | 
| текст | Нет  | Объект. | Представляет полезные данные, отправляемые конечной точке. | 
| retryPolicy | Нет  | Объект. | Используйте этот объект, чтобы настроить поведение повтора при возникновении ошибок 4xx или 5xx. Дополнительные сведения см. в разделе [Политики повтора](../logic-apps/logic-apps-exception-handling.md). | 
| authentication | Нет  | Объект. | Представляет метод, который должен использоваться запросом для аутентификации. Дополнительные сведения см. в статье [Исходящая проверка подлинности планировщика](../scheduler/scheduler-outbound-authentication.md). | 
||||| 

Ниже приведены свойства для объекта `host`.  
  
| Имя элемента | Обязательно | ОПИСАНИЕ | 
| ------------ | -------- | ----------- | 
| api runtimeUrl | Yes | Конечная точка для управляемого API. | 
| connection name |  | Имя подключения управляемого API, которое использует рабочий процесс. Должно быть ссылкой на параметр с именем `$connection`. |
|||| 

Ниже приведены выходные данные для триггера подключения API.
  
| Имя элемента | type | ОПИСАНИЕ |
| ------------ | ---- | ----------- |
| headers | Объект. | Заголовки HTTP-ответа. | 
| текст | Объект. | Текст HTTP-ответа. | 
|||| 

См. дополнительные сведения о [ценах на триггеры API подключения](../logic-apps/logic-apps-pricing.md#triggers).

## <a name="httpwebhook-trigger"></a>Триггер httpWebhook  

Триггер HTTPWebhook предоставляет конечную точку аналогично триггеру запросов, но также вызывает указанный URL-адрес для регистрации и отмены регистрации. Триггер httpWebhook может выглядеть следующим образом:  

```json
"myAppsSpotTrigger": {
    "type": "HttpWebhook",
    "inputs": {
        "subscribe": {
            "method": "POST",
            "uri": "https://pubsubhubbub.appspot.com/subscribe",
            "headers": { },
            "body": {
                "hub.callback": "@{listCallbackUrl()}",
                "hub.mode": "subscribe",
                "hub.topic": "https://pubsubhubbub.appspot.com/articleCategories/technology"
            },
            "authentication": { },
            "retryPolicy": { }
        },
        "unsubscribe": {
            "url": "https://pubsubhubbub.appspot.com/subscribe",
            "body": {
                "hub.callback": "@{workflow().endpoint}@{listCallbackUrl()}",
                "hub.mode": "unsubscribe",
                "hub.topic": "https://pubsubhubbub.appspot.com/articleCategories/technology"
            },
            "method": "POST",
            "authentication": { }
        }
    },
    "conditions": [ ]
}
```

Многие из этих разделов являются необязательными, и поведение триггера HTTPWebhook зависит от того, какие разделы предоставлены или опущены. Ниже приведены свойства триггера HTTPWebhook.
  
| Имя элемента | Обязательно | ОПИСАНИЕ | 
| ------------ | -------- | ----------- |  
| subscribe | Нет  | Указывает исходящий запрос, который вызывается, когда триггер создается и выполняет первоначальную регистрацию. | 
| unsubscribe | Нет  | Указывает исходящий запрос, который вызывается при удалении триггера. | 
|||| 

Вы можете указать ограничения для действий webhook так же, как [ограничения для асинхронной модели HTTP](#asynchronous-limits). Ниже приведены дополнительные сведения о действиях `subscribe` и `unsubscribe`:

* `subscribe` вызывается, чтобы триггер начал ожидать передачи данных событий. Этот исходящий вызов запускается с теми же параметрами, что и стандартные действия HTTP. Этот вызов выполняется при любом изменении рабочего процесса, например когда происходит отзыв учетных данных или изменяются входные параметры триггера. 
  
  Для поддержки этого вызова функция `@listCallbackUrl()` возвращает уникальный URL-адрес для конкретного триггера в рабочем процессе. Этот URL-адрес представляет собой уникальный идентификатор для конечных точек, использующих REST API службы.
  
* `unsubscribe` вызывается автоматически, когда операция делает этот триггер недействительным, включая такие операции:

  * удаление или отключение триггера; 
  * удаление или отключение рабочего процесса; 
  * удаление или отключение подписки. 
  
  Параметры этой функции совпадают с параметрами триггера HTTP.

Ниже приведены выходные данные триггера HTTPWebhook и содержимое входящего запроса.
  
| Имя элемента | type | ОПИСАНИЕ |
| ------------ | ---- | ----------- |
| headers | Объект. | Заголовки HTTP-ответа. | 
| текст | Объект. | Текст HTTP-ответа. | 
|||| 

## <a name="conditions"></a>Условия  

Для любого триггера можно задать одно или несколько условий, определяющих, должен ли выполняться рабочий процесс. Например:   

```json
"myDailyReportTrigger": {
    "type": "Recurrence",
    "conditions": [ 
        {
            "expression": "@parameters('sendReports')"
        } 
    ],
    "recurrence": {
        "frequency": "Day",
        "interval": 1
    }
}
```

В этом случае отчет запускается, если для параметра рабочего процесса `sendReports` установлено значение true. Условия могут ссылаться на код состояния триггера. Например, можно запускать рабочий процесс только в том случае, если веб-сайт возвращает код состояния 500:
  
``` json
"conditions": [ 
    {  
      "expression": "@equals(triggers().code, 'InternalServerError')"  
    }  
]  
```  
  
> [!NOTE]  
> Если любое выражение ссылается на код состояния триггера каким-либо образом, поведение по умолчанию, запускаемое только при появлении кода состояния 200 (ОК), изменяется. Например, если требуется запуск при возникновении кода состояния 200 и 201, необходимо включить `@or(equals(triggers().code, 200),equals(triggers().code,201))` в качестве условия.
  
## <a name="start-multiple-runs-for-a-request"></a>Запуск нескольких выполнений запроса

Для запуска нескольких выполнений одного запроса можно использовать `splitOn`. Например, при необходимости опросить конечную точку, которая может получить несколько новых элементов между интервалами опроса.
  
Используя `splitOn`, можно указать свойство в полезных данных ответа, содержащих массив элементов, каждый из которых необходим для запуска триггера. Представьте, например, что у вас есть API, который возвращает такой ответ:  
  
```json
{
    "status": "Succeeded",
    "rows": [
        {  
            "id" : 938109380,
            "name" : "myFirstRow"
        },
        {
            "id" : 938109381,
            "name" : "mySecondRow"
        }
    ]
}
```
  
Приложению логики необходимо только содержимое `rows`, поэтому можно создать триггер, как в следующем примере:  

```json
"mySplitterTrigger": {
    "type": "Http",
    "recurrence": {
        "frequency": "minute",
        "interval": 1
    },
    "intputs": {
        "uri": "https://mydomain.com/myAPI",
        "method": "GET"
    },
    "splitOn": "@triggerBody()?.rows"
}
```
> [!NOTE]  
> При использовании команды `SplitOn` не удается получить свойства, которые находятся за пределами массива. Поэтому для данного примера не удается получить свойство `status` в ответе, возвращаемом из API.
> В этом примере также используется оператор `?`, чтобы избежать ошибок, если отсутствует свойство `rows`. 

Таким образом, в определении рабочего процесса `@triggerBody().name` возвращает `myFirstRow` для первого выполнения и `mySecondRow` для второго. Выходные данные триггера выглядят следующим образом:  

```json
{
    "body": {
        "id": 938109380,
        "name": "mySecondRow"
    }
}
```

```json
{
    "body": {
        "id": 938109381,
        "name": "mySecondRow"
    }
}
```
  
## <a name="single-run-instance"></a>Экземпляр однократного выполнения

Триггеры повторения можно настроить таким образом, чтобы они срабатывали, только когда завершены все активные выполнения. Если запланированное повторение случается во время выполнения экземпляра рабочего процесса, то триггер не срабатывает и ожидает следующего запланированного интервала повторения, чтобы сделать повторную проверку.
Чтобы настроить этот параметр, задайте для `operationOptions` значение `singleInstance`:

```json
"triggers": {
    "myHTTPTrigger": {
        "type": "Http",
        "inputs": { ... },
        "recurrence": { ... },
        "operationOptions": "singleInstance"
    }
}
```

## <a name="actions-overview"></a>Общие сведения о действиях

Существует много типов действий, каждое из которых имеет уникальное поведение. Каждый тип действия имеет различные входные данные, определяющие его поведение. Действия коллекций могут содержать множество других вложенных действий. 

### <a name="standard-actions"></a>Стандартные действия  

| Тип действия | ОПИСАНИЕ | 
| ----------- | ----------- | 
| **HTTP** | Вызывает конечную веб-точку HTTP. | 
| **ApiConnection**  | Работает по принципу действия HTTP, но использует [интерфейсы API, управляемые Майкрософт](https://docs.microsoft.com/azure/connectors/apis-list). | 
| **ApiConnectionWebhook** | Работает по принципу HTTPWebhook, но использует интерфейсы API, управляемые Майкрософт. | 
| **Ответ** | Определяет ответ для входящего вызова. | 
| **Function** | Представляет функцию Azure. | 
| **Wait** | Ожидает фиксированное количество времени или до определенного времени. | 
| **Workflow** | Представляет вложенный рабочий процесс. | 
| **Действие создания** | Создает произвольный объект из входных данных действия. | 
| **Запрос** | Фильтрует массив по условию. | 
| **Select** | Проецирует каждый элемент массива на новое значение. Например, можно преобразовать массив чисел в массив объектов. | 
| **Таблица** | Преобразовывает массив элементов в таблицу CSV или HTML. | 
| **Terminate** | Останавливает выполнение рабочего процесса. | 
||| 

### <a name="collection-actions"></a>Действия коллекций

| Тип действия | ОПИСАНИЕ | 
| ----------- | ----------- | 
| **Condition** | Вычисляет выражение и, в зависимости от результата, выполняет соответствующую ветвь. | 
| **Область** | Используется для логического группирования других действий. | 
| **ForEach** | Это циклическое действие выполняет итерацию по массиву и внутренние действия для каждого элемента массива. | 
| **Until** | Это циклическое действие выполняет внутренние действия, пока для условия не возвращается значение true. | 
||| 

## <a name="http-action"></a>Действие HTTP  

Действия HTTP вызывают указанную конечную точку и проверяют ответ, чтобы определить, следует ли запускать рабочий процесс. Например: 
  
```json
"myLatestNewsAction": {
    "type": "Http",
    "inputs": {
        "method": "GET",
        "uri": "https://mynews.example.com/latest"
    }
}
```

Объект `inputs` принимает следующие параметры, необходимые для создания HTTP-вызова: 

| Имя элемента | Обязательно | type | ОПИСАНИЕ | 
| ------------ | -------- | ---- | ----------- | 
| метод | Yes | Строка | Использует один из этих методов HTTP: GET, POST, PUT, DELETE, PATCH или HEAD. | 
| uri | Yes| Строка | Конечная точка HTTP или HTTPS, которую проверяет триггер. Максимальный размер строки: 2 КБ. | 
| Запросы | Нет  | Объект. | Представляет любые параметры запроса, которые необходимо включить в URL-адрес. <p>Например, `"queries": { "api-version": "2015-02-01" }` добавляет `?api-version=2015-02-01` в URL-адрес. | 
| headers | Нет  | Объект. | Представляет каждый заголовок, который отправляется в запросе. <p>Например, чтобы задать язык и тип запроса: <p>`"headers": { "Accept-Language": "en-us", "Content-Type": "application/json" }` | 
| текст | Нет  | Объект. | Представляет полезные данные, отправляемые конечной точке. | 
| retryPolicy | Нет  | Объект. | Используйте этот объект, чтобы настроить поведение повтора при возникновении ошибок 4xx или 5xx. Дополнительные сведения см. в разделе [Политики повтора](../logic-apps/logic-apps-exception-handling.md). | 
| operationsOptions | Нет  | Строка | Определяет набор особого поведения для переопределения. | 
| authentication | Нет  | Объект. | Представляет метод, который должен использоваться запросом для аутентификации. Дополнительные сведения см. в статье [Исходящая проверка подлинности планировщика](../scheduler/scheduler-outbound-authentication.md). <p>Помимо планировщика, имеется еще одно поддерживаемое свойство: `authority`. По умолчанию его значение равно `https://login.windows.net`, если не указано другое. Также можно использовать другое значение, например `https://login.windows\-ppe.net`. | 
||||| 

В этом примере при возникновении временных сбоев действие HTTP от двух до трех раз пытается получить последние новости с 30-секундной задержкой между попытками:
  
```json
"myLatestNewsAction": {
    "type": "Http",
    "inputs": {
        "method": "GET",
        "uri": "https://mynews.example.com/latest",
        "retryPolicy" : {
            "type": "fixed",
            "interval": "PT30S",
            "count": 2
        }
    }
}
```

Интервал повторных попыток указывается в [формате ISO 8601](https://en.wikipedia.org/wiki/ISO_8601). Минимальное значение по умолчанию для этого интервала составляет 20 секунд, а максимальное — один час. Максимальное число повторных попыток по умолчанию составляет четыре часа. Если определение политики повтора не указано, используется стратегия `fixed` со значениями числа и интервала повтора по умолчанию. Чтобы отключить политику повтора, задайте для нее тип `None`.

### <a name="asynchronous-patterns"></a>Модель асинхронных операций

По умолчанию все действия на основе HTTP поддерживают стандартную модель асинхронных операций. Таким образом, если удаленный сервер указывает, что запрос принят для обработки с ответом "202 ACCEPTED", то ядро Logic Apps продолжает опрашивать URL-адрес, указанный в заголовке расположения ответа, пока не получит конечного ответа, отличного от ответа 202.
  
Чтобы отключить описанное выше асинхронное поведение, задайте параметру `operationOptions` значение `DisableAsyncPattern` во входных данных действия. В таком случае выходные данные действия будут основаны на первоначальном ответе 202 от сервера. Например: 
  
```json
"invokeLongRunningOperationAction": {
    "type": "Http",
    "inputs": {
        "method": "POST",
        "uri": "https://host.example.com/resources"
    },
    "operationOptions": "DisableAsyncPattern"
}
```
<a name="asynchronous-limits"></a>

#### <a name="asynchronous-limits"></a>Ограничения асинхронных операций

Вы можете ограничить длительность асинхронных операций, задав определенный период времени. Если интервал времени истекает без достижения конечного состояния, состояние действия помечается как `Cancelled` с помощью кода `ActionTimedOut`. Ограничение времени ожидания указывается в формате ISO 8601. Вы можете указать ограничения, как показано ниже.

``` json
"action-name": {
    "type": "Workflow|Webhook|Http|ApiConnectionWebhook|ApiConnection",
    "inputs": { },
    "limit": {
        "timeout": "PT10S"
    }
}
```
  
## <a name="apiconnection-action"></a>Действие APIConnection

Действие APIConnection ссылается на соединитель, управляемый Майкрософт. Для этого действия требуется ссылка на допустимое подключение и сведения об API и параметрах.
Ниже приведен пример действия APIConnection.

```json
"Send_Email": {
    "type": "ApiConnection",
    "inputs": {
        "host": {
            "api": {
                "runtimeUrl": "https://logic-apis-df.azure-apim.net/apim/office365"
            },
            "connection": {
                "name": "@parameters('$connections')['office365']['connectionId']"
            }
        },
        "method": "POST",
        "body": {
            "Subject": "New tweet from @{triggerBody()['TweetedBy']}",
            "Body": "@{triggerBody()['TweetText']}",
            "To": "me@example.com"
        },
        "path": "/Mail"
    },
    "runAfter": {}
}
```

| Имя элемента | Обязательно | type | ОПИСАНИЕ | 
| ------------ | -------- | ---- | ----------- | 
| host | Yes | Объект. | Представляет сведения о соединителе, например `runtimeUrl`, и ссылку на объект подключения. | 
| метод | Yes | Строка | Использует один из этих методов HTTP: GET, POST, PUT, DELETE, PATCH или HEAD. | 
| path | Yes | Строка | Путь к операции API. | 
| Запросы | Нет  | Объект. | Представляет любые параметры запроса, которые необходимо включить в URL-адрес. <p>Например, `"queries": { "api-version": "2015-02-01" }` добавляет `?api-version=2015-02-01` в URL-адрес. | 
| headers | Нет  | Объект. | Представляет каждый заголовок, который отправляется в запросе. <p>Например, чтобы задать язык и тип запроса: <p>`"headers": { "Accept-Language": "en-us", "Content-Type": "application/json" }` | 
| текст | Нет  | Объект. | Представляет полезные данные, отправляемые конечной точке. | 
| retryPolicy | Нет  | Объект. | Используйте этот объект, чтобы настроить поведение повтора при возникновении ошибок 4xx или 5xx. Дополнительные сведения см. в разделе [Политики повтора](../logic-apps/logic-apps-exception-handling.md). | 
| operationsOptions | Нет  | Строка | Определяет набор особого поведения для переопределения. | 
| authentication | Нет  | Объект. | Представляет метод, который должен использоваться запросом для аутентификации. Дополнительные сведения см. в статье [Исходящая проверка подлинности планировщика](../scheduler/scheduler-outbound-authentication.md). |
||||| 

## <a name="apiconnection-webhook-action"></a>Действие APIConnectionWebhook

Действие APIConnectionWebhook ссылается на соединитель, управляемый Майкрософт. Для этого действия требуется ссылка на допустимое подключение и сведения об API и параметрах. Вы можете указать ограничения для действий webhook так же, как [ограничения для асинхронной модели HTTP](#asynchronous-limits).

```json
"Send_approval_email": {
    "type": "ApiConnectionWebhook",
    "inputs": {
        "host": {
            "api": {
                "runtimeUrl": "https://logic-apis-df.azure-apim.net/apim/office365"
            },
            "connection": {
                "name": "@parameters('$connections')['office365']['connectionId']"
            }
        },
        "body": {
            "Message": {
                "Subject": "Approval Request",
                "Options": "Approve, Reject",
                "Importance": "Normal",
                "To": "me@email.com"
            }
        },
        "path": "/approvalmail",
        "authentication": "@parameters('$authentication')"
    },
    "runAfter": {}
}
```

| Имя элемента | Обязательно | type | ОПИСАНИЕ | 
| ------------ | -------- | ---- | ----------- | 
| host | Yes | Объект. | Представляет сведения о соединителе, например `runtimeUrl`, и ссылку на объект подключения. | 
| path | Yes | Строка | Путь к операции API. | 
| Запросы | Нет  | Объект. | Представляет любые параметры запроса, которые необходимо включить в URL-адрес. <p>Например, `"queries": { "api-version": "2015-02-01" }` добавляет `?api-version=2015-02-01` в URL-адрес. | 
| headers | Нет  | Объект. | Представляет каждый заголовок, который отправляется в запросе. <p>Например, чтобы задать язык и тип запроса: <p>`"headers": { "Accept-Language": "en-us", "Content-Type": "application/json" }` | 
| текст | Нет  | Объект. | Представляет полезные данные, отправляемые конечной точке. | 
| retryPolicy | Нет  | Объект. | Используйте этот объект, чтобы настроить поведение повтора при возникновении ошибок 4xx или 5xx. Дополнительные сведения см. в разделе [Политики повтора](../logic-apps/logic-apps-exception-handling.md). | 
| operationsOptions | Нет  | Строка | Определяет набор особого поведения для переопределения. | 
| authentication | Нет  | Объект. | Представляет метод, который должен использоваться запросом для аутентификации. Дополнительные сведения см. в статье [Исходящая проверка подлинности планировщика](../scheduler/scheduler-outbound-authentication.md). |
||||| 

## <a name="response-action"></a>Действие ответа  

Это действие содержит все полезные данные ответа из HTTP-запроса и включает в себя `statusCode`, `body` и `headers`:
  
```json
"myResponseAction": {
    "type": "response",
    "inputs": {
        "statusCode": 200,
        "body": {
            "contentFieldOne": "value100",
            "anotherField": 10.001
        },
        "headers": {
            "x-ms-date": "@utcnow()",
            "Content-type": "application/json"
        }
    },
    "runAfter": {}
}
```

Действие response имеет специальные ограничения, которые не применяются к другим действиям, а именно:  
  
* Действия response не могут быть в параллельных ветвях в определении приложения логики, так как для входящего запроса требуется детерминированный ответ.
  
* Если рабочий процесс достигает действия response после получения ответа входящим запросом, то действие response считается неудачным или в состоянии конфликта. В результате запуск приложения логики помечается как `Failed`.
  
* Рабочий процесс с действиями response не может использовать команду `splitOn` в определении триггера, так как вызов создает несколько запусков. В результате при проверке этого случая, если операция рабочего процесса — PUT, возвращается ответ "Недопустимый запрос".

## <a name="function-action"></a>Действие функции   

Это действие позволяет представить и вызвать [функцию Azure](../azure-functions/functions-overview.md), например:

```json
"my-Azure-Function-name": {
   "type": "Function",
    "inputs": {
        "function": {
            "id": "/subscriptions/{Azure-subscription-ID}/resourceGroups/{Azure-resource-group}/providers/Microsoft.Web/sites/{your-Azure-function-app-name}/functions/{your-Azure-function-name}"
        },
        "queries": {
            "extrafield": "specialValue"
        },  
        "headers": {
            "x-ms-date": "@utcnow()"
        },
        "method": "POST",
        "body": {
            "contentFieldOne": "value100",
            "anotherField": 10.001
        }
    },
    "runAfter": {}
}
```
| Имя элемента | Обязательно | type | ОПИСАНИЕ | 
| ------------ | -------- | ---- | ----------- |  
| ИД функции | Yes | Строка | Идентификатор ресурса для функции Azure, которую требуется вызвать. | 
| метод | Нет  | Строка | Метод HTTP, используемый для вызова функции. Если метод не указан, то по умолчанию используется POST. | 
| Запросы | Нет  | Объект. | Представляет любые параметры запроса, которые необходимо включить в URL-адрес. <p>Например, `"queries": { "api-version": "2015-02-01" }` добавляет `?api-version=2015-02-01` в URL-адрес. | 
| headers | Нет  | Объект. | Представляет каждый заголовок, который отправляется в запросе. <p>Например, чтобы задать язык и тип запроса: <p>`"headers": { "Accept-Language": "en-us", "Content-Type": "application/json" }` | 
| текст | Нет  | Объект. | Представляет полезные данные, отправляемые конечной точке. | 
|||||

При сохранении приложения логики Azure Logic Apps выполняет проверки указанной функции:

* У вас должен быть доступ к функции.
* Допускаются только стандартные триггеры HTTP или универсальные триггеры webhook в формате JSON.
* В функции не должен быть определен какой-либо маршрут.
* Допускаются только авторизация с помощью функции и анонимная авторизация.

URL-адрес триггера извлекается, помещается в кэш и используется во время выполнения. Поэтому, если какая-либо операция делает недействительным кэшированный URL-адрес, то во время выполнения действие заканчивается сбоем. Чтобы обойти эту проблему, еще раз сохраните приложение логики. При этом приложение логики повторно получит и поместит в кэш URL-адрес триггера.

## <a name="wait-action"></a>Действие wait  

Это действие приостанавливает выполнение рабочего процесса на указанный период времени. В этом примере задается ожидание рабочего процесса длительностью 15 минут:
  
```json
"waitForFifteenMinutesAction": {
    "type": "Wait",
    "inputs": {
        "interval": {
            "unit": "minute",
            "count": 15
        }
    }
}
```
  
Кроме того, чтобы задать ожидание до определенного момента времени, можно использовать такой пример:
  
```json
"waitUntilOctoberAction": {
    "type": "Wait",
    "inputs": {
        "until": {
            "timestamp": "2017-10-01T00:00:00Z"
        }
    }
}
```
  
> [!NOTE]  
> Длительность ожидания можно задать с помощью только одного из объектов — `until` или `interval`.
  
| Имя элемента | Обязательно | type | ОПИСАНИЕ | 
| ------------ | -------- | ---- | ----------- | 
| until | Нет  | Объект. | Длительность ожидания на основе точки на момент времени. | 
| until timestamp | Yes | Строка | Точка во времени ([дата и время в формате UTC](https://en.wikipedia.org/wiki/Coordinated_Universal_Time)), когда истекает время ожидания. | 
| interval | Нет  | Объект. | Длительность ожидания на основе единицы интервала и числа интервалов. | 
| interval unit | Yes | Строка | Единица времени. Используйте только одно из этих значений: second (секунда), minute (минута), hour (час), day (день), week (неделя) или month (месяц). | 
| interval count | Yes | Целое число  | Положительное целое число, представляющее число единиц интервала, которые используются для длительности ожидания. | 
||||| 

## <a name="workflow-action"></a>Действие workflow   

Это действие представляет еще один рабочий процесс. Logic Apps проверяет доступ в рабочем процессе, точнее в триггере. Это означает, что требуется доступ к рабочему процессу.

Выходные данные этого действия основаны на заданном в действии `response` для дочернего рабочего процесса. Если действие `response` не задано, то выходные данные будут пустыми.

```json
"myNestedWorkflowAction": {
    "type": "Workflow",
    "inputs": {
        "host": {
            "id": "/subscriptions/xxxxyyyyzzz/resourceGroups/rg001/providers/Microsoft.Logic/mywf001",
            "triggerName": "mytrigger001"
        },
        "queries": {
            "extrafield": "specialValue"
        },  
        "headers": {
            "x-ms-date": "@utcnow()",
            "Content-type": "application/json"
        },
        "body": {
            "contentFieldOne": "value100",
            "anotherField": 10.001
        }
    },
    "runAfter": {}
}
```

| Имя элемента | Обязательно | type | ОПИСАНИЕ | 
| ------------ | -------- | ---- | ----------- |  
| host id | Yes | Строка| Идентификатор ресурса для рабочего процесса, который требуется вызвать. | 
| host triggerName | Yes | Строка | Имя триггера, который необходимо вызвать. | 
| Запросы | Нет  | Объект. | Представляет любые параметры запроса, которые необходимо включить в URL-адрес. <p>Например, `"queries": { "api-version": "2015-02-01" }` добавляет `?api-version=2015-02-01` в URL-адрес. | 
| headers | Нет  | Объект. | Представляет каждый заголовок, который отправляется в запросе. <p>Например, чтобы задать язык и тип запроса: <p>`"headers": { "Accept-Language": "en-us", "Content-Type": "application/json" }` | 
| текст | Нет  | Объект. | Представляет полезные данные, отправляемые конечной точке. | 
|||||   

## <a name="compose-action"></a>Действие compose

Это действие позволяет создать произвольный объект, а выходные данные являются результатом вычисления входных данных действия. 

> [!NOTE]
> Действие `Compose` можно использовать для создания выходных данных, включая объекты, массивы и любой другой тип, изначально поддерживаемый приложениями логики (XML и двоичный тип).

Например, действие compose можно использовать для объединения выходных данных из нескольких действий:

```json
"composeUserRecordAction": {
    "type": "Compose",
    "inputs": {
        "firstName": "@actions('getUser').firstName",
        "alias": "@actions('getUser').alias",
        "thumbnailLink": "@actions('lookupThumbnail').url"
    }
}
```

## <a name="select-action"></a>Выбор действия

Это действие позволяет проецировать каждый элемент массива на новое значение.
Например, чтобы преобразовать массив чисел в массив объектов, можно использовать следующую команду:

```json
"selectNumbersAction": {
    "type": "Select",
    "inputs": {
        "from": [ 1, 3, 0, 5, 4, 2 ],
        "select": { "number": "@item()" }
    }
}
```

| ИМЯ | Обязательно | type | ОПИСАНИЕ | 
| ---- | -------- | ---- | ----------- | 
| from | Yes | Массив, | Исходный массив. |
| select | Yes | Любой | Проекция, применяемая к каждому элементу в исходном массиве. |
||||| 

Выходные данные действия `select` — это массив с таким же количеством элементов, как и во входном массиве. Каждый его элемент преобразован так, как предписывает свойство `select`. Если вход — это пустой массив, выходные данные также будут пустым массивом.

## <a name="query-action"></a>Действие запроса

Это действие позволяет фильтровать массив на основе условия. В этом примере выбираются числа больше двух:

```json
"filterNumbersAction": {
    "type": "Query",
    "inputs": {
        "from": [ 1, 3, 0, 5, 4, 2 ],
        "where": "@greater(item(), 2)"
    }
}
```

Выходные данные действия `query` представлены в виде массива, содержащего элементы из массива входных данных, которые соответствуют условию.

> [!NOTE]
> Если значений, соответствующих условию `where`, нет, результатом будет пустой массив.

| ИМЯ | Обязательно | type | ОПИСАНИЕ | 
| ---- | -------- | ---- | ----------- | 
| from | Yes | Массив, | Исходный массив. |
| где: | Yes | Строка | Условие, которое применяемое к каждому элементу из исходного массива. |
||||| 

## <a name="table-action"></a>Действие таблицы

Это действие позволяет преобразовать массив элементов в таблицу **CSV** или **HTML**. Предположим, например, что у вас есть `@triggerBody()` с таким массивом:

```json
[ 
    {
      "id": 0,
      "name": "apples"
    },
    {
      "id": 1, 
      "name": "oranges"
    }
]
```

И вы определяете действие table, как в следующем примере:

```json
"convertToTableAction": {
    "type": "Table",
    "inputs": {
        "from": "@triggerBody()",
        "format": "html"
    }
}
```

Результат из этого примера выглядит как следующая таблица HTML: 

<table><thead><tr><th>id</th><th>name</th></tr></thead><tbody><tr><td>0</td><td>apples</td></tr><tr><td>1</td><td>oranges</td></tr></tbody></table>

Чтобы настроить эту таблицу, можно явно указать столбцы, например:

```json
"ConvertToTableAction": {
    "type": "Table",
    "inputs": {
        "from": "@triggerBody()",
        "format": "html",
        "columns": [ 
            {
                "header": "Produce ID",
                "value": "@item().id"
            },
            {
              "header": "Description",
              "value": "@concat('fresh ', item().name)"
            }
        ]
    }
}
```

Результат из этого примера выглядит как следующая таблица HTML: 

<table><thead><tr><th>Код результата</th><th>ОПИСАНИЕ</th></tr></thead><tbody><tr><td>0</td><td>fresh apples</td></tr><tr><td>1</td><td>fresh oranges</td></tr></tbody></table>

| ИМЯ | Обязательно | type | ОПИСАНИЕ | 
| ---- | -------- | ---- | ----------- | 
| from | Yes | Массив, | Исходный массив. Если значение свойства `from` — это пустой массив, выходные данные будут пустой таблицей. | 
| свойства | Yes | Строка | Необходимый формат таблицы — **CSV** или **HTML**. | 
| columns | Нет  | Массив, | Необходимые столбцы таблицы. Используйте, чтобы переопределить форму таблицы по умолчанию. | 
| column header | Нет  | Строка | Заголовок столбца. | 
| column value | Yes | Строка | Значение столбца. | 
||||| 

## <a name="terminate-action"></a>Действие terminate

Это действие останавливает выполнение рабочего процесса, отменяя активные действия и пропуская все оставшиеся действия. Действие terminate не влияет на завершенные действия.

Например, чтобы остановить выполнение в состоянии "Сбой", можно использовать следующий пример:

```json
"handleUnexpectedResponseAction": {
    "type": "Terminate",
    "inputs": {
        "runStatus": "Failed",
        "runError": {
            "code": "UnexpectedResponse",
            "message": "Received an unexpected response"
        }
    }
}
```

| ИМЯ | Обязательно | type | ОПИСАНИЕ | 
| ---- | -------- | ---- | ----------- | 
| runStatus | Yes | Строка | Состояние целевого выполнения (`Failed` или `Cancelled`). |
| runError | Нет  | Объект. | Сведения об ошибке. Поддерживается, только если `runStatus` имеет значение `Failed`. |
| runError code | Нет  | Строка | Код ошибки выполнения. |
| runError message | Нет  | Строка | Сообщение об ошибке выполнения. |
||||| 

## <a name="collection-actions-overview"></a>Общие сведения о действиях коллекций

Некоторые действия могут содержать вложенные действия. На действия ссылок в коллекции можно ссылаться непосредственно за пределами коллекции. Например, если вы определили `Http` в `scope`, то элемент `@body('http')` действителен в любой точке рабочего процесса. Действия в коллекции могут выполняться (`runAfter`) только с другими действиями в этой коллекции.

## <a name="condition-if-action"></a>Условие: действие If

Это действие позволяет вычислить условие и выполнить ветвь в зависимости от того, получает ли выражение значение `true`. 
  
```json
"myCondition": {
    "type": "If",
    "actions": {
        "if_true": {
            "type": "Http",
            "inputs": {
                "method": "GET",
                "uri": "http://myurl"
            },
            "runAfter": {}
        }
    },
    "else": {
        "actions": {
            "if_false": {
                "type": "Http",
                "inputs": {
                    "method": "GET",
                    "uri": "http://myurl"
                },
                "runAfter": {}
            }
        }
    },
    "expression": "@equals(triggerBody(), json(true))",
    "runAfter": {}
}
``` 

| ИМЯ | Обязательно | type | ОПИСАНИЕ | 
| ---- | -------- | ---- | ----------- | 
| actions | Yes | Объект. | Внутренние действия, которые необходимо выполнить, когда `expression` получает значение `true`. | 
| expression | Yes | Строка | Выражение для вычисления. |
| else | Нет  | Объект. | Внутренние действия, которые необходимо выполнить, когда `expression` получает значение `false`. |
||||| 

Если условие выполняется успешно, то оно помечается как `Succeeded`. Действия в объектах `actions` или `else` получают следующие значения: 

* `Succeeded`, если они запускаются и выполняются успешно;
* `Failed`, если они запускаются, но завершаются ошибкой;
* `Skipped`, если не запускается соответствующая ветвь.

Ниже приведены примеры, показывающие, как условия могут использовать выражения в действии.
  
| Значение JSON | Результат | 
| ---------- | -------| 
| `"expression": "@parameters('hasSpecialAction')"` | Условие выполняется при наличии какого-либо значения, которое возвращает значение true для выражения. Поддерживаются только логические выражения. Для преобразования других типов в логическое значение используйте следующие функции: `empty` и `equals`. | 
| `"expression": "@greater(actions('act1').output.value, parameters('threshold'))"` | Поддерживает функции сравнения. В этом примере действие выполняется, только если выходные данные `act1` превышают пороговое значение. | 
| `"expression": "@or(greater(actions('act1').output.value, parameters('threshold')), less(actions('act1').output.value, 100))"` | Поддерживает функции логики для создания вложенных логических выражений. В этом примере действие выполняется, если выходные данные `act1` превышают пороговое значение или меньше 100. | 
| `"expression": "@equals(length(actions('act1').outputs.errors), 0))"` | Чтобы проверить, содержит ли массив элементы, можно использовать функции массива. В этом примере действие выполняется, если массив `errors` пустой. | 
| `"expression": "parameters('hasSpecialAction')"` | Ошибка, недопустимое условие, так как для условия требуется @. |  
|||

## <a name="scope-action"></a>Действие scope

Это действие позволяет логически группировать действия в рабочем процессе.

```json
"myScope": {
    "type": "Scope",
    "actions": {
        "call_bing": {
            "type": "Http",
             "inputs": {
                "url": "http://www.bing.com"
            }
        }
    }
}
```

| ИМЯ | Обязательно | type | ОПИСАНИЕ | 
| ---- | -------- | ---- | ----------- |  
| actions | Yes | Объект. | Внутренние действия, которые необходимо выполнить внутри области. |
||||| 

## <a name="foreach-action"></a>Действие foreach

Это циклическое действие выполняет итерацию по массиву и внутренние действия для каждого элемента массива. По умолчанию цикл `foreach` выполняется параллельно и может иметь 20 параллельных выполнений одновременно. Правила выполнения можно задать с помощью параметра `operationOptions`.

```json
"forEach_EmailAction": {
    "type": "Foreach",
    "foreach": "@body('email_filter')",
    "actions": {
        "Send_email": {
            "type": "ApiConnection",
            "inputs": {
                "body": {
                    "to": "@item()",
                    "from": "me@contoso.com",
                    "message": "Hello, thank you for ordering"
                },
                "host": {
                    "connection": {
                        "id": "@parameters('$connections')['office365']['connection']['id']"
                    }
                }
            }
        }
    },
    "runAfter": {
        "email_filter": [ "Succeeded" ]
    }
}
```

| ИМЯ | Обязательно | type | ОПИСАНИЕ | 
| ---- | -------- | ---- | ----------- | 
| actions | Yes | Объект. | Внутренние действия, которые необходимо выполнить внутри цикла. | 
| foreach | Yes | Строка | Массив для итерации. | 
| operationOptions | Нет  | Строка | Указывает любые параметры операций для настройки поведения. В данный момент поддерживается только значение `Sequential` для последовательного выполнения итераций, где поведение по умолчанию — параллельное выполнение. |
||||| 

## <a name="until-action"></a>Действие Until

Это циклическое действие выполняет внутренние действия, пока для условия не возвращается значение true.

```json
 "runUntilSucceededAction": {
    "type": "Until",
    "actions": {
        "Http": {
            "type": "Http",
            "inputs": {
                "method": "GET",
                "uri": "http://myurl"
            },
            "runAfter": {}
        }
    },
    "expression": "@equals(outputs('Http')['statusCode', 200)",
    "limit": {
        "count": 1000,
        "timeout": "PT1H"
    },
    "runAfter": {}
}
```

| ИМЯ | Обязательно | type | ОПИСАНИЕ | 
| ---- | -------- | ---- | ----------- | 
| actions | Yes | Объект. | Внутренние действия, которые необходимо выполнить внутри цикла. | 
| expression | Yes | Строка | Выражение, вычисляемое после каждой итерации. | 
| ограничение | Yes | Объект. | Ограничения для цикла. Необходимо определить по крайней мере одно ограничение. | 
| count | Нет  | Целое число  | Ограничение на число итераций, которые необходимо выполнить. | 
| timeout | Нет  | Строка | Ограничение времени ожидания в [формате ISO 8601](https://en.wikipedia.org/wiki/ISO_8601), которое определяет, как долго будет выполняться цикл. |
||||| 

## <a name="next-steps"></a>Дополнительная информация

* [Язык определения рабочего процесса](../logic-apps/logic-apps-workflow-definition-language.md)
* [REST API рабочих процессов](https://docs.microsoft.com/rest/api/logic/workflows)
