---
title: "Действия и триггеры рабочих процессов в Azure Logic Apps | Документация Майкрософт"
description: 
services: logic-apps
author: MandiOhlinger
manager: anneta
editor: 
documentationcenter: 
ms.assetid: 86a53bb3-01ba-4e83-89b7-c9a7074cb159
ms.service: logic-apps
ms.workload: integration
ms.tgt_pltfrm: na
ms.devlang: multiple
ms.topic: article
ms.date: 11/17/2016
ms.author: mandia
translationtype: Human Translation
ms.sourcegitcommit: 8c4e33a63f39d22c336efd9d77def098bd4fa0df
ms.openlocfilehash: ff86340f18a2d3d13d55b7e0bcd4122d9b85ccd9
ms.lasthandoff: 04/20/2017

---

# <a name="workflow-actions-and-triggers-for-azure-logic-apps"></a>Действия и триггеры рабочих процессов в Azure Logic Apps

Приложения логики состоят из триггеров и действий. Существует шесть типов триггеров. У каждого из них свой интерфейс и разное поведение. Подробные сведения см. в статье [Схема языка определения рабочих процессов в Azure Logic Apps](logic-apps-workflow-definition-language.md).  
  
Здесь вы узнаете о триггерах и действиях, а также об их использовании при создании приложений логики для оптимизации бизнес-процессов и рабочих процессов.  
  
### <a name="triggers"></a>триггеры;  

Триггер указывает вызовы, которые могут инициировать запуск рабочего процесса приложения логики. Ниже приведены два разных способа инициировать запуск рабочего процесса:  
  
-   с помощью опрашивающего триггера;  

-   с помощью извещающего триггера путем вызова [REST API службы рабочих процессов](https://docs.microsoft.com/rest/api/logic/workflows).  
  
Все триггеры содержат следующие элементы верхнего уровня:  
  
```json
"<name-of-the-trigger>" : {
    "type": "<type-of-trigger>",
    "inputs": { <settings-for-the-call> },
    "recurrence": {  
        "frequency": "Second|Minute|Hour|Week|Month|Year",
        "interval": "<recurrence interval in units of frequency>"
    },
    "conditions": [ <array-of-required-conditions > ],
    "splitOn" : "<property to create runs for>",
    "operationOptions": "<operation options on the trigger>"
}
```

### <a name="trigger-types-and-their-inputs"></a>Типы триггеров и их входные данные  

Можно использовать такие типы триггеров:
  
-   **Триггер запросов** (request) — делает приложение логики конечной точкой для вызова.  
  
-   **Триггер повторения** (recurrence) — активируется на основе определенного расписания.  
  
-   **HTTP-триггер** — опрашивает конечную веб-точку HTTP. Конечная точка HTTP должна соответствовать определенному условию триггера — используя шаблон асинхронных операций  202 или возвращая массив.  
  
-   **ApiConnection** — выполняет опрос как триггер HTTP, но использует преимущества [интерфейсов API, управляемых Майкрософт](https://docs.microsoft.com/azure/connectors/apis-list).  
  
-   **httpWebhook** — открывает конечную точку аналогично триггеру запуска вручную, но также вызывает указанный URL-адрес для регистрации и отмены регистрации.  
  
-   **apiconnectionwebhook** — работает как триггер httpWebhook, используя преимущества интерфейсов API, управляемых Майкрософт.       
    Каждый тип триггера имеет разный набор **входных данных**, определяющий его поведение.  
  
## <a name="request-trigger"></a>Триггер запросов  

Этот триггер служит в качестве конечной точки, которая вызывается с помощью HTTP-запроса для вызова приложения логики. Триггер запроса выглядит следующим образом:  
  
```json
"<name-of-the-trigger>" : {
    "type" : "request",
    "kind": "http",
    "inputs" : {
        "schema" : {
            "properties" : {
                "myInputProperty1" : { "type" : "string" },
                "myInputProperty2" : { "type" : "number" }
            },
        "required" : [ "myInputProperty1" ],
        "type" : "object"
        }
    }
} 
```

Имеется также необязательное свойство, которое называется **schema**.  
  
|Имя элемента|Обязательно|Описание|  
|----------------|------------|---------------|  
|schema|Нет|Схема JSON, которая проверяет входящий запрос. Используется, чтобы указать, на какие свойства ссылаться последующим действиям рабочего процесса.|

Для вызова этой конечной точки необходимо вызвать API *listCallbackUrl*. См. сведения в статье [Рабочие процессы](https://docs.microsoft.com/rest/api/logic/workflows).  
  
## <a name="recurrence-trigger"></a>Триггер повторения  

Триггер recurrence — это триггер, который выполняется на основе заданного расписания. Такой триггер может выглядеть следующим образом:  

```json
"dailyReport" : {
    "type": "recurrence",
    "recurrence": {
        "frequency": "Day",
        "interval": "1"
    }
}
```

Как видно, это простой способ запуска рабочего процесса.  
  
|Имя элемента|Обязательно|Описание|  
|----------------|------------|---------------|  
|frequency|Да|Частота выполнения триггера. Используйте только одно из этих значений: Second, Minute, Hour, Day, Week, Month или Year.|  
|interval|Да|Интервал повторения в указанной единице времени|  
|startTime|Нет|Используется, если для свойства startTime указано значение без смещения от UTC.|  
|timeZone|Нет|Используется, если для свойства startTime указано значение без смещения от UTC.|  
  
Вы также можете запланировать запуск триггера в определенный момент времени в будущем. Например, если вы хотите, чтобы еженедельный отчет запускался каждый понедельник, можно запланировать запуск приложения логики каждый понедельник, создав следующий триггер:  

```json
"dailyReport" : {
    "type": "recurrence",
    "recurrence": {
        "frequency": "Week",
        "interval": "1",
        "startTime" : "2015-06-22T00:00:00Z"
    }
}
```

## <a name="http-trigger"></a>Триггер HTTP  

Триггеры HTTP опрашивают указанную конечную точку и проверяют ответ, чтобы определить, следует ли запускать рабочий процесс. Объект входных данных принимает набор параметров, необходимый для создания HTTP-вызова:  
  
|Имя элемента|Обязательно|Описание|Тип|  
|----------------|------------|---------------|--------|  
|метод|Да|Это может быть один из следующих методов HTTP: GET, POST, PUT, DELETE, HEAD или PATCH.|Строка|  
|uri|Да|Вызываемая конечная точка HTTP или HTTPS. Не более 2 КБ.|string|  
|Запросы|Нет|Объект, представляющий параметры запроса для добавления к URL-адресу. Например, `"queries" : { "api-version": "2015-02-01" }` добавляет `?api-version=2015-02-01` в URL-адрес.|Объект|  
|headers|Нет|Объект, представляющий все заголовки, которые отправляются в запрос. Например, чтобы задать язык и тип запроса: `"headers" : { "Accept-Language": "en-us",  "Content-Type": "application/json" }`|Объект|  
|текст|Нет|Объект, представляющий полезные данные, отправляемые конечной точке.|Объект|  
|retryPolicy|Нет|Объект, который позволяет настроить поведение повтора при возникновении ошибок 4xx или 5xx.|Объект|  
|authentication|Нет|Представляет метод для проверки подлинности запроса. Дополнительные сведения см. в статье [Исходящая проверка подлинности планировщика](https://docs.microsoft.com/azure/scheduler/scheduler-outbound-authentication). Помимо планировщика, имеется еще одно поддерживаемое свойство: `authority`. По умолчанию его значение равно `https://login.windows.net`, если не указано другое. Также можно использовать другое значение, например `https://login.windows\-ppe.net`.|Объект|  
  
Для эффективной работы с приложением логики триггеру HTTP требуется, чтобы HTTP API соответствовал определенному шаблону. Необходимы следующие поля:  
  
|Ответ|Описание|  
|------------|---------------|  
|Код состояния|Код состояния 200 \(ОК\) инициирует запуск. Другие коды состояния не вызывают запуск.|  
|Заголовок Retry\-After|Количество секунд перед повторным опросом конечной точки приложением логики.|  
|Заголовок Location|URL-адрес для вызова во время следующего интервала опроса. Если не указан, используется исходный URL-адрес.|  
  
Ниже приведены некоторые примеры различных поведений для различных типов запросов.  
  
|Код ответа|Retry\-After|Поведение|  
|-----------------|----------------|------------|  
|200|\(Нет\)|Недопустимый триггер. Необходимо указать заголовок Retry\-After. В противном случае обработчик не будет выполнять опрос при следующем запросе.|  
|202|60|Рабочий процесс не запускается. Следующая попытка произойдет через одну минуту.|  
|200|10|Рабочий процесс запускается, и через 10 секунд проверяется наличие дополнительного содержимого.|  
|400|\(Нет\)|Недопустимый запрос, рабочий процесс не запускается. Если **политика повтора** не задана, используется политика по умолчанию. По достижении определенного количества повторных попыток триггер перестает быть допустимым.|  
|500|\(Нет\)|Ошибка сервера. Рабочий процесс не запускается.  Если **политика повтора** не задана, используется политика по умолчанию. По достижении определенного количества повторных попыток триггер перестает быть допустимым.|  
  
Выходные данные триггера HTTP выглядят, как приведено ниже.  
  
|Имя элемента|Описание|Тип|  
|----------------|---------------|--------|  
|headers|Заголовки HTTP-ответа.|Объект|  
|текст|Текст HTTP-ответа.|Объект|  
  
## <a name="api-connection-trigger"></a>Триггер подключения API  

Триггер подключения API по своей функциональности аналогичен триггеру HTTP. Однако параметры для определения действия различаются. Пример:  
  
```json
"dailyReport" : {
    "type": "ApiConnection",
    "inputs": {
        "host": {
            "api": {
                "runtimeUrl": "https://myarticles.example.com/"
            },
        }
        "connection": {
            "name": "@parameters('$connections')['myconnection'].name"
        }
    },  
    "method": "POST",
    "body": {
        "category": "awesomest"
    }
}
```

|Имя элемента|Обязательно|Тип|Описание|  
|----------------|------------|--------|---------------|  
|host|Да||Шлюз, где размещено приложение API, и его идентификатор.|  
|метод|Да|Строка|Это может быть один из следующих методов HTTP: **GET**, **POST**, **PUT**, **DELETE**, **HEAD** или **PATCH**.|  
|Запросы|Нет|Объект|Представляет параметры запроса для добавления в URL-адрес. Например, `"queries" : { "api-version": "2015-02-01" }` добавляет `?api-version=2015-02-01` в URL-адрес.|  
|headers|Нет|Объект|Представляет все заголовки, которые отправляются в запрос. Например, чтобы задать язык и тип запроса: `"headers" : { "Accept-Language": "en-us",  "Content-Type": "application/json" }`|  
|текст|Нет|Объект|Представляет полезные данные, отправляемые конечной точке.|  
|retryPolicy|Нет|Объект|Позволяет настроить поведение повтора при возникновении ошибок 4xx или 5xx.|  
|authentication|Нет|Объект|Представляет метод для проверки подлинности запроса. Дополнительные сведения см. в статье [Исходящая проверка подлинности планировщика](https://docs.microsoft.com/azure/scheduler/scheduler-outbound-authentication).|  
  
Ниже приведены свойства узла.  
  
|Имя элемента|Обязательно|Описание|  
|----------------|------------|---------------|  
|api runtimeUrl|Да|Конечная точка управляемого API.|  
|connection name||Должно быть ссылкой на параметр с именем `$connection` и представлять имя подключения управляемого API, которое использует рабочий процесс.|
  
Выходные данные триггера подключения API:
  
|Имя элемента|Тип|Описание|  
|----------------|--------|---------------|  
|headers|Объект|Заголовки HTTP-ответа.|  
|текст|Объект|Текст HTTP-ответа.|  
  
## <a name="httpwebhook-trigger"></a>Триггер httpWebhook  

Триггер httpWebhook открывает конечную точку аналогично триггеру запуска вручную, но также вызывает указанный URL-адрес для регистрации и отмены регистрации. Триггер httpWebhook может выглядеть следующим образом:  

```json
"myappspottrigger": {
    "type": "httpWebhook",
    "inputs": {
        "subscribe": {
            "method": "POST",
            "uri": "https://pubsubhubbub.appspot.com/subscribe",
            "headers": { },
            "body": {
                "hub.callback": "@{listCallbackUrl()}",
                "hub.mode": "subscribe",
                "hub.topic": "https://pubsubhubbub.appspot.com/articleCategories/technology"
            },
            "authentication": { },
            "retryPolicy": { }
        },
        "unsubscribe": {
            "url": "https://pubsubhubbub.appspot.com/subscribe",
            "body": {
                "hub.callback": "@{workflow().endpoint}@{listCallbackUrl()}",
                "hub.mode": "unsubscribe",
                "hub.topic": "https://pubsubhubbub.appspot.com/articleCategories/technology"
            },
            "method": "POST",
            "authentication": { }
        }
    },
    "conditions": [ ]
    }
```

Многие из этих разделов являются необязательными, и поведение объекта webhook зависит от того, какие разделы предоставлены или опущены.  
Ниже приведены свойства объекта webhook.  
  
|Имя элемента|Обязательно|Описание|  
|----------------|------------|---------------|  
|subscribe|Нет|Исходящий запрос, который вызывается, когда триггер создается, и выполняет первоначальную регистрацию.|  
|unsubscribe|Нет|Исходящий запрос при удалении триггера.|  
  
-   **subscribe** является исходящим вызовом для начала прослушивания событий. Этот вызов запускается с тем же набором параметров, что и обычные действия HTTP. Этот исходящий вызов выполняется при любом изменении рабочего процесса, например когда происходит отзыв учетных данных или изменяются входные параметры триггера.
  
    Для поддержки этого вызова используется новая функция: `@listCallbackUrl()`. Эта функция возвращает уникальный URL-адрес для конкретного триггера в этом рабочем процессе. Это уникальный идентификатор для конечных точек, использующих REST для службы.  
  
-   **unsubscribe** вызывается, когда операция делает этот триггер недействительным, например в результате таких действий:  
  
    -   удаление или отключение триггера;  
  
    -   удаление или отключение рабочего процесса;  
  
    -   удаление или отключение подписки.  
  
    Приложение логики автоматически вызывает действие отмены подписки. Параметры этой функции совпадают с параметрами триггера HTTP.  
  
    Выходные данные триггера httpWebhook представляют собой содержимое входящего запроса.  
  
|Имя элемента|Тип|Описание|  
|-----------------|--------|---------------|  
|headers|Объект|Заголовки HTTP-запроса.|  
|текст|Объект|Текст HTTP-запроса.|  

Ограничения для действий webhook можно указать так же, как [ограничения для асинхронной модели HTTP](#asynchronous-limits).
  

## <a name="conditions"></a>Условия  

Для любого триггера можно задать одно или несколько условий, определяющих, должен ли выполняться рабочий процесс. Например:  

```json
"dailyReport" : {
    "type": "recurrence",
    "conditions": [ {
        "expression": "@parameters('sendReports')"
    } ],
    "recurrence": {
        "frequency": "Day",
        "interval": "1"
    }
}
```

В этом случае отчет запускается, если для параметра рабочего процесса `sendReports` установлено значение true. Условия могут ссылаться на код состояния триггера. Например, можно настроить так, чтобы рабочий процесс запускался только в том случае, если веб-сайт возвращает код состояния 500:
  
```  
"conditions": [  
        {  
          "expression": "@equals(triggers().code, 'InternalServerError')"  
        }  
      ]  
```  
  
> [!NOTE]  
> Если любое выражение ссылается на код состояния триггера \(каким-либо образом\), поведение по умолчанию \(запускать только при возникновении кода состояния 200 \(ОК\)\) изменяется. Например, если требуется запуск при возникновении кода состояния 200 и 201, необходимо включить `@or(equals(triggers().code, 200),equals(triggers().code,201))` в качестве условия.  
  
## <a name="start-multiple-runs-for-a-request"></a>Запуск нескольких выполнений запроса

Для запуска нескольких выполнений одного запроса можно использовать `splitOn`. Например, при необходимости опросить конечную точку, которая может получить несколько новых элементов между интервалами опроса.
  
Используя `splitOn`, можно указать свойство в полезных данных ответа, содержащих массив элементов, каждый из которых необходим для запуска триггера. Представьте, что у вас есть API, который возвращает следующий ответ:  
  
```json
{
    "Status" : "success",
    "Rows" : [
        {  
            "id" : 938109380,
            "name" : "mycoolrow"
        },
        {
            "id" : 938109381,
            "name" : "another row"
        }
    ]
}
```
  
Приложению логики необходимо только содержимое строк, поэтому можно создать триггер, как в следующем примере:  
  
```json
"mysplitter" : {
    "type" : "http",
    "recurrence": {
        "frequency": "Minute",
        "interval": "1"
    },
    "intputs" : {
        "uri" : "https://mydomain.com/myAPI",
        "method" : "GET"
    },
    "splitOn" : "@triggerBody()?.Rows"
}
```
  
Затем в определении рабочего процесса `@triggerBody().name` возвращает `mycoolrow` для первого выполнения и `another row` для второго. Выходные данные триггера выглядят следующим образом:  
  
```json
{
    "body" : {
        "id" : 938109381,
        "name" : "another row"
    }
}
```

Если используется `SplitOn`, невозможно получить свойства, которые находятся за пределами массива, в данном случае поле `Status`.  
  
> [!NOTE]  
> В этом примере используется оператор `?`, чтобы избежать ошибок, если отсутствует свойство `Rows`. 
  
## <a name="single-run-instance"></a>Экземпляр однократного выполнения

Для триггеров можно настроить так, чтобы свойство повторения срабатывало, только если завершены все активные выполнения. Если запланированное повторение случается во время уже происходящего выполнения, триггер не срабатывает и ожидает следующего запланированного интервала повторения, чтобы сделать повторную проверку.

Этот параметр можно настроить с помощью параметров операции:

```json
"triggers": {
    "mytrigger": {
        "type": "http",
        "inputs": { ... },
        "recurrence": { ... },
        "operationOptions": "singleInstance"
    }
}
```

## <a name="types-and-inputs"></a>Типы и входные данные  

Существует много типов действий, каждое из которых имеет уникальное поведение. Действия коллекций могут содержать множество вложенных действий.

### <a name="standard-actions"></a>Стандартные действия  

-   **http** — это действие вызывает конечную веб-точку HTTP.  
  
-   **apiConnection** — это действие ведет себя как действие HTTP, но использует интерфейсы API, управляемые Майкрософт.  
  
-   **apiConnectionWebhook** — аналогично httpWebhook, но использует интерфейсы API, управляемые Майкрософт.  
  
-   **response** — это действие определяет ответ для входящего вызова.  
  
-   **wait** — это простое действие ожидает фиксированное количество времени или до определенного времени.  
  
-   **workflow** — это действие представляет вложенный рабочий процесс.  

-   **Function** \- — это действие представляет функцию Azure.

### <a name="collection-actions"></a>Действия коллекций

-   **scope** — это действие является логическим объединением других действий.

-   **condition** — это действие вычисляет выражение и выполняет соответствующую ветвь результатов.

-   **foreach** — это циклическое действие выполняет итерацию по массиву и внутренние действия для каждого элемента.

-   **Until** — это циклическое действие выполняет внутренние действия, пока для условия не возвращается значение true.
  
Каждый тип действия имеет разный набор **входных данных**, определяющих его поведение.  
  
## <a name="http-action"></a>Действие HTTP  

Действия HTTP вызывают указанную конечную точку и проверяют ответ, чтобы определить, следует ли запускать рабочий процесс. Объект **входных данных** принимает набор параметров, необходимых для создания HTTP-вызова:  
  
|Имя элемента|Обязательно|Тип|Описание|  
|----------------|------------|--------|---------------|  
|метод|Да|Строка|Это может быть один из следующих методов HTTP: **GET**, **POST**, **PUT**, **DELETE**, **HEAD** или **PATCH**.|  
|uri|Да|Строка|Вызываемая конечная точка HTTP или HTTPS. Не более 2 КБ.|  
|Запросы|Нет|Объект|Представляет параметры запроса для добавления в URL-адрес. Например, `"queries" : { "api-version": "2015-02-01" }` добавляет `?api-version=2015-02-01` в URL-адрес.|  
|headers|Нет|Объект|Представляет все заголовки, которые отправляются в запрос. Например, чтобы задать язык и тип запроса: `"headers" : { "Accept-Language": "en-us",  "Content-Type": "application/json" }`|  
|текст|Нет|Объект|Представляет полезные данные, отправляемые конечной точке.|  
|retryPolicy|Нет|Объект|Позволяет настроить поведение повтора при возникновении ошибок 4xx или 5xx.|  
|operationsOptions|Нет|string|Определяет набор особого поведения для переопределения.|  
|authentication|Нет|Объект|Представляет метод для проверки подлинности запроса. Дополнительные сведения см. в статье [Исходящая проверка подлинности планировщика](https://docs.microsoft.com/azure/scheduler/scheduler-outbound-authentication). Помимо планировщика, имеется еще одно поддерживаемое свойство: `authority`. По умолчанию его значение равно `https://login.windows.net`, если не указано другое. Также можно использовать другое значение, например `https://login.windows\-ppe.net`.|  
  
Действия HTTP и \(действия API подключения\) поддерживают политики повтора. Помимо исключений при подключении, политика повтора применяется к периодическим сбоям, классифицируемым как коды состояния HTTP 408, 429 и 5xx. Эта политика описывается с помощью объекта *retryPolicy*, определенного, как показано ниже.
  
```json
"retryPolicy" : {
    "type": "<type-of-retry-policy>",
    "interval": <retry-interval>,
    "count": <number-of-retry-attempts>
}
```
  
Интервал повторных попыток указывается в формате ISO 8601. Минимальное значение по умолчанию для этого интервала составляет 20 секунд, а максимальное — один час. Максимальное число повторных попыток по умолчанию составляет четыре часа. Если определение политики повтора не указано, используется стратегия `fixed` со значениями числа и интервала повтора по умолчанию. Чтобы отключить политику повтора, задайте для нее тип `None`.  
  
Например, при возникновении временных сбоев следующее действие от двух до трех раз пытается получить последние новости с 30-секундной задержкой между попытками.  
  
```json
"latestNews" : {
    "type": "http",
    "inputs": {
        "method": "GET",
        "uri": "https://mynews.example.com/latest",
        "retryPolicy" : {
            "type": "fixed",
            "interval": "PT30S",
            "count": 2
        }
    }
}
```
### <a name="asynchronous-patterns"></a>Модель асинхронных операций

По умолчанию все действия на основе HTTP поддерживают стандартную модель асинхронных операций. Таким образом, если удаленный сервер указывает, что запрос принят для обработки с ответом 202 \(Accepted\), ядро приложений логики продолжает опрашивать URL-адрес, указанный в заголовке расположения ответа, пока не получит конечного ответа, отличного \(от ответа 202\).  
  
Чтобы отключить асинхронное поведение, установите параметр `DisableAsyncPattern` во входных данных действия. В таком случае входные данные действия будут основаны на первоначальном ответе 202 от сервера.  
  
```json
"invokeLongRunningOperation" : {
    "type": "http",
    "inputs": {
        "method": "POST",
        "uri": "https://host.example.com/resources"
    },
    "operationOptions": "DisableAsyncPattern"
}
```

#### <a name="asynchronous-limits"></a>Ограничения асинхронных операций

Действие модели асинхронных операций можно ограничить, задав определенный период времени.  Если интервал времени истекает без достижения конечного состояния, состояние действия будет помечено как `Cancelled` с помощью кода `ActionTimedOut`.  Ограничение времени ожидания указывается в формате ISO 8601.  Ограничения можно задать с помощью следующего синтаксиса:

``` json
"<action-name>": {
    "type": "workflow|webhook|http|apiconnectionwebhook|apiconnection",
    "inputs": { },
    "limit": {
        "timeout": "PT10S"
    }
}
```
  
## <a name="api-connection"></a>API подключения  

API подключения — это действие, которое ссылается на соединитель, управляемый Майкрософт.
Для этого действия требуется ссылка на допустимое подключение и сведения об API и необходимых параметрах.

|Имя элемента|Обязательно|Тип|Описание|  
|----------------|------------|--------|---------------|  
|host|Да|Объект|Представляет сведения о соединителе, например runtimeUrl, и ссылку на объект подключения.|
|метод|Да|Строка|Это может быть один из следующих методов HTTP: **GET**, **POST**, **PUT**, **DELETE**, **HEAD** или **PATCH**.|  
|path|Да|Строка|Путь к операции API.|  
|Запросы|Нет|Объект|Представляет параметры запроса для добавления в URL-адрес. Например, `"queries" : { "api-version": "2015-02-01" }` добавляет `?api-version=2015-02-01` в URL-адрес.|  
|headers|Нет|Объект|Представляет все заголовки, которые отправляются в запрос. Например, чтобы задать язык и тип запроса: `"headers" : { "Accept-Language": "en-us",  "Content-Type": "application/json" }`|  
|текст|Нет|Объект|Представляет полезные данные, отправляемые конечной точке.|  
|retryPolicy|Нет|Объект|Позволяет настроить поведение повтора при возникновении ошибок 4xx или 5xx.|  
|operationsOptions|Нет|string|Определяет набор особого поведения для переопределения.|  

```json
"Send_Email": {
    "type": "apiconnection",
    "inputs": {
        "host": {
            "api": {
                "runtimeUrl": "https://logic-apis-df.azure-apim.net/apim/office365"
            },
            "connection": {
                "name": "@parameters('$connections')['office365']['connectionId']"
            }
        },
        "method": "post",
        "body": {
            "Subject": "New Tweet from @{triggerBody()['TweetedBy']}",
            "Body": "@{triggerBody()['TweetText']}",
            "To": "me@example.com"
        },
        "path": "/Mail"
    },
    "runAfter": {}
    }
```

## <a name="api-connection-webhook-action"></a>Действие webhook API подключения

```json
"Send_approval_email": {
    "type": "apiconnectionwebhook",
    "inputs": {
        "host": {
            "api": {
                "runtimeUrl": "https://logic-apis-df.azure-apim.net/apim/office365"
            },
            "connection": {
                "name": "@parameters('$connections')['office365']['connectionId']"
            }
        },
        "body": {
            "Message": {
                "Subject": "Approval Request",
                "Options": "Approve, Reject",
                "Importance": "Normal",
                "To": "me@email.com"
            }
        },
        "path": "/approvalmail",
        "authentication": "@parameters('$authentication')"
    },
    "runAfter": {}
}
```

Ограничения для действий webhook можно указать так же, как [ограничения для асинхронной модели HTTP](#asynchronous-limits).
  
## <a name="response-action"></a>Действие ответа  

Этот тип действия содержит все полезные данные ответа из HTTP-запроса и содержит код состояния, текст и заголовки:  
  
```json
"myresponse" : {
    "type" : "response",
    "inputs" : {
        "statusCode" : 200,
        "body" : {
            "contentFieldOne" : "value100",
            "anotherField" : 10.001
        },
        "headers" : {
            "x-ms-date" : "@utcnow()",
            "Content-type" : "application/json"
        }
    },
    "runAfter": {}
}
```
  
Действие ответа имеет специальные ограничения, которые не применяются к другим действиям. В частности:  
  
-   Действия ответов не могут быть параллельными в определении, так как требуется детерминированный ответ на входящий запрос.  
  
-   Если действие ответа получено после получения ответа входящим запросом, действие считается неудачным \(конфликт\) и, как результат, получает состояние `Failed`.  
  
-   Рабочий процесс с действиями ответа не может содержать `splitOn` в своем триггере, так как один вызов запускает несколько выполнений. Поэтому это нужно проверить, когда поток использует метод PUT и получает ошибку запроса.  
  
## <a name="wait-action"></a>Действие wait  

Действие `wait` приостанавливает выполнение рабочего процесса на указанный период времени. Например, чтобы ожидать 15 минут, можно использовать следующий фрагмент кода:  
  
```json
"waitForFifteenMinutes" : {
    "type": "wait",
    "inputs": {
        "interval": {
            "unit" : "minute",
            "count" : 15
        }
    }
}
```  
  
Кроме того, чтобы задать ожидание до определенного момента времени, можно использовать такой пример:  
  
```json
"waitUntilOctober" : {
    "type": "wait",
    "inputs": {
        "until": {
            "timestamp" : "2016-10-01T00:00:00Z"
        }
    }
}
```
  
> [!NOTE]  
> Длительность ожидания можно задать только с помощью одного из объектов — **interval** или **until**.  
  
|Имя|Обязательно|Тип|Описание|  
|--------|------------|--------|---------------|  
|interval|Нет|Объект|Длительность ожидания зависит от количества времени.|  
|interval unit|Да|Строка|Одна из таких единиц времени: second, minute, hour, day, week, month, year.|  
|interval count|Да|Строка|Длительность на основе заданной внутренней единицы измерения.|  
|until|Нет|Объект|Длительность ожидания на основе точки на момент времени.|  
|until timestamp|Да|string|Точка во времени в формате UTC, когда истекает время ожидания.|  

## <a name="query-action"></a>Действие запроса

Действие `query` позволяет фильтровать массив на основе условия. Например, чтобы выбрать числа больше 2, можно использовать:

```json
"FilterNumbers" : {
    "type": "query",
    "inputs": {
        "from": [ 1, 3, 0, 5, 4, 2 ],
        "where": "@greater(item(), 2)"
    }
}
```

Выходные данные действия `query` представлены в виде массива, содержащего элементы из массива входных данных, которые соответствуют условию.

> [!NOTE]
> Если значений, соответствующих условию `where`, нет, результатом будет пустой массив.

|Имя|Обязательно|Тип|Описание|
|--------|------------|--------|---------------|
|from|Да|Массив,|Исходный массив.|
|где:|Да|Строка|Условие, применяемое к каждому элементу исходного массива.|

## <a name="select-action"></a>Выбор действия

Действие `select` позволяет проецировать каждый элемент массива на новое значение.
Например, чтобы преобразовать массив чисел в массив объектов, можно использовать следующую команду:

```json
"SelectNumbers" : {
    "type": "select",
    "inputs": {
        "from": [ 1, 3, 0, 5, 4, 2 ],
        "select": { "number": "@item()" }
    }
}
```

Выходные данные действия `select` — это массив с таким же количеством элементов, как и во входном массиве. При этом каждый его элемент преобразован так, как предписывает свойство `select`. Если вход — это пустой массив, выходные данные также будут пустым массивом.

|Имя|Обязательно|Тип|Описание|
|--------|------------|--------|---------------|
|from|Да|Массив,|Исходный массив.|
|select|Да|Любой|Проекция, применяемая к каждому элементу исходного массива.|

## <a name="terminate-action"></a>Действие terminate

Действие terminate останавливает выполнение рабочего процесса, прерывая активные действия и пропуская все оставшиеся действия. Например, для прерывания выполнения с состоянием **Failed** можно использовать следующий фрагмент кода:

```json
"HandleUnexpectedResponse" : {
    "type": "terminate",
    "inputs": {
        "runStatus" : "failed",
        "runError": {
            "code": "UnexpectedResponse",
            "message": "Received an unexpected response.",
        }
    }
}
```

> [!NOTE]
> Действие прерывания не распространяется на уже выполненные действия.

|Имя|Обязательно|Тип|Описание|
|--------|------------|--------|---------------|
|runStatus|Да|string|Состояние выполнения объекта: **Failed** или **Cancelled**.|
|runError|Нет|Объект|Сведения об ошибке. Поддерживается, только если **runStatus** имеет значение **Failed**.|
|runError code|Нет|Строка|Код ошибки выполнения.|
|runError message|Нет|Строка|Сообщение об ошибке выполнения.|

## <a name="compose-action"></a>Действие compose

Действие compose позволяет создать произвольный объект. Выходные данные действия compose являются результатом вычисления входных данных. Например, это действие можно использовать для объединения выходных данных нескольких действий:

```json
"composeUserRecord" : {
    "type": "compose",
    "inputs": {
        "firstName": "@actions('getUser').firstName",
        "alias": "@actions('getUser').alias",
        "thumbnailLink": "@actions('lookupThumbnail').url"
        }
    }
}
```

> [!NOTE]
> Действие **compose** может использоваться для создания выходных данных, включая объекты, массивы и любой другой тип, изначально поддерживаемый приложениями логики (XML и двоичный тип).

## <a name="table-action"></a>Действие таблицы

Позволяет `table` преобразовать массив элементов в таблицу **CVS** или **HTML**.

Предположим, что @triggerBody() выглядит следующим образом:

```json
[{
  "id": 0,
  "name": "apples"
},{
  "id": 1, 
  "name": "oranges"
}]
```

Пускай действие определено так:

```json
"ConvertToTable" : {
    "type": "table",
    "inputs": {
        "from": "@triggerBody()",
        "format": "html"
    }
}
```

Результат для указанного выше кода будет следующим:

<table><thead><tr><th>id</th><th>name</th></tr></thead><tbody><tr><td>0</td><td>apples</td></tr><tr><td>1</td><td>oranges</td></tr></tbody></table>"

Чтобы настроить таблицу, можно явно указать столбцы. Например:

```json
"ConvertToTable" : {
    "type": "table",
    "inputs": {
        "from": "@triggerBody()",
        "format": "html",
        "columns": [{
          "header": "produce id",
          "value": "@item().id"
        },{
          "header": "description",
          "value": "@concat('fresh ', item().name)"
        }]
    }
}
```

Результат для указанного выше кода будет следующим:

<table><thead><tr><th>Код результата</th><th>Описание</th></tr></thead><tbody><tr><td>0</td><td>fresh apples</td></tr><tr><td>1</td><td>fresh oranges</td></tr></tbody></table>"

Если значение свойства `from` — это пустой массив, выходные данные будут пустой таблицей.

|Имя|Обязательно|Тип|Описание|
|--------|------------|--------|---------------|
|from|Да|Массив,|Исходный массив.|
|свойства|Да|Строка|Формат (**CVS** или **HTML**).|
|columns|Нет|Массив,|Столбцы. Позволяет переопределить стандартную форму таблицы.|
|column header|Нет|string|Заголовок столбца.|
|column value|Да|Строка|Значение столбца.|

## <a name="workflow-action"></a>Действие workflow   

|Имя|Обязательно|Тип|Описание|  
|--------|------------|--------|---------------|  
|host id|Да|string|Идентификатор ресурса рабочего процесса, который требуется вызвать.|  
|host triggerName|Да|string|Имя триггера, который необходимо вызвать.|  
|Запросы|Нет|Объект|Представляет параметры запроса для добавления в URL-адрес. Например, `"queries" : { "api-version": "2015-02-01" }` добавляет `?api-version=2015-02-01` в URL-адрес.|  
|headers|Нет|Объект|Представляет все заголовки, которые отправляются в запрос. Например, чтобы задать язык и тип запроса: `"headers" : { "Accept-Language": "en-us",  "Content-Type": "application/json" }`|  
|текст|Нет|Объект|Представляет полезные данные, отправляемые конечной точке.|  
  
```json
"mynestedwf" : {
    "type" : "workflow",
    "inputs" : {
        "host" : {
            "id" : "/subscriptions/xxxxyyyyzzz/resourceGroups/rg001/providers/Microsoft.Logic/mywf001",
            "triggerName " : "mytrigger001"
        },
        "queries" : {
            "extrafield" : "specialValue"
        },  
        "headers" : {
            "x-ms-date" : "@utcnow()",
            "Content-type" : "application/json"
        },
        "body" : {
            "contentFieldOne" : "value100",
            "anotherField" : 10.001
        }
    },
    "runAfter": {}
    }
```
  
Проверка доступа выполняется в рабочем процессе, \(точнее в триггере\). Это означает, что требуется доступ к рабочему процессу.  
  
Выходные данные действия `workflow` основаны на заданном в действии `response` в дочернем рабочем процессе. Если действие `response` не задано, выходные данные будут пустыми.  

## <a name="function-action"></a>Действие функции   

|Имя|Обязательно|Тип|Описание|  
|--------|------------|--------|---------------|  
|ИД функции|Да|string|Идентификатор ресурса функции, которую требуется вызвать.|  
|метод|Нет|Строка|Метод HTTP, используемый для вызова функции. Если не указан, по умолчанию используется `POST`.|  
|Запросы|Нет|Объект|Представляет параметры запроса для добавления в URL-адрес. Например, `"queries" : { "api-version": "2015-02-01" }` добавляет `?api-version=2015-02-01` в URL-адрес.|  
|headers|Нет|Объект|Представляет все заголовки, которые отправляются в запрос. Например, чтобы задать язык и тип запроса: `"headers" : { "Accept-Language": "en-us" }`.|  
|текст|Нет|Объект|Представляет полезные данные, отправляемые конечной точке.|  

```json
"myfunc" : {
    "type" : "Function",
    "inputs" : {
        "function" : {
            "id" : "/subscriptions/xxxxyyyyzzz/resourceGroups/rg001/providers/Microsoft.Web/sites/myfuncapp/functions/myfunc"
        },
        "queries" : {
            "extrafield" : "specialValue"
        },  
        "headers" : {
            "x-ms-date" : "@utcnow()"
        },
        "method" : "POST",
    "body" : {
            "contentFieldOne" : "value100",
            "anotherField" : 10.001
        }
    },
    "runAfter": {}
}
```

При сохранении приложения логики мы выполняем ряд проверок указанной функции.
-   У вас должен быть доступ к функции.
-   Допускается только стандартный триггер HTTP или универсальный триггер webhook в формате JSON.
-   В ней не должен быть определен какой-либо маршрут.
-   Допускаются только авторизация с помощью функции и анонимная авторизация.

URL-адрес триггера извлекается, помещается в кэш и используется во время выполнения. Поэтому, если какая-либо операция делает недействительным кэшированный URL-адрес, то во время выполнения действие заканчивается сбоем. Чтобы обойти это, еще раз сохраните приложение логики. При этом приложение логики повторно получит и поместит в кэш URL-адрес триггера.

## <a name="collection-actions-scopes-and-loops"></a>Действия коллекций (области и циклы)

Действия некоторых типов могут содержать вложенные действия. На действия ссылок в коллекции можно ссылаться непосредственно за пределами коллекции. Если вы определили `http` в области, `@body('http')` действительно в любой точке рабочего процесса. Действия в коллекции могут выполнять (`runAfter`) только после других действий в этой коллекции.

## <a name="scope-action"></a>Действие scope

Действие `scope` позволяет логически группировать действия в рабочем процессе.

|Имя|Обязательно|Тип|Описание|  
|--------|------------|--------|---------------|  
|actions|Да|Объект|Внутренние действия, выполняемые в области.|

```json
{
    "myScope": {
        "type": "scope",
        "actions": {
            "call_bing": {
                "type": "http",
                "inputs": {
                    "url": "http://www.bing.com"
                }
            }
        }
    }
}
```

## <a name="foreach-action"></a>Действие foreach

Это циклическое действие выполняет итерацию по массиву и внутренние действия для каждого элемента. По умолчанию цикл ForEach выполняется параллельно (20 параллельных выполнений одновременно). Правила выполнения можно задать с помощью параметра `operationOptions`.

|Имя|Обязательно|Тип|Описание|  
|--------|------------|--------|---------------|  
|actions|Да|Объект|Внутренние действия, выполняемые в цикле.|
|foreach|Да|строка|Массив для итерации.|
|operationOptions|Нет|строка|Любые параметры операции для определения поведения. В данный момент поддерживается только `sequential` для последовательного выполнения итераций (поведение по умолчанию — параллельное выполнение).|

```json
"forEach_email": {
    "type": "foreach",
    "foreach": "@body('email_filter')",
    "actions": {
        "send_email": {
            "type": "ApiConnection",
            "inputs": {
                "body": {
                    "to": "@item()",
                    "from": "me@contoso.com",
                    "message": "Hello, thank you for ordering"
                }
                "host": {
                    "connection": {
                        "id": "@parameters('$connections')['office365']['connection']['id']"
                    }
                }
            }
        }
    },
    "runAfter":{
        "email_filter": [ "Succeeded" ]
    }
}
```

## <a name="until-action"></a>Действие Until

Это циклическое действие выполняет внутренние действия, пока для условия не возвращается значение true.

|Имя|Обязательно|Тип|Описание|  
|--------|------------|--------|---------------|  
|actions|Да|Объект|Внутренние действия, выполняемые в цикле.|
|expression|Да|string|Выражение, вычисляемое после каждой итерации.|
|limit|Да|Объект|Для цикла должно быть определено по крайней мере одно ограничение.|
|count|Нет|int|Ограничение на число итераций, которые могут быть выполнены.|
|timeout|Нет|строка|Время ожидания выполнения цикла  (в формате ISO 8601).|


```json
 "Until_succeeded": {
    "actions": {
        "Http": {
            "inputs": {
                "method": "GET",
                "uri": "http://myurl"
            },
            "runAfter": {},
            "type": "Http"
        }
    },
    "expression": "@equals(outputs('Http')['statusCode', 200)",
    "limit": {
        "count": 1000,
        "timeout": "PT1H"
    },
    "runAfter": {},
    "type": "Until"
}
```

## <a name="conditions---if-action"></a>Условия. Действие If

Действие `If` позволяет вычислить условие и выполнить ветвь в зависимости от того, получает ли выражение значение `true`.

|Имя|Обязательно|Тип|Описание|  
|--------|------------|--------|---------------|  
|actions|Да|Объект|Внутренние действия, выполняемые, когда выражение получает значение `true`.|
|expression|Да|строка|Выражение для вычисления.|
|else|Нет|Объект|Внутренние действия, выполняемые, когда выражение получает значение `false`.|
  
```json
"My_condition": {
    "actions": {
        "If_true": {
            "inputs": {
                "method": "GET",
                "uri": "http://myurl"
            },
            "runAfter": {},
            "type": "Http"
        }
    },
    "else": {
        "actions": {
            "if_false": {
                "inputs": {
                    "method": "GET",
                    "uri": "http://myurl"
                },
                "runAfter": {},
                "type": "Http"
            }
        }
    },
    "expression": "@equals(triggerBody(), json(true))",
    "runAfter": {},
    "type": "If"
}
```  
  
Ниже приведены примеры, как условия могут использовать выражения в действии.  
  
|Значение JSON|Результат|  
|--------------|----------|  
|`"expression": "@parameters('hasSpecialAction')"`|Условие выполняется при наличии какого-либо значения, которое возвращает значение true для выражения. Поддерживаются только логические выражения. Для преобразования других типов в логическое значение используются функции `empty` и `equals`.|  
|`"expression": "@greater(actions('act1').output.value, parameters('threshold'))"`|Поддерживаются функции сравнения. В этом примере действие выполняется, только если выходные данные act1 превышают пороговое значение.|  
|`"expression": "@or(greater(actions('act1').output.value, parameters('threshold')), less(actions('act1').output.value, 100))"`|Функции логики позволяют создавать вложенные логические выражения. В этом случае действие выполняется, если выходные данные act1 выше порогового значения или меньше 100.|  
|`"expression": "@equals(length(actions('act1').outputs.errors), 0))"`|Чтобы проверить, содержит ли массив элементы, можно использовать функции массива. В этом случае действие выполняется, если массив ошибок пустой.| 
|`"expression": "parameters('hasSpecialAction')"`|Ошибка является недопустимым условием, поскольку для условия требуется @.|  
  
Если условие выполняется успешно, оно помечается как `Succeeded`. Действия в объектах `actions` или `else` помечаются как `Succeeded` при успешном выполнении, `Failed` при выполнении с ошибкой или `Skipped`, если эта ветвь не выполняется.

## <a name="next-steps"></a>Дальнейшие действия

[REST API службы рабочих процессов](https://docs.microsoft.com/rest/api/logic/workflows)

