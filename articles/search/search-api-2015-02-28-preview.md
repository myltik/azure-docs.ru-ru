---
title: "REST API службы поиска Azure версии 2015-02-28-Preview | Документация Майкрософт"
description: "В версии 2015-02-28-Preview API REST службы поиска Azure реализованы экспериментальные функции, такие как анализаторы естественных языков и запросы moreLikeThis."
services: search
documentationcenter: na
author: brjohnstmsft
manager: pablocas
editor: 
ms.assetid: 3dba3bf8-9c83-42f6-82bc-04727bd11037
ms.service: search
ms.devlang: rest-api
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: search
ms.date: 05/01/2017
ms.author: brjohnst
ms.translationtype: Human Translation
ms.sourcegitcommit: 245ce9261332a3d36a36968f7c9dbc4611a019b2
ms.openlocfilehash: e6ad5c964bfa8421be2706cb4015980e01a271b7
ms.contentlocale: ru-ru
ms.lasthandoff: 06/09/2017

---
# <a name="azure-search-service-rest-api-version-2015-02-28-preview"></a>API REST службы поиска Azure, версия 2015-02-28-Preview
Эта статья представляет собой справочную документацию по версии `api-version=2015-02-28-Preview`. Она расширяет текущую общедоступную версию [api-version=2015-02-28](https://msdn.microsoft.com/library/dn798935.aspx), изменения в которую заблокированы, и содержит перечисленные ниже экспериментальные функции.

* `moreLikeThis` в API [Поиск документов](#SearchDocs) . Находит другие документы, связанные с другим указанным документом.

Несколько дополнительных частей REST API `2015-02-28-Preview` описаны отдельно. В частности, описаны такие возможности:

* [Профили оценки](search-api-scoring-profiles-2015-02-28-preview.md)
* [Индексаторы](search-api-indexers-2015-02-28-preview.md)

Существуют различные версии службы поиска Azure. Дополнительные сведения см. в статье, посвященной [управлению версиями службы поиска](http://msdn.microsoft.com/library/azure/dn864560.aspx).

## <a name="apis-in-this-document"></a>API, рассматриваемый в этом документе
API службы поиска Azure поддерживает две синтаксические схемы URL, которые можно использовать для операций API: простой синтаксис и синтаксис OData, который описан в статье о [поддержке OData в API службы поиска Azure](http://msdn.microsoft.com/library/azure/dn798932.aspx). В разделах из приведенного ниже списка рассматривается простой синтаксис.

[Создание индекса](#CreateIndex)

    POST /indexes?api-version=2015-02-28-Preview

[Обновление индекса](#UpdateIndex)

    PUT /indexes/[index name]?api-version=2015-02-28-Preview

[Получение индекса](#GetIndex)

    GET /indexes/[index name]?api-version=2015-02-28-Preview

[Получение списка индексов](#ListIndexes)

    GET /indexes?api-version=2015-02-28-Preview

[Получение статистических данных индекса](#GetIndexStats)

    GET /indexes/[index name]/stats?api-version=2015-02-28-Preview

[Анализатор теста](#TestAnalyzer)

    POST /indexes/[index name]/analyze?api-version=2015-02-28-Preview

[Удаление индекса](#DeleteIndex)

    DELETE /indexes/[index name]?api-version=2015-02-28-Preview

[Добавление, удаление и обновление данных в индексе](#AddOrUpdateDocuments)

    POST /indexes/[index name]/docs/index?api-version=2015-02-28-Preview

[Поиск документов](#SearchDocs)

    GET /indexes/[index name]/docs?[query parameters]
    POST /indexes/[index name]/docs/search?api-version=2015-02-28-Preview

[Запрос документов](#LookupAPI)

     GET /indexes/[index name]/docs/[key]?[query parameters]

[Подсчет документов](#CountDocs)

    GET /indexes/[index name]/docs/$count?api-version=2015-02-28-Preview

[Предложения](#Suggestions)

    GET /indexes/[index name]/docs/suggest?[query parameters]
    POST /indexes/[index name]/docs/suggest?api-version=2015-02-28-Preview

- - -
<a name="IndexOps"></a>

## <a name="index-operations"></a>Операции с индексом
Для создания индексов в службе поиска Azure и управления ими используются простые HTTP-запросы (POST, GET, PUT, DELETE), отправляемые к определенному ресурсу индекса. Чтобы создать индекс, необходимо сначала отправить с помощью запроса POST документ JSON, который описывает его схему. В схеме определяются поля индекса, их типы данных, а также возможные варианты их использования (например, в полнотекстовом поиске, фильтрах, сортировке и аспектах). Она также определяет профили оценки, средства подбора и другие атрибуты, которые позволяют настроить поведение индекса.

Ниже приведен пример схемы, которая используется для поиска сведений о гостиницах, с полем описания, определенным на двух языках. Обратите внимание на то, как атрибуты определяют порядок использования поля. Например, `hotelId` используется в качестве ключа документа (`"key": true`) и исключается из полнотекстового поиска (`"searchable": false`).

    {
    "name": "hotels",  
    "fields": [
      {"name": "hotelId", "type": "Edm.String", "key": true, "searchable": false},
      {"name": "baseRate", "type": "Edm.Double"},
      {"name": "description", "type": "Edm.String", "filterable": false, "sortable": false, "facetable": false},
      {"name": "description_fr", "type": "Edm.String", "filterable": false, "sortable": false, "facetable": false, "analyzer": "fr.lucene"},
      {"name": "hotelName", "type": "Edm.String"},
      {"name": "category", "type": "Edm.String"},
      {"name": "tags", "type": "Collection(Edm.String)"},
      {"name": "parkingIncluded", "type": "Edm.Boolean"},
      {"name": "smokingAllowed", "type": "Edm.Boolean"},
      {"name": "lastRenovationDate", "type": "Edm.DateTimeOffset"},
      {"name": "rating", "type": "Edm.Int32"},
      {"name": "location", "type": "Edm.GeographyPoint"}
     ],
     "suggesters": [
      {
       "name": "sg",
       "searchMode": "analyzingInfixMatching",
       "sourceFields": ["hotelName"]
      }
     ]
    }

После создания индекса в него необходимо добавить документы. Этот этап описан в разделе [Добавление и обновление документов](#AddOrUpdateDocuments) .

Вы также можете ознакомиться с [видеороликом Channel 9 Cloud Cover](http://go.microsoft.com/fwlink/p/?LinkId=511509), в котором рассматривается индексирование в службе поиска Azure.

<a name="CreateIndex"></a>

## <a name="create-index"></a>Создание индекса
Индекс — это основной инструмент для упорядочения и поиска документов в службе поиска Azure (аналогично тому, как для организации записей в базе данных используются таблицы). Каждый индекс содержит коллекцию документов, которые соответствуют его схеме (в ней определены имена полей, типы данных и свойства). Кроме того, в индексах задаются дополнительные объекты (средства подбора, профили оценки и параметры CORS), которые влияют на обработку поисковых запросов.

Для создания нового индекса в службе поиска Azure используется HTTP-запрос POST или PUT. Тело запроса представляет собой схему JSON, которая определяет индекс и конфигурацию.

    POST https://[service name].search.windows.net/indexes?api-version=[api-version]
    Content-Type: application/json
    api-key: [admin key]

Вы также можете отправить запрос PUT и передать имя индекса в URI. Если такого индекса не существует, он будет создан.

    PUT https://[search service url]/indexes/[index name]?api-version=[api-version]

При создании индекса определяется структура документов, которые будут в нем храниться и участвовать в поиске. Заполнение индекса выполняется с помощью отдельной операции. На этом этапе можно использовать [индексатор](https://msdn.microsoft.com/library/azure/mt183328.aspx) (для поддерживаемых источников данных) либо операции [добавления, обновления и удаления документов](https://msdn.microsoft.com/library/azure/dn798930.aspx). При добавлении документов формируется обращенный индекс.

**Примечание.** Максимальное разрешенное число индексов зависит от ценовой категории. В бесплатной версии службы разрешено до трех индексов. В стандартной версии разрешено использовать до 50 индексов на одну службу поиска. Дополнительные сведения см. в статье с описанием [пределов и ограничений](http://msdn.microsoft.com/library/azure/dn798934.aspx).

**Запрос**

Все запросы к службе отправляются по протоколу HTTPS. Для отправки запроса на **создание индекса** можно использовать метод POST или PUT. Для метода POST в теле запроса передается название индекса вместе с определением его схемы. Для метода PUT имя индекса указывается в составе URL-адреса. Если такого индекса не существует, он будет создан. Если он уже есть, его определение будет обновлено.

Имя индекса передается в нижнем регистре, должно начинаться с буквы или цифры, не должно содержать символов косой черты и точки, а его максимальная длина составляет 127 знаков. Начиная со второго символа имя может содержать буквы, цифры и дефисы (однако последовательности из двух или большего числа дефисов запрещены).

`api-version` является обязательным элементом. Список доступных версий см. в статье об [управлении версиями службы поиска](http://msdn.microsoft.com/library/azure/dn864560.aspx).

**Заголовки запроса**

В списке ниже перечислены обязательные и необязательные заголовки запроса.

* `Content-Type`: обязательный параметр. Для этого заголовка необходимо задать значение `application/json`
* `api-key`: обязательный. Заголовок `api-key` используется для
* проверки подлинности запроса в службе поиска. Это уникальное строковое значение, присваиваемое службе. Запрос на **создание индекса** должен содержать заголовок `api-key` со значением ключа администратора (а не ключа запроса).

Для формирования URL-адреса запроса также понадобится имя службы. Имя и `api-key` можно найти в панели мониторинга службы на портале Azure. Дополнительные сведения о навигации по страницам см. в статье, посвященной [созданию службы поиска на портале](search-create-service-portal.md).

<a name="RequestData"></a>
**Синтаксис текста запроса**

Тело запроса содержит определение схемы со списком полей данных в документах, передаваемых в индекс, типами данных, атрибутами, а также необязательным списком профилей оценки, которые используются для оценки соответствующих критериям поиска документов во время выполнения запроса.

Обратите внимание на то, что в теле запроса POST передается имя индекса.

Индекс может содержать только одно ключевое поле. Оно должно быть строковым. Это поле представляет собой уникальный идентификатор каждого документа, который хранится в индексе.

Индекс состоит из перечисленных ниже основных частей.

* `name`
* `fields` — поля, которые будут передаваться в этот индекс, включая имя, тип данных и свойства, определяющие доступные для каждого поля операции.
* `suggesters` — средства подбора, которые используются для автозавершения и упреждающего ввода запросов.
* `scoringProfiles`— профили оценки, которые используются для настраиваемого ранжирования показателей поиска. Дополнительные сведения см. в статье о [добавлении профилей оценки](https://msdn.microsoft.com/library/azure/dn798928.aspx).
* `analyzers`, `charFilters`, `tokenizers`, `tokenFilters` используются для настройки разбиения документов и запросов на маркеры для индексации и поиска. Дополнительные сведения см. в статье, посвященной [анализу в службе поиска Azure](https://aka.ms//azsanalysis).
* `defaultScoringProfile` — профиль оценки по умолчанию, переопределяющий алгоритмы оценки по умолчанию.
* `corsOptions` —параметры CORS, обеспечивающие возможность отправки запросов к индексу независимо от источника.

Ниже описан синтаксис полезных данных запроса. Далее в этом разделе приведен пример запроса.

    {
      "name": (optional on PUT; required on POST) "name_of_index",
      "fields": [
        {
          "name": "name_of_field",
          "type": "Edm.String | Collection(Edm.String) | Edm.Int32 | Edm.Int64 | Edm.Double | Edm.Boolean | Edm.DateTimeOffset | Edm.GeographyPoint",
          "searchable": true (default where applicable) | false (only Edm.String and Collection(Edm.String) fields can be searchable),
          "filterable": true (default) | false,
          "sortable": true (default where applicable) | false (Collection(Edm.String) fields cannot be sortable),
          "facetable": true (default where applicable) | false (Edm.GeographyPoint fields cannot be facetable),
          "key": true | false (default, only Edm.String fields can be keys),
          "retrievable": true (default) | false,              
          "analyzer": "name of the analyzer used for search and indexing", (only if 'searchAnalyzer' and 'indexAnalyzer' are not set)
          "searchAnalyzer": "name of the search analyzer", (only if 'indexAnalyzer' is set and 'analyzer' is not set)
          "indexAnalyzer": "name of the indexing analyzer" (only if 'searchAnalyzer' is set and 'analyzer' is not set)
        }
      ],
      "suggesters": [
        {
          "name": "name of suggester",
          "searchMode": "analyzingInfixMatching" (other modes may be added in the future),
          "sourceFields": ["field1", "field2", ...]
        }
      ],
      "scoringProfiles": [
        {
          "name": "name of scoring profile",
          "text": (optional, only applies to searchable fields) {
            "weights": {
              "searchable_field_name": relative_weight_value (positive numbers),
              ...
            }
          },
          "functions": (optional) [
            {
              "type": "magnitude | freshness | distance | tag",
              "boost": # (positive number used as multiplier for raw score != 1),
              "fieldName": "...",
              "interpolation": "constant | linear (default) | quadratic | logarithmic",
              "magnitude": {
                "boostingRangeStart": #,
                "boostingRangeEnd": #,
                "constantBoostBeyondRange": true | false (default)
              },
              "freshness": {
                "boostingDuration": "..." (value representing timespan leading to now over which boosting occurs)
              },
              "distance": {
                "referencePointParameter": "...", (parameter to be passed in queries to use as reference location, see "scoringParameter" for syntax details)
                "boostingDistance": # (the distance in kilometers from the reference location where the boosting range ends)
              },
              "tag": {
                "tagsParameter": "..." (parameter to be passed in queries to specify list of tags to compare against target field, see "scoringParameter" for syntax details)
              }
            }
          ],
          "functionAggregation": (optional, applies only when functions are specified)
            "sum (default) | average | minimum | maximum | firstMatching"
        }
      ],
      "analyzers":(optional)[ ... ],
      "charFilters":(optional)[ ... ],
      "tokenizers":(optional)[ ... ],
      "tokenFilters":(optional)[ ... ],
      "defaultScoringProfile": (optional) "...",
      "corsOptions": (optional) {
        "allowedOrigins": ["*"] | ["origin_1", "origin_2", ...],
        "maxAgeInSeconds": (optional) max_age_in_seconds (non-negative integer)
      }
    }

**Атрибуты индекса**

При создании индекса можно задать перечисленные ниже атрибуты. Подробные сведения об оценке и профилях см. в статье о [добавлении профилей оценки](https://msdn.microsoft.com/library/azure/dn798928.aspx).

`name` — задает имя поля.

`type` — задает тип данных поля.

`searchable` — помечает поле как доступное для полнотекстового поиска. Это означает, что во время индексирования оно будет включено в анализ (в частности, для разбиения на слова). Если, например, задать для поля с атрибутом `searchable` значение sunny day (солнечный день), оно будет разделено на элементы sunny и day. В результате эти слова смогут участвовать в полнотекстовом поиске. У полей типа `Edm.String` и `Collection(Edm.String)` по умолчанию установлен флаг `searchable`. Для полей других типов установить атрибут `searchable`нельзя.

* **Примечание.** Поля c атрибутом `searchable` занимают больше места в индексе, так как служба поиска Azure хранит дополнительную (разбитую на элементы) версию значения каждого такого поля для полнотекстового поиска. Если вам нужно сэкономить место в индексе и вы не собираетесь включать поле в поиск, установите для параметра `searchable` значение `false`.

`filterable` — позволяет использовать в запросах `$filter` ссылки на это поле. `filterable` отличается от `searchable` тем, как обрабатываются строки. Для полей типа `Edm.String` и `Collection(Edm.String)` с атрибутом `filterable` не выполняется разбиение на слова, поэтому они могут попасть в результаты поиска только по точному совпадению. Например, если для такого поля задать в параметре `f` значение sunny day, запрос `$filter=f eq 'sunny'` не вернет совпадений, а запрос — `$filter=f eq 'sunny day'` вернет. По умолчанию атрибут `filterable` устанавливается для всех полей.

`sortable` — по умолчанию система сортирует результаты на основе их оценки, однако пользователям часто бывает нужно отсортировать документы по полям. Для полей типа `Collection(Edm.String)` установить атрибут `sortable` нельзя. Для всех остальных полей флаг `sortable` устанавливается по умолчанию.

`facetable` — как правило, используется для представления результатов поиска, в которых указывается количество найденных документов по категориям (например, при поиске цифровых фотоаппаратов можно разделить результаты по производителям, количеству мегапикселей, цене и т. п.). Этот параметр не предназначен для использования с полями типа `Edm.GeographyPoint`. Для всех остальных полей флаг `facetable` устанавливается по умолчанию.

* **Примечание**. Поля типа `Edm.String`, для которых задан атрибут `filterable`, `sortable` или `facetable`, должны иметь длину не больше 32 КБ. Это связано с тем, что такие поля обрабатываются как целые условия поиска, а максимальная длина такого условия в службе поиска Azure составляет 32 КБ. Если в одном строковом поле нужно хранить текст большего размера, необходимо явным образом задать в определении индекса для свойств `filterable`, `sortable` и `facetable` значение `false`.
* **Примечание**. Если для поля не заданы атрибуты с присвоенным значением `true` (`searchable`, `filterable`, `sortable` или `facetable`), такое поле фактически исключается из обращенного индекса. Это могут быть поля, которые не используются в запросах, однако нужны в результатах поиска. Их исключение из индекса позволяет повысить его производительность.

`key` — указывает, что в поле хранятся уникальные идентификаторы документов в индексе. Атрибут `key` должен быть установлен у одного и только у одного поля типа `Edm.String`. Такие ключевые поля можно использовать для запроса документов непосредственно через [API поиска](#LookupAPI).

`retrievable` — определяет, включается ли поле в возвращаемые поиском результаты.  Этот атрибут полезен, когда поле (например, показатель прибыльности) нужно использовать для фильтрации, сортировки или оценки, но оно не должно отображаться конечному пользователю. У полей с установленным свойством `true` for `key` .

`analyzer` — задает имя анализатора, который следует использовать для этого поля во время поиска и индексирования. Список допустимых значений см. [в описании анализаторов](https://msdn.microsoft.com/library/mt605304.aspx). Этот параметр можно использовать только с полями `searchable`, а с `searchAnalyzer` или `indexAnalyzer` его установить нельзя.  Выбрав для поля анализатор, его невозможно изменить.

`searchAnalyzer`: задает имя анализатора, используемого для этого поля во время поиска. Список допустимых значений см. [в описании анализаторов](https://msdn.microsoft.com/library/mt605304.aspx). Этот параметр можно использовать только с полями, для которых задан атрибут `searchable`. Его можно задать вместе с параметром `indexAnalyzer`, но не вместе с параметром `analyzer`. Этот анализатор можно обновить на существующее поле.

`indexAnalyzer`: задает имя анализатора, используемого для этого поля во время индексирования. Список допустимых значений см. [в описании анализаторов](https://msdn.microsoft.com/library/mt605304.aspx). Этот параметр можно использовать только с полями, для которых задан атрибут `searchable`. Его можно задать вместе с параметром `searchAnalyzer`, но не вместе с параметром `analyzer`. Выбрав для поля анализатор, его невозможно изменить.

`suggesters`: список из одного или нескольких полей, которые служат источником при поиске предложений. Дополнительные сведения см. в разделе [Средства подбора](#Suggesters).

`scoringProfiles` — позволяет настроить механизм оценки, с помощью которого можно влиять на относительную позицию элементов в результатах поиска. Профили оценки состоят из взвешенных полей и функций. Дополнительные сведения об атрибутах, которые используются в таких профилях, см. в статье о [добавлении профилей оценки в индекс поиска](https://msdn.microsoft.com/library/azure/dn798928.aspx).

<!-- This is a standalone topic in MSDN -->
<a name="LanguageSupport"></a>
**Поддержка языков**

Поля с поддержкой поиска подвергаются анализу, который чаще всего включает разбиение на слова, нормализацию текста и выделение условий поиска. По умолчанию поля с поддержкой поиска анализируются в службе поиска Azure с помощью [анализатора Apache Lucene Standard](http://lucene.apache.org/core/4_9_0/analyzers-common/index.html), который разбивает текст на элементы согласно правилам [сегментации текста Юникода](http://unicode.org/reports/tr29/). Кроме того, стандартный анализатор преобразует все знаки в нижний регистр. Анализу подвергаются как индексируемые документы, так и условия поиска во время индексирования и обработки запросов.

"Поиск Azure" поддерживает различные языки. Для каждого из них необходим нестандартный анализатор текста, который учитывает особенности соответствующего языка. В службе поиска Azure доступны анализаторы двух типов:

* 35 анализаторов на базе технологии Lucene.
* 50 анализаторов на базе собственной технологии Майкрософт для обработки естественных языков, которая используется в приложениях Office и поисковой системе Bing.

Некоторые разработчики предпочитают более знакомое и простое решение Lucene с открытым исходным кодом. Оно работает быстрее, однако анализаторы Майкрософт обладают расширенными функциями, такими как лемматизация, разбор слов на составные части (на таких языках, как немецкий, датский, голландский, шведский, норвежский, эстонский, финский, венгерский, словацкий) и распознавание сущностей (URL-адреса, адреса электронной почты, даты, числа). Рекомендуем вам сравнить результаты работы анализаторов от Майкрософт и Lucene и выбрать оптимальный для себя вариант.

***Сравнение***

Анализатор Lucene для английского расширяет возможности стандартного анализатора. Он удаляет из слов признаки принадлежности (символы 's в конце), находит основу слов с помощью [стеммера Портера](http://tartarus.org/~martin/PorterStemmer/) и удаляет английские [стоп-слова](http://en.wikipedia.org/wiki/Stop_words).

По сравнению с ним анализатор от Майкрософт вместо парадигматического модуля использует лемматизацию. Это означает, что он гораздо лучше обрабатывает флективные и неправильные словоформы, а также позволяет получить более подходящие результаты поиска (дополнительные сведения см. в модуле 7 [презентации MVA, посвященной службе поиска Azure](http://www.microsoftvirtualacademy.com/training-courses/adding-microsoft-azure-search-to-your-websites-and-apps)).

В зависимости от языка индексирование на базе анализаторов Майкрософт занимает в среднем в два-три раза больше времени, чем с помощью эквивалентных анализаторов Lucene. Время выполнения поискового запроса не должно значительно отличаться от запросов средних размеров.

***Конфигурация***

Для каждого поля в определении индекса можно задать в свойстве `analyzer` имя, определяющее язык и разработчика анализатора. Этот же анализатор будет применяться при индексировании и поиске поля.
Например, в одном индексе могут существовать отдельные поля для описаний гостиницы на английском, французском и испанском языках. Используйте [параметр запроса searchFields](#SearchQueryParameters) , чтобы указать поля для других языков, в которых будет выполнен запрос. Вы можете ознакомиться с примерами запросов, в которых используется свойство `analyzer` , в разделе [Поиск документов](#SearchDocs). 

***Список анализаторов***

Ниже приведен список поддерживаемых языков и названия анализаторов Lucene и Майкрософт.

<table style="font-size:12">
    <tr>
        <th>Язык</th>
        <th>Название анализатора Майкрософт</th>
        <th>Название анализатора Lucene</th>
    </tr>
    <tr>
        <td>Арабский</td>
        <td>ar.microsoft</td>
        <td>ar.lucene</td>        
    </tr>
    <tr>
        <td>Армянский</td>
        <td></td>
        <td>hy.lucene</td>
      </tr>
    <tr>
        <td>Бенгальский</td>
        <td>bn.microsoft</td>
        <td></td>
    </tr>
      <tr>
        <td>Баскский</td>
        <td></td>
        <td>eu.lucene</td>
    </tr>
      <tr>
         <td>Болгарский</td>
        <td>bg.microsoft</td>
        <td>bg.lucene</td>
      </tr>
      <tr>
        <td>Каталанский</td>
        <td>ca.microsoft</td>
        <td>ca.lucene</td>          
      </tr>
    <tr>
        <td>Китайский (упрощенное письмо)</td>
        <td>zh-Hans.microsoft</td>
        <td>zh-Hans.lucene</td>        
    </tr>
    <tr>
        <td>Китайский (традиционное письмо)</td>
        <td>zh-Hant.microsoft</td>
        <td>zh-Hant.lucene</td>        
    <tr>
    <tr>
        <td>Хорватский</td>
        <td>hr.microsoft</td>
        <td/></td>
    </tr>
    <tr>
        <td>Чешский</td>
        <td>cs.microsoft</td>
        <td>cs.lucene</td>        
    </tr>    
    <tr>
        <td>Датский</td>
        <td>da.microsoft</td>
        <td>da.lucene</td>        
    </tr>    
    <tr>
        <td>Нидерландский</td>
        <td>nl.microsoft</td>
        <td>nl.lucene</td>    
    </tr>    
    <tr>
        <td>Английский</td>        
        <td>en.microsoft</td>
        <td>en.lucene</td>        
    </tr>
    <tr>
        <td>Эстонский</td>
        <td>et.microsoft</td>
        <td></td>
    </tr>
    <tr>
        <td>Финский</td>
        <td>fi.microsoft</td>
        <td>fi.lucene</td>        
    </tr>    
    <tr>
        <td>Французский</td>
        <td>fr.microsoft</td>
        <td>fr.lucene</td>        
    </tr>
    <tr>
        <td>Галисийский</td>
        <td></td>
        <td>gl.lucene</td>        
      </tr>
    <tr>
        <td>Немецкий</td>
        <td>de.microsoft</td>
        <td>de.lucene</td>        
    </tr>
    <tr>
        <td>Греческий</td>
        <td>el.microsoft</td>
        <td>el.lucene</td>        
    </tr>
    <tr>
        <td>Гуджарати</td>
        <td>gu.microsoft</td>
        <td></td>
    </tr>
    <tr>
        <td>Иврит</td>
        <td>he.microsoft</td>
        <td></td>
    </tr>
    <tr>
        <td>Хинди</td>
        <td>hi.microsoft</td>
        <td>hi.lucene</td>        
    </tr>
    <tr>
        <td>Венгерский</td>        
        <td>hu.microsoft</td>
        <td>hu.lucene</td>
    </tr>
    <tr>
        <td>Исландский</td>
        <td>is.microsoft</td>
        <td></td>
    </tr>
    <tr>
        <td>Индонезийский (бахаса)</td>
        <td>id.microsoft</td>
        <td>id.lucene</td>        
    </tr>
    <tr>
        <td>Ирландский</td>
        <td></td>
          <td>ga.lucene</td>
    </tr>
    <tr>
        <td>Итальянский</td>
        <td>it.microsoft</td>
        <td>it.lucene</td>        
    </tr>
    <tr>
        <td>Японский</td>
        <td>ja.microsoft</td>
        <td>ja.lucene</td>

    </tr>
    <tr>
        <td>Каннада</td>
        <td>ka.microsoft</td>
        <td></td>
    </tr>
    <tr>
        <td>Корейский</td>
        <td>ko.microsoft</td>
        <td>ko.lucene</td>
    </tr>
    <tr>
        <td>Латышский</td>        
        <td>lv.microsoft</td>
        <td>lv.lucene</td>    
    </tr>
    <tr>
        <td>Литовский</td>
        <td>lt.microsoft</td>
        <td></td>
    </tr>
    <tr>
        <td>Малаялам</td>
        <td>ml.microsoft</td>
        <td></td>
    </tr>
    <tr>
        <td>Малайский (латиница)</td>
        <td>ms.microsoft</td>
        <td></td>
    </tr>
    <tr>
        <td>Маратхи</td>
        <td>mr.microsoft</td>
        <td></td>
    </tr>
    <tr>
        <td>Норвежский</td>
        <td>nb.microsoft</td>
        <td>no.lucene</td>        
    </tr>
      <tr>
        <td>Персидский</td>
        <td></td>
        <td>fa.lucene</td>        
      </tr>
    <tr>
        <td>Польский</td>
        <td>pl.microsoft</td>
        <td>pl.lucene</td>        
    </tr>
    <tr>
        <td>Португальский (Бразилия)</td>
        <td>pt-Br.microsoft</td>
        <td>pt-Br.lucene</td>        
    </tr>
    <tr>
        <td>Португальский (Португалия)</td>
        <td>pt-Pt.microsoft</td>        
        <td>pt-Pt.lucene</td>
    </tr>
    <tr>
        <td>Панджаби</td>
        <td>pa.microsoft</td>
        <td></td>
    </tr>
    <tr>
        <td>Румынский</td>
        <td>ro.microsoft</td>
        <td>ro.lucene</td>
    </tr>
    <tr>
        <td>Русский</td>
        <td>ru.microsoft</td>
        <td>ru.lucene</td>    
    </tr>
    <tr>
        <td>Сербский (кириллица)</td>
        <td>sr-cyrillic.microsoft</td>
        <td></td>
    </tr>
    <tr>
        <td>Сербский (латиница)</td>
        <td>sr-latin.microsoft</td>
        <td></td>
    </tr>
    <tr>
        <td>Словацкий</td>
        <td>sk.microsoft</td>
        <td></td>
    </tr>
    <tr>
        <td>Словенский</td>
        <td>sl.microsoft</td>
        <td></td>
    </tr>
    <tr>
        <td>Испанский</td>
        <td>es.microsoft</td>
        <td>es.lucene</td>
    </tr>
    <tr>
        <td>Шведский</td>
        <td>sv.microsoft</td>
        <td>sv.lucene</td>
    </tr>

    <tr>
        <td>Тамильский</td>
        <td>ta.microsoft</td>
        <td></td>
    </tr>
    <tr>
        <td>Телугу</td>
        <td>te.microsoft</td>
        <td></td>
    </tr>
    <tr>
        <td>Тайский</td>
        <td>th.microsoft</td>
        <td>th.lucene</td>
    </tr>
    <tr>
        <td>Турецкий</td>
        <td>tr.microsoft</td>
        <td>tr.lucene</td>        
    </tr>
    <tr>
        <td>Украинский</td>
        <td>uk.microsoft</td>
        <td></td>
    </tr>
    <tr>
        <td>Урду</td>
        <td>ur.microsoft</td>
        <td></td>
    </tr>
    <tr>
        <td>Вьетнамский</td>
        <td>vi.microsoft</td>
        <td></td>
    </tr>
    <td colspan="3">Кроме того, в службе поиска Azure доступны независимые от языка конфигурации анализаторов.</td>
    <tr>
        <td>Стандартное приведение к ASCII</td>
        <td>standardasciifolding.lucene</td>
        <td>
        <ul>
            <li>Сегментация текста Юникода (стандартный лексический анализатор)</li>
            <li>Фильтр приведения к ASCII: преобразует символы Юникода, которые не относятся к числу первых 127 знаков кодировки ASCII, к их эквивалентам в этой кодировке. Эта функция полезна для удаления диакритических знаков.</li>
        </ul>
        </td>
    </tr>
</table>

Все анализаторы, у которых в названии есть идентификатор <i>lucene</i>, работают на базе [языковых анализаторов Apache Lucene](http://lucene.apache.org/core/4_9_0/analyzers-common/overview-summary.html). Дополнительные сведения о фильтре приведения к ASCII можно найти [здесь](http://lucene.apache.org/core/4_9_0/analyzers-common/org/apache/lucene/analysis/miscellaneous/ASCIIFoldingFilter.html).

**Средства подбора**

`suggester` определяет, какие поля в индексе используются для поддержки автозаполнения поисковых запросов. Как правило, фрагмент запроса передается в [API предложений](#Suggestions), пока пользователь вводит текст, и API возвращает набор предлагаемых фраз. Заданное для индекса средство подбора определяет, какие поля используются для создания условий поиска для опережающего ввода. Информацию о настройке см. в разделе [Средства подбора](#Suggesters).

**Профили оценки**

`scoringProfile` позволяет настроить механизм оценки, с помощью которого можно влиять на относительную позицию элементов в результатах поиска. Профили оценки состоят из взвешенных полей и функций. Чтобы использовать их, необходимо задать профиль по имени в строке запроса.

Профиль оценки по умолчанию вычисляет оценку поиска для каждого элемента в результирующем наборе в фоновом режиме. Можно использовать внутренний профиль оценки без имени. Можно также задать для параметра `defaultScoringProfile` использование пользовательского профиля в качестве профиля по умолчанию, который вызывается всякий раз, когда пользовательский профиль не указан в строке запроса.

Дополнительную информацию см. в статье о [добавлении профилей оценки в индекс поиска (REST API службы поиска Azure)](search-api-scoring-profiles-2015-02-28-preview.md).

**Параметры CORS**

Клиентский код JavaScript не может обращаться к API, так как браузер блокирует все запросы между разными источниками. Чтобы разрешить такие запросы к индексу, необходимо включить CORS (Cross-Origin Resource Sharing — общий доступ к ресурсам независимо от источника), установив атрибут `corsOptions` . Обратите внимание на то, что по соображениям безопасности технологию CORS поддерживают только интерфейсы API запросов. Для технологии CORS можно настроить перечисленные ниже параметры.

* `allowedOrigins` (обязательный): список источников, которым необходимо предоставлять доступ к индексу. Это означает, что любому коду JavaScript из такого источника будет разрешено отправлять запросы к индексу (при условии, что будет указан правильный ключ API). Источники обычно задаются в формате `protocol://fully-qualified-domain-name:port`, хотя значение порта часто опускается. Дополнительные сведения см. в [этой статье](http://go.microsoft.com/fwlink/?LinkId=330822).
  * Чтобы разрешить доступ всем источникам, добавьте в массив `allowedOrigins` единственный элемент: `*`. Напоминаем вам, что **так не рекомендуется делать в рабочих версиях служб поиска**. Однако это может оказаться полезно для целей разработки или отладки.
* `maxAgeInSeconds` (необязательный): с помощью этого значения браузеры определяют длительность (в секундах) кэширования предварительных ответов CORS. Это значение должно быть целой неотрицательной величиной. Чем оно больше, чем выше производительность, однако при этом применение изменений в политике CORS занимает больше времени. Если это значение не задано, длительность по умолчанию составляет 5 минут.

<a name="CreateUpdateIndexExample"></a>
**Пример тела запроса**

    {
      "name": "hotels",  
      "fields": [
        {"name": "hotelId", "type": "Edm.String", "key": true, "searchable": false},
        {"name": "baseRate", "type": "Edm.Double"},
        {"name": "description", "type": "Edm.String", "filterable": false, "sortable": false, "facetable": false},
        {"name": "description_fr", "type": "Edm.String", "filterable": false, "sortable": false, "facetable": false, "analyzer": "fr.lucene"},
        {"name": "hotelName", "type": "Edm.String"},
        {"name": "category", "type": "Edm.String"},
        {"name": "tags", "type": "Collection(Edm.String)"},
        {"name": "parkingIncluded", "type": "Edm.Boolean"},
        {"name": "smokingAllowed", "type": "Edm.Boolean"},
        {"name": "lastRenovationDate", "type": "Edm.DateTimeOffset"},
        {"name": "rating", "type": "Edm.Int32"},
        {"name": "location", "type": "Edm.GeographyPoint"}
      ],
      "suggesters": [
        {
          "name": "sg",
          "searchMode": "analyzingInfixMatching",
          "sourceFields": ["hotelName"]
        }
      ]
    }

**Ответ**

Для успешного запроса: "201 — Создан ресурс".

По умолчанию тело ответа содержит объект JSON с определением созданного индекса. Если заголовок `Prefer` запроса содержит значение `return=minimal`, тело ответа будет пустым, а код состояния вместо значения «201 — Создан ресурс» принимает значение «204 — Нет содержимого». При этом не играет роли, какой запрос (PUT или POST) использовался для создания индекса.

**Примечания**

В настоящее время функции обновления схемы индекса поддерживаются в ограниченном объеме. Обновления схемы, которые требуют переиндексирования (например, изменение типов полей), пока не поддерживаются. Хотя изменять и удалять существующие поля пока нельзя, вы можете в любой момент добавлять в существующий индекс новые поля. При добавлении нового поля для всех существующих в индексе документов ему автоматически присваивается значение Null. Дополнительное место в хранилище при этом не потребуется до тех пор, пока в индекс не будут добавлены новые документы.

<a name="Suggesters"></a>

## <a name="suggesters"></a>Средства подбора
Функция подбора в службе поиска Azure представляет собой функцию автозаполнения или опережающего ввода для поисковых запросов, которая предоставляет список потенциальных условий поиска в ответ на ввод в поле фрагмента запроса. Вы, наверняка, замечали предложения запроса при использовании коммерческих поисковых систем в Интернете. Например, если ввести в Bing ".NET", появится список условий для .NET 4.5, .NET Framework 3.5 и т. д. При использовании REST API службы поиска для реализации предложений в пользовательском приложении Поиска Azure необходимо выполнить следующие действия.

* Включить функцию подбора, добавив конструкцию **suggester** в индекс, указав имя, режим поиска и список полей, для которых будет вызываться опережающий ввод. Например, если указать в качестве исходного поля "Название города", в результате ввода фрагмента запроса "Вла" будут выведены предложения запроса "Владивосток", "Владикавказ" и "Владимир" (все они являются фактическими названиями городов).
* Вызвать функцию подбора путем вызова [API предложений](#Suggestions) в коде приложения. Как правило, фрагмент запроса передается в службу, пока пользователь вводит текст запроса, и API возвращает набор предлагаемых фраз.

В этой статье описывается настройка **средства подбора**. Дополнительную информацию об использовании средств подбора см. в разделе [Предложения](#Suggestions).

**Использование**

`Suggesters` создаются в индексе и лучше всего работают при поиске предложений по определенным документам, а не по произвольным условиям поиска и фразам. Они хорошо обрабатывают такие поля, как заголовки, имена и другие относительно короткие фразы, идентифицирующие документ. Менее эффективно выполняется поиск по таким полям с множеством повторяющихся элементов, как категории и теги, а также по очень длинным полям, таким как описания и комментарии.

В определении индекса в коллекцию `suggesters` можно добавить одно средство подбора. Для него задаются перечисленные ниже свойства.

* `name`: имя средства подбора. Оно используется при обращении к API `suggest` .
* `searchMode`: методика подбора совпадающих фраз. В настоящее время поддерживается только режим `analyzingInfixMatching`, в рамках которого выполняется гибкий поиск совпадений в начале и середине фраз.
* `sourceFields`: список из одного или нескольких полей, которые служат источником при поиске предложений. Источниками могут быть только поля типов `Edm.String` и `Collection(Edm.String)`. Можно использовать только поля, для которых не задан настраиваемый языковой анализатор.

**Пример средства подбора**

Средство подбора — это часть индекса. Коллекция текущей версии `suggesters` может содержать только одно средство подбора, наряду с коллекцией полей и `scoringProfiles`.

        {
          "name": "hotels",
          "fields": [
             . . .
           ],
          "suggesters": [
            {
            "name": "sg",
            "searchMode": "analyzingInfixMatching",
            "sourceFields: ["hotelName", "category"]
            }
          ],
          "scoringProfiles": [
             . . .
          ]
        }

> [!NOTE]
> Для пользователей общедоступной предварительной версии Поиска Azure: `suggesters` заменяют устаревшее логическое свойство (`"suggestions": false`), которое поддерживало только префиксный поиск предложений для коротких (от 3 до 25 знаков) строк. Вместо него введены `suggesters`, которые поддерживают инфиксный поиск совпадений, позволяющий находить соответствия как в начале, так и в середине текста, а также более устойчивый к ошибкам в поисковых запросах. Начиная с общедоступной версии, данная реализация API предложений является единственной. Свойство `suggestions`, которое появилось в версии `api-version=2014-07-31-Preview`, продолжает в ней работать, но не поддерживается в `2015-02-28` и более поздних версиях службы поиска Azure.
> 
> 

<a name="UpdateIndex"></a>

## <a name="update-index"></a>Обновление индекса
Обновить существующий индекс в службе поиска Azure можно с помощью HTTP-запроса PUT. В рамках обновления можно добавлять новые поля в существующие схемы, менять параметры CORS, а также вносить изменения в профили оценки. Дополнительную информацию см. в статье о [добавлении профилей оценки](https://msdn.microsoft.com/library/azure/dn798928.aspx). Указать имя обновляемого индекса можно в URI запроса:

    PUT https://[search service url]/indexes/[index name]?api-version=[api-version]
    Content-Type: application/json
    api-key: [admin key]

**Внимание!** Для обновления схемы можно использовать только операции, которые не ведут к перестройке индекса поиска. Обновления схемы, которые требуют переиндексирования (например, изменение типов полей), пока не поддерживаются. Новые поля можно добавлять в любой момент, однако изменять и удалять существующие поля пока нельзя. То же относится и к `suggesters`. Добавить в `suggesters` новое поле можно при добавлении этого поля в индекс, однако удалять из `suggesters` поля или добавлять существующие поля нельзя.

При добавлении в индекс нового поля для всех существующих в индексе документов ему автоматически присваивается значение Null. Дополнительное место в хранилище при этом не потребуется до тех пор, пока в индекс не будут добавлены новые документы.

**Запрос**

Все запросы к службе отправляются по протоколу HTTPS. Для отправки запроса на **обновление индекса** можно использовать HTTP-метод PUT. Для метода PUT имя индекса указывается в составе URL-адреса. Если такого индекса не существует, он будет создан. Если он уже есть, его определение будет обновлено.

Имя индекса передается в нижнем регистре, должно начинаться с буквы или цифры, не должно содержать символов косой черты и точки, а его максимальная длина составляет 127 знаков. Начиная со второго символа имя может содержать буквы, цифры и дефисы (однако последовательности из двух или большего числа дефисов запрещены).

`api-version=[string]` (обязательный). Предварительная версия — `api-version=2015-02-28-Preview`. Подробные сведения, в том числе о других версиях, см. в статье об [управлении версиями службы поиска](http://msdn.microsoft.com/library/azure/dn864560.aspx).

**Заголовки запроса**

В списке ниже перечислены обязательные и необязательные заголовки запроса.

* `Content-Type`: обязательный параметр. Для этого заголовка необходимо задать значение `application/json`
* `api-key`: обязательный параметр. Заголовок `api-key` используется для проверки подлинности запроса в службе поиска. Это уникальное строковое значение, присваиваемое службе. Запрос на **обновление индекса** должен содержать заголовок `api-key` со значением ключа администратора (а не ключа запроса).

Для формирования URL-адреса запроса также понадобится имя службы. Имя и `api-key` можно найти в панели мониторинга службы на портале Azure. Дополнительные сведения о навигации по страницам см. в статье, посвященной [созданию службы поиска на портале](search-create-service-portal.md).

**Синтаксис тела запроса**

При обновлении существующего индекса тело должно содержать исходное определение схемы и новые поля, которые требуется добавить, а также измененные профили оценки, средства подбора и параметры CORS (при их наличии). Если вносить изменения в профили оценки и параметры CORS не требуется, необходимо указать исходные профили и параметры, с которыми был создан индекс. Как правило, рекомендуется извлечь определение индекса с помощью запроса GET, изменить его, а затем обновить с помощью метода PUT.

Для удобства здесь приведен синтаксис схемы для создания индекса. Дополнительные сведения см. в разделе [Создание индекса](#CreateIndex).

    {
      "name": (optional) "name_of_index",
      "fields": [
        {
          "name": "name_of_field",
          "type": "Edm.String | Collection(Edm.String) | Edm.Int32 | Edm.Int64 | Edm.Double | Edm.Boolean | Edm.DateTimeOffset | Edm.GeographyPoint",
          "searchable": true (default where applicable) | false (only Edm.String and Collection(Edm.String) fields can be searchable),
          "filterable": true (default) | false,
          "sortable": true (default where applicable) | false (Collection(Edm.String) fields cannot be sortable),
          "facetable": true (default where applicable) | false (Edm.GeographyPoint fields cannot be facetable),
          "key": true | false (default, only Edm.String fields can be keys),
          "retrievable": true (default) | false, 
          "analyzer": "name of the analyzer used for search and indexing", (only if 'searchAnalyzer' and 'indexAnalyzer' are not set)
          "searchAnalyzer": "name of the search analyzer", (only if 'indexAnalyzer' is set and 'analyzer' is not set)
          "indexAnalyzer": "name of the indexing analyzer" (only if 'searchAnalyzer' is set and 'analyzer' is not set)
        }
      ],
      "suggesters": [
        {
          "name": "name of suggester",
          "searchMode": "analyzingInfixMatching" (other modes may be added in the future),
          "sourceFields": ["field1", "field2", ...]
        }
      ],
      "scoringProfiles": [
        {
          "name": "name of scoring profile",
          "text": (optional, only applies to searchable fields) {
            "weights": {
              "searchable_field_name": relative_weight_value (positive numbers),
              ...
            }
          },
          "functions": (optional) [
            {
              "type": "magnitude | freshness | distance | tag",
              "boost": # (positive number used as multiplier for raw score != 1),
              "fieldName": "...",
              "interpolation": "constant | linear (default) | quadratic | logarithmic",
              "magnitude": {
                "boostingRangeStart": #,
                "boostingRangeEnd": #,
                "constantBoostBeyondRange": true | false (default)
              },
              "freshness": {
                "boostingDuration": "..." (value representing timespan leading to now over which boosting occurs)
              },
              "distance": {
                "referencePointParameter": "...", (parameter to be passed in queries to use as reference location, see "scoringParameter" for syntax details)
                "boostingDistance": # (the distance in kilometers from the reference location where the boosting range ends)
              },
              "tag": {
                "tagsParameter": "..." (parameter to be passed in queries to specify list of tags to compare against target field, see "scoringParameter" for syntax details)
              }
            }
          ],
          "functionAggregation": (optional, applies only when functions are specified)
            "sum (default) | average | minimum | maximum | firstMatching"
        }
      ],
      "analyzers":(optional)[ ... ],
      "charFilters":(optional)[ ... ],
      "tokenizers":(optional)[ ... ],
      "tokenFilters":(optional)[ ... ],
      "defaultScoringProfile": (optional) "...",
      "corsOptions": (optional) {
        "allowedOrigins": ["*"] | ["origin_1", "origin_2", ...],
        "maxAgeInSeconds": (optional) max_age_in_seconds (non-negative integer)
      }
    }


**Ответ**

Для успешного запроса: "204 — Нет содержимого".

По умолчанию тело ответа пустое. Однако если заголовок `Prefer` запроса имеет значение `return=representation`, тело ответа содержит объект JSON с определением обновленного индекса. В данном случае код состояния после успешного выполнения операции — "200 — ОК".

**Обновление определения индекса с пользовательскими анализаторами**

После определения анализатора, создателя маркеров, фильтра маркеров или фильтра знаков его нельзя изменить. Добавить новые определения в существующий индекс можно только в том случае, если в запросе на обновление индекса для флага `allowIndexDowntime` установлено значение true. 

`PUT https://[search service name].search.windows.net/indexes/[index name]?api-version=[api-version]&allowIndexDowntime=true`

Обратите внимание, что эта операция переведет индекс в автономный режим на несколько секунд, что приведет к сбоям при выполнении индексирования и запросов. После обновления индекса его производительность и доступность для записи может быть снижена на несколько минут или дольше, если индекс очень большой.

<a name="ListIndexes"></a>

## <a name="list-indexes"></a>Получение списка индексов
Операция **получения списка индексов** возвращает список индексов, которые в настоящий момент есть в службе поиска Azure.

    GET https://[service name].search.windows.net/indexes?api-version=[api-version]
    api-key: [admin key]

**Запрос**

Все запросы к службе отправляются по протоколу HTTPS. Для отправки запроса на **получение списка индексов** можно использовать метод GET.

`api-version=[string]` (обязательный). Предварительная версия — `api-version=2015-02-28-Preview`. Подробные сведения, в том числе о других версиях, см. в статье об [управлении версиями службы поиска](http://msdn.microsoft.com/library/azure/dn864560.aspx).

**Заголовки запроса**

В списке ниже перечислены обязательные и необязательные заголовки запроса.

* `api-key`: обязательный. Заголовок `api-key` используется для проверки подлинности запроса в службе поиска. Это уникальное строковое значение, присваиваемое службе. Запрос на **получение списка индексов** должен содержать заголовок `api-key` со значением ключа администратора (а не ключа запроса).

Для формирования URL-адреса запроса также понадобится имя службы. Имя и `api-key` можно найти в панели мониторинга службы на портале Azure. Дополнительные сведения о навигации по страницам см. в статье, посвященной [созданию службы поиска на портале](search-create-service-portal.md).

**Тело запроса**

Отсутствует.

**Ответ**

Код состояния: в качестве успешного ответа возвращается код "200 — ОК".

Вот пример тела запроса:

    {
      "value": [
        {
          "name": "Books",
          "fields": [
            {"name": "ISBN", ...},
            ...
          ]
        },
        {
          "name": "Games",
          ...
        },
        ...
      ]
    }

Обратите внимание на то, что в ответе можно отфильтровать нужные свойства. Например, если необходим только список имен индексов, задайте параметр запроса OData `$select` :

    GET /indexes?api-version=2015-02-28-Preview&$select=name

В этом случае ответ из приведенного выше примера будет выглядеть так:

    {
      "value": [
        {"name": "Books"},
        {"name": "Games"},
        ...
      ]
    }

Это удобный способ сократить нагрузку на пропускную способность, если в службе поиска много индексов.

<a name="GetIndex"></a>

## <a name="get-index"></a>Получение индекса
С помощью операции **получения индекса** можно извлечь определение индекса из службы поиска Azure.

    GET https://[service name].search.windows.net/indexes/[index name]?api-version=[api-version]
    api-key: [admin key]

**Запрос**

Запросы к службе отправляются по протоколу HTTPS. Для отправки запроса на **получение индекса** можно использовать метод GET.

Параметр [index name] в URI запроса указывает, какой именно индекс требуется извлечь из коллекции.

`api-version=[string]` (обязательный). Предварительная версия — `api-version=2015-02-28-Preview`. Подробные сведения, в том числе о других версиях, см. в статье об [управлении версиями службы поиска](http://msdn.microsoft.com/library/azure/dn864560.aspx).

**Заголовки запроса**

В списке ниже перечислены обязательные и необязательные заголовки запроса.

* `api-key`: заголовок `api-key` используется для проверки подлинности запроса в службе поиска. Это уникальное строковое значение, присваиваемое службе. Запрос на **получение индекса** должен содержать заголовок `api-key` со значением ключа администратора (а не ключа запроса).

Для формирования URL-адреса запроса также понадобится имя службы. Имя и `api-key` можно найти в панели мониторинга службы на портале Azure. Дополнительные сведения о навигации по страницам см. в статье, посвященной [созданию службы поиска на портале](search-create-service-portal.md).

**Тело запроса**

Отсутствует.

**Ответ**

Код состояния: в качестве успешного ответа возвращается код "200 — ОК".

Пример полезных данных запроса см. в образце объекта JSON в разделе [Создание индекса](#CreateUpdateIndexExample).

<a name="DeleteIndex"></a>

## <a name="delete-index"></a>Удаление индекса
Операция **удаления индекса** удаляет из службы поиска Azure индекс и связанные с ним документы. Имя индекса можно найти в панели мониторинга службы на портале Azure или получить с помощью вызова API. Более подробные сведения см. в разделе [Получение списка индексов](#ListIndexes).

    DELETE https://[service name].search.windows.net/indexes/[index name]?api-version=[api-version]
    api-key: [admin key]

**Запрос**

Запросы к службе отправляются по протоколу HTTPS. Для отправки запроса на **удаление индекса** можно использовать метод DELETE.

Параметр [index name] в URI запроса указывает, какой именно индекс требуется удалить из коллекции.

`api-version=[string]` (обязательный). Предварительная версия — `api-version=2015-02-28-Preview`. Подробные сведения, в том числе о других версиях, см. в статье об [управлении версиями службы поиска](http://msdn.microsoft.com/library/azure/dn864560.aspx).

**Заголовки запроса**

В списке ниже перечислены обязательные и необязательные заголовки запроса.

* `api-key`: обязательный. Заголовок `api-key` используется для проверки подлинности запроса в службе поиска. Это строковое значение, уникальное для URL службы. Запрос на **удаление индекса** должен содержать заголовок `api-key` со значением ключа администратора (а не ключа запроса).

Для формирования URL-адреса запроса также понадобится имя службы. Имя и `api-key` можно найти в панели мониторинга службы на портале Azure. Дополнительные сведения о навигации по страницам см. в статье, посвященной [созданию службы поиска на портале](search-create-service-portal.md).

**Тело запроса**

Отсутствует.

**Ответ**

Код состояния: в качестве успешного ответа возвращается код "204 — Нет содержимого".

<a name="GetIndexStats"></a>

## <a name="get-index-statistics"></a>Получение статистических данных индекса
Операция **получения статистических данных индекса** возвращает из службы поиска Azure количество документов для текущего индекса, а также сведения об используемом в хранилище месте.

    GET https://[service name].search.windows.net/indexes/[index name]/stats?api-version=[api-version]
    api-key: [admin key]

> [!NOTE]
> Статистика по количеству документов и размеру хранилища собирается каждые несколько минут, а не в режиме реального времени. Поэтому статистика, возвращаемая этим API, может не отражать изменения, внесенные последними операциями индексирования.
> 
> 

**Запрос**

Все запросы к службе отправляются по протоколу HTTPS. Для отправки запроса на **получение статистических данных индекса** можно использовать метод GET.

Параметр [index name] в URI запроса указывает службе, для какого именно индекса требуется вернуть статистические данные.

`api-version=[string]` (обязательный). Предварительная версия — `api-version=2015-02-28-Preview`. Подробные сведения, в том числе о других версиях, см. в статье об [управлении версиями службы поиска](http://msdn.microsoft.com/library/azure/dn864560.aspx).

**Заголовки запроса**

В списке ниже перечислены обязательные и необязательные заголовки запроса.

* `api-key`: заголовок `api-key` используется для проверки подлинности запроса в службе поиска. Это уникальное строковое значение, присваиваемое службе. Запрос на **получение статистических данных индекса** должен содержать заголовок `api-key` со значением ключа администратора (а не ключа запроса).

Для формирования URL-адреса запроса также понадобится имя службы. Имя и `api-key` можно найти в панели мониторинга службы на портале Azure. Дополнительные сведения о навигации по страницам см. в статье, посвященной [созданию службы поиска на портале](search-create-service-portal.md).

**Тело запроса**

Отсутствует.

**Ответ**

Код состояния: в качестве успешного ответа возвращается код "200 — ОК".

Тело запроса имеет следующий формат:

    {
      "documentCount": number,
      "storageSize": number (size of the index in bytes)
    }

<a name="TestAnalyzer"></a>

## <a name="test-analyzer"></a>Анализатор теста
**API анализа** показывает, как анализатор разбивает текст на маркеры.

    POST https://[service name].search.windows.net/indexes/[index name]/analyze?api-version=[api-version]
    Content-Type: application/json
    api-key: [admin key]

**Запрос**

Все запросы к службе отправляются по протоколу HTTPS. Для формирования запроса к **API анализа** можно использовать метод POST.

`api-version=[string]` (обязательный). Предварительная версия — `api-version=2015-02-28-Preview`. Подробные сведения, в том числе о других версиях, см. в статье об [управлении версиями службы поиска](http://msdn.microsoft.com/library/azure/dn864560.aspx).

**Заголовки запроса**

В списке ниже перечислены обязательные и необязательные заголовки запроса.

* `api-key`: заголовок `api-key` используется для проверки подлинности запроса в службе поиска. Это уникальное строковое значение, присваиваемое службе. Запрос к **API анализа** должен содержать заголовок `api-key` со значением ключа администратора (а не ключа запроса).

Для формирования URL-адреса запроса также понадобятся имя индекса и имя службы. Имя и `api-key` можно найти в панели мониторинга службы на портале Azure. Дополнительные сведения о навигации по страницам см. в статье, посвященной [созданию службы поиска на портале](search-create-service-portal.md).

**Тело запроса**

    {
      "text": "Text to analyze",
      "analyzer": "analyzer_name"
    }

или

    {
      "text": "Text to analyze",
      "tokenizer": "tokenizer_name",
      "tokenFilters": (optional) [ "token_filter_name" ],
      "charFilters": (optional) [ "char_filter_name" ]
    }

`analyzer_name`, `tokenizer_name`, `token_filter_name` и `char_filter_name` должны быть допустимыми именами предварительно определенных или пользовательских анализаторов, создателей маркеров, фильтров маркеров и фильтров знаков для индекса. Чтобы больше узнать о процессе лексического анализа, ознакомьтесь с разделом [Лингвистический анализ с помощью анализаторов клиента в службе поиска Azure](https://aka.ms/azsanalysis).

**Ответ**

Код состояния: в качестве успешного ответа возвращается код "200 — ОК".

Тело запроса имеет следующий формат:

    {
      "tokens": [
        {
          "token": string (token),
          "startOffset": number (index of the first character of the token),
          "endOffset": number (index of the last character of the token),
          "position": number (position of the token in the input text)
        },
        ...
      ]
    }

**Пример для API анализа**

**Запрос**

    {
      "text": "Text to analyze",
      "analyzer": "standard"
    }

**Ответ**

    {
      "tokens": [
        {
          "token": "text",
          "startOffset": 0,
          "endOffset": 4,
          "position": 0
        },
        {
          "token": "to",
          "startOffset": 5,
          "endOffset": 7,
          "position": 1
        },
        {
          "token": "analyze",
          "startOffset": 8,
          "endOffset": 15,
          "position": 2
        }
      ]
    }

- - -
<a name="DocOps"></a>

## <a name="document-operations"></a>Операции с документами
В службе поиска Azure индекс хранится в облаке и заполняется с помощью документов JSON, которые добавляются в службу. Добавленные документы составляют весь объем данных, по которым производится поиск. Документы содержат поля, некоторые из которых разбиваются на условия поиска при добавлении. Сегмент `/docs` URL-адреса в API Поиска Azure представляет коллекцию документов в индексе. Все операции с этой коллекцией (добавление, объединение, удаление документов и запросы к ним) выполняются в контексте одного индекса, поэтому все URL-адреса для них всегда начинаются со строки `/indexes/[index name]/docs` , содержащей имя соответствующего индекса.

Код вашего приложения должен создавать документы JSON для отправки в службу поиска Azure. Также, если источником данных является база данных SQL Azure или Azure Cosmos DB, можно использовать для загрузки документов [индексатор](https://msdn.microsoft.com/library/dn946891.aspx). Как правило, индексы заполняются из одного указанного набора данных.

Рекомендуется создавать по одному документу для каждого объекта, по которым будет осуществляться поиск. В приложении для видеопроката можно создать по одному документу для каждого фильма, в приложении для интернет-магазина — по документу для каждого номера SKU, в приложении для электронного обучения — по одному документу для каждого курса, в фирме, которая занимается научными исследованиями, — по документу для каждой научной работы из архива и т. д.

Документы состоят из одного или нескольких полей. Поля могут содержать текст, который разбит службой поиска Azure на условия поиска, а также неразбитые и нетекстовые значения, которые можно использовать в фильтрах и профилях оценки. Имена, типы данных и поддерживаемые для поля функции поиска определяются в схеме индекса. Одно из полей в каждой схеме должно содержать идентификаторы, и у каждого документа в таком поле должно быть значение, уникальным образом идентифицирующее этот документ в индексе. Все прочие поля документа являются необязательными и заполняются значениями Null, если они не указаны явным образом. Обратите внимание на то, что значения Null не занимают места в индексе поиска.

Перед добавлением документов необходимо создать индекс в службе. Подробные сведения о выполнении этого первого этапа см. в разделе [Создание индекса](#CreateIndex).

<a name="AddOrUpdateDocuments"></a>

## <a name="add-update-or-delete-documents"></a>Добавления, обновления и удаления документов
Для добавления, объединения, объединения/добавления и удаления документов в определенном индексе используются HTTP-запросы POST. Для добавления большого количества документов рекомендуется использовать пакетные запросы (до 1000 документов или ок. 16 МБ на пакет).

    POST https://[service name].search.windows.net/indexes/[index name]/docs/index?api-version=[api-version]
    Content-Type: application/json
    api-key: [admin key]

**Запрос**

Все запросы к службе отправляются по протоколу HTTPS. Для добавления, объединения, объединения/добавления и удаления документов в определенном индексе используются HTTP-запросы POST.

URI запроса содержит параметр [index name], который указывает, в какой именно индекс отправляются документы. За один раз можно отправить документы только в один индекс.

`api-version=[string]` (обязательный). Предварительная версия — `api-version=2015-02-28-Preview`. Подробные сведения, в том числе о других версиях, см. в статье об [управлении версиями службы поиска](http://msdn.microsoft.com/library/azure/dn864560.aspx).

**Заголовки запроса**

В списке ниже перечислены обязательные и необязательные заголовки запроса.

* `Content-Type`: обязательный параметр. Для этого заголовка необходимо задать значение `application/json`
* `api-key`: обязательный параметр. Заголовок `api-key` используется для проверки подлинности запроса в службе поиска. Это уникальное строковое значение, присваиваемое службе. Запрос на **добавление документов** должен содержать заголовок `api-key` со значением ключа администратора (а не ключа запроса).

Для формирования URL-адреса запроса также понадобится имя службы. Имя и `api-key` можно найти в панели мониторинга службы на портале Azure. Дополнительные сведения о навигации по страницам см. в статье, посвященной [созданию службы поиска на портале](search-create-service-portal.md).

**Тело запроса**

Тело запроса содержит один или несколько индексируемых документов. Документы идентифицируются уникальным ключом. С каждым документом связывается действие: добавить, объединить, объединить или добавить либо удалить. Запросы на добавление должны содержать данные документа в виде набора пар "ключ/значение".

    {
      "value": [
        {
          "@search.action": "upload (default) | merge | mergeOrUpload | delete",
          "key_field_name": "unique_key_of_document", (key/value pair for key field from index schema)
          "field_name": field_value (key/value pairs matching index schema)
            ...
        },
        ...
      ]
    }

> [!NOTE]
> Ключи документа могут содержать только буквы, цифры, дефисы ("–"), знак подчеркивания ("_") и знак равенства ("="). Дополнительные сведения см. в разделе [Правила именования](https://msdn.microsoft.com/library/azure/dn857353.aspx).
> 
> 

**Действия с документами**

* `upload`: операция добавления аналогична операции upsert, которая добавляет документ, если он новый, и обновляет либо заменяет его, если он уже существует. Обратите внимание на то, что при обновлении все поля заменяются.
* `merge`: операция объединения обновляет существующий документ с использованием указанных полей. Если документ не существует, объединение возвращает ошибку. Поля, указанные в запросе на объединение, заменяют собой существующие поля документа. Это относится и к полям типа `Collection(Edm.String)`. Например, если документ содержит поле tags со значением `["budget"]` и вы выполняете запрос на объединение со значением `["economy", "pool"]` для поля tags, после его обработки оно примет значение `["economy", "pool"]`, а **не** `["budget", "economy", "pool"]`.
* `mergeOrUpload`: работает аналогично операции `merge`, если документ с указанным значением ключа уже существует в индексе. Если его нет, эта операция выполняется так же, как и операция `upload` с новым документом.
* `delete`: операция удаления указанного документа из индекса. Обратите внимание, что все поля, указанные в операции `delete` , которые отличны от ключевого поля, будут игнорироваться. Чтобы удалить из документа определенное поле, воспользуйтесь операцией `merge`, явным образом задав для требуемого поля значение `null`.

**Ответ**

Код состояния: при успешном выполнении возвращается код "200 — ОК", указывающий на то, что все элементы проиндексированы. На этот код указывает свойство `status` со значением true для всех элементов, а также значение свойства `statusCode`, равное 201 (для недавно переданных документов) или 200 (для объединенных или удаленных документов).

    {
      "value": [
        {
          "key": "unique_key_of_new_document",
          "status": true,
          "errorMessage": null,
          "statusCode": 201
        },
        {
          "key": "unique_key_of_merged_document",
          "status": true,
          "errorMessage": null,
          "statusCode": 200
        },
        {
          "key": "unique_key_of_deleted_document",
          "status": true,
          "errorMessage": null,
          "statusCode": 200
        }
      ]
    }  

Код состояния 207 (множественное состояние) возвращается, если хотя бы один элемент не удалось проиндексировать. Для элементов, которые не были проиндексированы, значение `status` равно false. Свойства `errorMessage` и `statusCode` содержат причину ошибки индексирования.

    {
      "value": [
        {
          "key": "unique_key_of_document_1",
          "status": false,
          "errorMessage": "The search service is too busy to process this document. Please try again later.",
          "statusCode": 503
        },
        {
          "key": "unique_key_of_document_2",
          "status": false,
          "errorMessage": "Document not found.",
          "statusCode": 404
        },
        {
          "key": "unique_key_of_document_3",
          "status": false,
          "errorMessage": "Index is temporarily unavailable because it was updated with the 'allowIndexDowntime' flag set to 'true'. Please try again later.",
          "statusCode": 422
        }
      ]
    }  

В следующей таблице описаны различные коды состояния документов, которые могут быть возвращены в ответе. Обратите внимание, что некоторые коды указывают на проблемы с самим запросом, а другие — на временные ошибки. Во втором случае нужно повторить попытку подключения через некоторое время.

<table style="font-size:12">
    <tr>
        <th>Код состояния</th>
        <th>Значение</th>
        <th>Возможность повторной попытки</th>
        <th>Примечания</th>
    </tr>
    <tr>
        <td>200</td>
        <td>Документ был успешно изменен или удален.</td>
        <td>Недоступно</td>
        <td>Операции удаления являются <a href="https://en.wikipedia.org/wiki/Idempotence">идемпотентными</a>. То есть, даже если ключ документа не существует в индексе, при попытке операции удаления с этим ключом возвращается код состояния 200.</td>
    </tr>
    <tr>
        <td>201</td>
        <td>Документ создан.</td>
        <td>Недоступно</td>
        <td></td>
    </tr>
    <tr>
        <td>400</td>
        <td>Ошибка в документе, препятствующая индексированию.</td>
        <td>Нет</td>
        <td>Подробное описание проблем с документом содержится в сообщении об ошибке в ответе.</td>
    </tr>
    <tr>
        <td>404</td>
        <td>Документ нельзя объединить, так как указанного ключа нет в индексе.</td>
        <td>Нет</td>
        <td>Эта ошибка не возникает при передаче файлов, так как в этом случае создаются новые документы. Не возникает она и при удалении, так как такие операции являются <a href="https://en.wikipedia.org/wiki/Idempotence">идемпотентными</a>.</td>
    </tr>
    <tr>
        <td>409</td>
        <td>Обнаружен конфликт версий при попытке индексирования документа.</td>
        <td>Да</td>
        <td>Это может произойти при нескольких одновременных попытках индексирования одного документа.</td>
    </tr>
    <tr>
        <td>422</td>
        <td>Индекс временно недоступен, так как для флага allowIndexDowntime было установлено значение true.</td>
        <td>Да</td>
        <td></td>
    </tr>
    <tr>
        <td>503</td>
        <td>Служба поиска временно недоступна, возможно, из-за высокой нагрузки.</td>
        <td>Да</td>
        <td>Следует подождать, прежде чем предпринимать повторную попытку. В противном случае вы можете только увеличить время недоступности службы.</td>
    </tr>
</table> 

**Примечание.**Если клиент часто получает ответ с кодом 207, это может быть связано с повышенной нагрузкой на систему. Чтобы выяснить, так ли это, проверьте, не имеет ли свойство `statusCode` значение 503. Если это так, рекомендуется воспользоваться ***запросами регулирования индексирования***. В противном случае если поток запросов на индексирование не уменьшится, система может начать отклонять их все с кодом ошибки 503.

Код состояния: если превышена квота на количество документов в индексе, система возвращает код ошибки 429. В этом случае нужно создать новый индекс или повысить предельную емкость.

**Пример**

    {
      "value": [
        {
          "@search.action": "upload",
          "hotelId": "1",
          "baseRate": 199.0,
          "description": "Best hotel in town",
          "description_fr": "Meilleur hôtel en ville",
          "hotelName": "Fancy Stay",
          "category": "Luxury",
          "tags": ["pool", "view", "wifi", "concierge"],
          "parkingIncluded": false,
          "smokingAllowed": false,
          "lastRenovationDate": "2010-06-27T00:00:00Z",
          "rating": 5,
          "location": { "type": "Point", "coordinates": [-122.131577, 47.678581] }
        },
        {
          "@search.action": "upload",
          "hotelId": "2",
          "baseRate": 79.99,
          "description": "Cheapest hotel in town",
          "description_fr": "Hôtel le moins cher en ville",
          "hotelName": "Roach Motel",
          "category": "Budget",
          "tags": ["motel", "budget"],
          "parkingIncluded": true,
          "smokingAllowed": true,
          "lastRenovationDate": "1982-04-28T00:00:00Z",
          "rating": 1,
          "location": { "type": "Point", "coordinates": [-122.131577, 49.678581] }
        },
        {
          "@search.action": "merge",
          "hotelId": "3",
          "baseRate": 279.99,
          "description": "Surprisingly expensive",
          "lastRenovationDate": null
        },
        {
          "@search.action": "delete",
          "hotelId": "4"
        }
      ]
    }
- - -
<a name="SearchDocs"></a>

## <a name="search-documents"></a>Поиск документов
Операция **поиска** выполняется с помощью запроса GET или POST и содержит параметры, которые определяют условия сопоставления документов.

    GET https://[service name].search.windows.net/indexes/[index name]/docs?[query parameters]
    api-key: [admin or query key]

    POST https://[service name].search.windows.net/indexes/[index name]/docs/search?api-version=[api-version]
    Content-Type: application/json
    api-key: [admin or query key]

**В каких случаях следует использовать запрос POST вместо GET**

При использовании HTTP-запроса GET для вызова API **поиска** следует помнить, что длина URL-адреса запроса не должна превышать 8 КБ. Для большинства приложений этого достаточно. В то же время некоторые приложения создают очень длинные запросы или выражения фильтров OData. Лучший вариант для этих приложений — использование запроса HTTP POST, так как он позволяет увеличить фильтры и запросы по сравнению с GET. При использовании запроса POST ограничивающим фактором является количество условий или предложений в запросе, а не размер необработанных запросов, так как предельный размер запроса для POST ограничен примерно 16 МБ.

> [!NOTE]
> Даже несмотря на то, что размер запроса POST очень большой, поисковые запросы и выражения фильтров не могут иметь произвольную сложность. Дополнительные сведения об ограничениях по сложности для запросов и фильтров поиска см. в статьях, посвященных [синтаксису запросов Lucene](https://msdn.microsoft.com/library/mt589323.aspx) и [синтаксису выражений OData](https://msdn.microsoft.com/library/dn798921.aspx).
> 
> 

**Запрос**

Запросы к службе отправляются по протоколу HTTPS. Для отправки запроса на **поиск** можно использовать метод GET или POST.

В URI запроса указывается целевой индекс, из которого требуется вернуть все документы, соответствующие заданным параметрам. Параметры указываются в строке (для запросов GET) или в теле (для запросов POST) запроса.

При непосредственном вызове REST API для создания запросов GET рекомендуется преобразовывать ряд параметров запроса в [кодировку URL](https://msdn.microsoft.com/library/system.uri.escapedatastring.aspx) . Для операций **поиска** в число таких параметров входят:

* `$filter`
* `facet`
* `highlightPreTag`
* `highlightPostTag`
* `search`
* `moreLikeThis`

Преобразовывать в кодировку URL рекомендуется только перечисленные выше параметры. Если случайно преобразовать всю строку запроса (все знаки после ?), он завершится ошибкой.

Кроме того, преобразование в кодировку URL необходимо только при непосредственном обращении к API REST с помощью запроса GET. При вызове **поиска** с помощью запроса POST или при использовании [клиентской библиотеки .NET](https://msdn.microsoft.com/library/dn951165.aspx), которая автоматически выполняет кодировку URL-адресов, не требуется выполнять кодирование URL-адресов самостоятельно.

<a name="SearchQueryParameters"></a>
**Параметры запроса**

**Поиск** принимает несколько параметров, которые сообщают условия запроса и определяют способы поиска. Эти параметры указываются в строке запроса URL-адреса (при вызове **поиска** с помощью запроса GET) или в теле запроса в виде свойств JSON (при вызове **поиска** с помощью запроса POST). Синтаксис некоторых параметров зависит от выбора запроса GET и POST. Эти различия описаны ниже.

`search=[string]` (необязательный): искомый текст. По умолчанию ведется поиск по всем полям с атрибутом `searchable`, если не задан параметр `searchFields`. При поиске по полям со свойством `searchable` искомый текст разбивается на элементы, поэтому условия поиска можно разделять пробелами (пример: `search=hello world`). Чтобы вернуть совпадения по любому из условий, используйте значение `*` (это может быть полезно для запросов логической фильтрации). Если этот параметр опущен, по умолчанию он принимает значение `*`. Синтаксис поиска подробнее описан в статье [Синтаксис простых запросов](https://msdn.microsoft.com/library/dn798920.aspx) .

* **Примечание.** При поиске по полям с атрибутом `searchable` результаты иногда могут быть неожиданными. Лексический анализатор использует алгоритмы, применимые для английского текста (с апострофами, запятыми в числах и т. д.). Например, поиск по запросу `search=123,456` вернет совпадения для одного условия — 123,456, а не для двух отдельных условий 123 и 456, так как запятые в английском используются в качестве разделителей групп разрядов в больших числах. В связи с этим для разделения условий в параметре `search` рекомендуется вместо знаков пунктуации использовать пробелы.

`searchMode=any|all` (необязательный, значение по умолчанию — `any`): указывает, необходимо ли совпадение по всем условиям или по любому из них, чтобы документ был возвращен в числе результатов.

`searchFields=[string]` (необязательный): список полей через запятую, в которых нужно искать указанный текст. Для целевых полей должен быть задан атрибут `searchable`.

`queryType=simple|full` (необязательный, значение по умолчанию — `simple`). Если задано значение simple, искомый текст интерпретируется с помощью языка простых запросов, в котором разрешены такие символы, как +, * и "". Запросы вычисляются для всех полей поиска (или полей, указанных в `searchFields`) в каждом документе по умолчанию. Если тип запроса имеет значение `full`, искомый текст интерпретируется с помощью языка запросов Lucene, в котором разрешен поиск в конкретных полях и взвешенный поиск. Подробные сведения о синтаксисе поиска см. в статьях, посвященных [синтаксису простого запроса](https://msdn.microsoft.com/library/dn798920.aspx) и [синтаксису запросов Lucene](https://msdn.microsoft.com/library/mt589323.aspx). 

> [!NOTE]
> Диапазон поиска в языке запросов Lucene не поддерживается в пользу параметра $filter, который предоставляет аналогичные функциональные возможности.
> 
> 

`moreLikeThis=[key]` (необязательный) **Внимание!** Эта функция доступна только в версии `2015-02-28-Preview`. Этот параметр нельзя использовать в запросе, который содержит параметр текстового поиска `search=[string]`. С параметром `moreLikeThis` выполняется поиск документов, которые похожи на документ, указанный с помощью ключа. При обработке поискового запроса с параметром `moreLikeThis`формируется список условий поиска с учетом частоты и распространенности элементов в исходном документе. Затем условия из списка используются в запросе. По умолчанию анализируется содержимое всех полей с атрибутом `searchable`, если набор полей для поиска не задан с помощью параметра `searchFields`.  

`$skip=#` (необязательный). Количество результатов поиска, которые необходимо пропустить (максимальное значение — 100 000). Если нужно выполнить последовательный поиск по документам, однако воспользоваться параметром `$skip` нельзя из-за этого ограничения, попробуйте упорядочить результаты (параметр `$orderby`) по полностью упорядоченному ключу и отфильтровать их (`$filter`) с помощью запроса в диапазоне.

> [!NOTE]
> При вызове **поиска** с помощью запроса POST этот параметр называется `skip`, а не `$skip`.
> 
> 

`$top=#` (необязательный). Количество результатов поиска, которые необходимо получить. В сочетании с параметром `$skip` этот параметр позволяет реализовать разбивку результатов поиска на страницы на стороне клиента.

> [!NOTE]
> При вызове **поиска** с помощью запроса POST этот параметр называется `top`, а не `$top`.
> 
> 

`$count=true|false` (необязательный, значение по умолчанию — `false`): указывает, нужно ли вернуть общее количество результатов. Это количество всех документов, соответствующих параметрам `search` и `$filter` без учета `$top` и `$skip`. Если для этого параметра задать значение `true` , это может повлиять на производительность. Обратите внимание на то, что возвращается приблизительное количество результатов.

> [!NOTE]
> При вызове **поиска** с помощью запроса POST этот параметр называется `count`, а не `$count`.
> 
> 

`$orderby=[string]` (необязательный): список выражений через запятую для сортировки результатов. Выражение может быть именем поля или вызовом функции `geo.distance()` . После выражения можно указать атрибут (`asc` сортировка по возрастанию) или `desc` (сортировка по убыванию). По умолчанию результаты сортируются по возрастанию. При равенстве позиций порядок определяется по показателю совпадения документа. Если параметр `$orderby` не указан, по умолчанию документы сортируются в убывающем порядке по показателю совпадения. Максимальное количество предложений `$orderby`— 32.

> [!NOTE]
> При вызове **поиска** с помощью запроса POST этот параметр называется `orderby`, а не `$orderby`.
> 
> 

`$select=[string]` (необязательный): список извлекаемых полей через запятую. Если этот параметр не указан, возвращаются все поля, помеченные в схеме как подлежащие извлечению. Чтобы явным образом запросить все поля, задайте для этого параметра значение `*`.

> [!NOTE]
> При вызове **поиска** с помощью запроса POST этот параметр называется `select`, а не `$select`.
> 
> 

`facet=[string]` (ноль или больше параметров): поле, используемое для аспектирования. Это строковое значение может содержать параметры аспектирования в виде перечисленных через запятую пар `name:value` . Ниже перечислены возможные параметры.

* `count` (максимальное количество условий аспектирования; значение по умолчанию — 10). Максимального предела нет, однако чем больше количество, чем сильнее это влияет на производительность (особенно если поле аспекта содержит большое число уникальных элементов).
  * Пример. `facet=category,count:5` возвращает первые пять категорий в результатах аспектирования.  
  * **Примечание.** Если значение параметра `count` меньше числа уникальных элементов, результаты могут быть неточными. Это связано с особенностями распределения запросов аспектирования по сегментам. Увеличение значения `count` обычно повышает точность подсчета элементов, но за счет ухудшения производительности.
* `sort` (возможные значения: `count` — сортировка по количеству *в порядке убывания*, `-count` — сортировка по количеству *в порядке возрастания*, `value` — сортировка по значению *в порядке возрастания*, `-value` — сортировка по значению *в порядке убывания*).
  * Пример. `facet=category,count:3,sort:count` возвращает первые три категории в результатах аспектирования, отсортированные в убывающем порядке по количеству документов с названием каждого из городов. Например, если первые три категории — "бюджетные", "мотели" и "люкс", при этом для категории "бюджетные" найдено 5 документов, для категории "мотели" — 6 документов, а для категории "люкс" — 4 документа, то контейнеры возвращаются в следующем порядке: "мотели", "бюджетные", "люкс".
  * Пример. `facet=rating,sort:-value` возвращает контейнеры со всеми возможными значениями оценки rating, отсортированные в убывающем порядке по значению. Например, для оценок от 1 до 5 контейнеры будут отсортированы в последовательности 5, 4, 3, 2, 1 независимо от количества документов с каждой из оценок.
* `values` (разделенные символами вертикальной черты числовые значения или значения типа `Edm.DateTimeOffset`, задающие динамический набор значений записей аспектов)
  * Пример. `facet=baseRate,values:10|20` возвращает три контейнера: один для базового тарифа от 0 до 10 не включительно, один — от 10 до 20 не включительно, и один — от 20 и выше.
  * Пример. `facet=lastRenovationDate,values:2010-02-01T00:00:00Z` возвращает два контейнера: один для гостиниц, отремонтированных до февраля 2010 г., и один — для гостиниц, отремонтированных 1 февраля 2010 г. или позже.
* `interval` (целочисленный интервал больше 0 для числе либо `minute`, `hour`, `day`, `week`, `month`, `quarter` или `year` для значений даты и времени)
  * Пример. `facet=baseRate,interval:100` возвращает контейнеры для диапазонов базового тарифа с интервалом 100. Например, для базовых тарифов от 60 до 600 долларов будут возвращены контейнеры 0–100, 100–200, 200–300, 300–400, 400–500 и 500–600.
  * Пример: `facet=lastRenovationDate,interval:year` возвращает по одному контейнеру для каждого года, в течение которого выполнялся ремонт гостиниц.
* Параметр `timeoffset` ([+-]чч:мм, [+-]ччмм или [+-]чч) `timeoffset` является необязательным. Его можно комбинировать только с параметром `interval` и только в том случае, если он применяется к полю типа `Edm.DateTimeOffset`. Значение задает смещение времени UTC в учетной записи для настройки временных границ.
  * Пример. `facet=lastRenovationDate,interval:day,timeoffset:-01:00` использует границу дня, которая начинается в 01:00:00 в формате UTC (полночь в целевом часовом поясе).
* **Примечание**. Параметры `count` и `sort` можно использовать в одном запросе аспектирования, но их нельзя объединять с параметрами `interval` или `values`, при этом параметры `interval` и `values` нельзя использовать одновременно.
* **Примечание**. Границы интервала для даты и времени вычисляются на основе времени в формате UTC, если не указан параметр `timeoffset`. Пример. Для `facet=lastRenovationDate,interval:day` граница дня начинается в 00:00:00 UTC. 

> [!NOTE]
> При вызове **поиска** с помощью запроса POST этот параметр называется `facets`, а не `facet`. Кроме того, она задается в виде JSON-массива строк, где каждая строка представляет собой отдельное выражение аспектирования.
> 
> 

`$filter=[string]` (необязательный): выражение структурированного поиска в стандартном синтаксисе OData.

> [!NOTE]
> При вызове **поиска** с помощью запроса POST этот параметр называется `filter`, а не `$filter`.
> 
> 

`highlight=[string]` (необязательный): набор имен полей через запятую, используемых для выделения совпадений. Для выделения можно использовать только поля с атрибутом `searchable` .

`highlightPreTag=[string]` (необязательный, значение по умолчанию — `<em>`): строковый тег, который добавляется в начале строки выделения количества совпадений. Для него должно быть задано значение `highlightPostTag`.

> [!NOTE]
> При вызове **поиска** с помощью запроса GET зарезервированные символы в URL-адресе следует заменить сочетанием символов со знаком процента (например, %23 вместо #).
> 
> 

`highlightPostTag=[string]` (необязательный, значение по умолчанию — `</em>`): строковый тег, который добавляется в конце строки выделения количества совпадений. Для него должно быть задано значение `highlightPreTag`.

> [!NOTE]
> При вызове **поиска** с помощью запроса GET зарезервированные символы в URL-адресе следует заменить сочетанием символов со знаком процента (например, %23 вместо #).
> 
> 

`scoringProfile=[string]` (необязательный): имя профиля оценки для сортировки результатов по показателю совпадения документов.

`scoringParameter=[string]` (ноль или больше): задает значения параметров, определенных в функции оценки (например, `referencePointParameter`), в формате `name-value1,value2,...`.

* Например, если в профиле повышения определена функция с параметром mylocation, то строка запроса может содержать параметр `&scoringParameter=mylocation--122.2,44.8`. Первый дефис отделяет имя от списка значений, а второй является частью первого значения (в этом примере — долгота).
* Для параметров оценки, например при улучшении тегов, которые могут содержать запятые, значения списка можно завершать одинарными кавычками. Если одинарные кавычки содержатся в самих значениях, этот символ можно экранировать путем дублирования.
  * Например, если имеется параметр повышения тегов с именем mytag и нужно повысить значения тегов Hello, O'Brien и Smith, то строка запроса может иметь следующий вид: `&scoringParameter=mytag-'Hello, O''Brien',Smith`. Обратите внимание, что кавычки нужны только для значений, содержащих запятые.

> [!NOTE]
> При вызове **поиска** с помощью запроса POST этот параметр называется `scoringParameters`, а не `scoringParameter`. Кроме того, она задается в виде массива JSON строк, где каждая строка представляет собой отдельную пару `name-values` .
> 
> 

`minimumCoverage` (необязательно, по умолчанию — 100) — число от 0 до 100, указывающее процент индекса, который должен составлять поисковой запрос для возвращения успешного результата запроса. По умолчанию должен быть доступен весь индекс, иначе `Search` вернет код состояния HTTP 503. Если вы зададите значение параметра `minimumCoverage` и `Search` завершится успешно, будет возвращен ответ с состоянием HTTP 200 и значением `@search.coverage`, указывающим процент индекса, включенного в запрос.

> [!NOTE]
> Можно задать для этого параметра значение меньше 100, чтобы обеспечить доступность поиска даже для служб с одной репликой. Однако в таком случае в результатах поиска могут не присутствовать все совпадающие документы. Если полнота результатов поискового запроса важнее для приложения, чем доступность поиска, лучше оставить для параметра `minimumCoverage` значение по умолчанию (100).
> 
> 

`api-version=[string]` (обязательный). Предварительная версия — `api-version=2015-02-28-Preview`. Подробные сведения, в том числе о других версиях, см. в статье об [управлении версиями службы поиска](http://msdn.microsoft.com/library/azure/dn864560.aspx).

Примечание. Для этой операции `api-version` указывается как параметр запроса в URL-адресе независимо от того, с помощью какого запроса вызывается **поиск** — GET или POST.

**Заголовки запроса**

В списке ниже перечислены обязательные и необязательные заголовки запроса.

* `api-key`: заголовок `api-key` используется для проверки подлинности запроса в службе поиска. Это строковое значение, уникальное для URL службы. В запросе **поиска** для параметра `api-key` может быть указан ключ администратора или ключ запроса.

Для формирования URL-адреса запроса также понадобится имя службы. Имя и `api-key` можно найти в панели мониторинга службы на портале Azure. Дополнительные сведения о навигации по страницам см. в статье, посвященной [созданию службы поиска на портале](search-create-service-portal.md).

**Тело запроса**

Для запроса GET: нет.

Для запроса POST:

    {
      "count": true | false (default),
      "facets": [ "facet_expression_1", "facet_expression_2", ... ],
      "filter": "odata_filter_expression",
      "highlight": "highlight_field_1, highlight_field_2, ...",
      "highlightPreTag": "pre_tag",
      "highlightPostTag": "post_tag",
      "minimumCoverage": # (% of index that must be covered to declare query successful; default 100),
      "moreLikeThis": "document_key" (mutually exclusive with "search" parameter),
      "orderby": "orderby_expression",
      "scoringParameters": [ "scoring_parameter_1", "scoring_parameter_2", ... ],
      "scoringProfile": "scoring_profile_name",
      "search": "simple_query_expression",
      "searchFields": "field_name_1, field_name_2, ...",
      "searchMode": "any" (default) | "all",
      "select": "field_name_1, field_name_2, ...",
      "skip": # (default 0),
      "top": #
    }

**Продолжение частичных ответов поиска**

Иногда служба поиска Azure не может вернуть все запрошенные результаты в одном ответе поиска. Это может произойти по разным причинам, например, когда запрос запрашивает слишком много документов, не указывая `$top` или указывая слишком большое значение для `$top`. В таких случаях служба поиска Azure будет включать заметку `@odata.nextLink` в тексте ответа, а также `@search.nextPageParameters`, если это был запрос POST. Вы можете использовать значения этих заметок, чтобы составить другой запрос на поиск для получения следующей части ответа поиска. Это называется ***продолжением*** исходного запроса на поиск, а такие аннотации обычно называются ***маркерами продолжения***. В [приведенном ниже примере](#SearchResponse) есть дополнительные сведения о синтаксисе этих аннотаций и их расположении в тексте ответа. 

Причины, по которым поиск Azure может возвращать токены продолжения, зависят от реализации и могут изменяться. Надежные клиенты должны быть всегда готовы к ситуациям, когда возвращается меньше документов, чем ожидалось, и предоставляется токен продолжения, позволяющий продолжить извлечение документов. Кроме того, обратите внимание, что для продолжения необходимо использовать тот же самый метод HTTP, что и в исходном запросе. Например, если был отправлен запрос GET, все отправляемые запросы на продолжение должны также использовать GET (это справедливо и для POST).

<a name="SearchResponse"></a>
**Ответ**

Код состояния: в качестве успешного ответа возвращается код "200 — ОК".

    {
      "@odata.count": # (if $count=true was provided in the query),
      "@search.coverage": # (if minimumCoverage was provided in the query),
      "@search.facets": { (if faceting was specified in the query)
        "facet_field": [
          {
            "value": facet_entry_value (for non-range facets),
            "from": facet_entry_value (for range facets),
            "to": facet_entry_value (for range facets),
            "count": number_of_documents
          }
        ],
        ...
      },
      "@search.nextPageParameters": { (request body to fetch the next page of results if not all results could be returned in this response and Search was called with POST)
        "count": ... (value from request body if present),
        "facets": ... (value from request body if present),
        "filter": ... (value from request body if present),
        "highlight": ... (value from request body if present),
        "highlightPreTag": ... (value from request body if present),
        "highlightPostTag": ... (value from request body if present),
        "minimumCoverage": ... (value from request body if present),
        "moreLikeThis": ... (value from request body if present),
        "orderby": ... (value from request body if present),
        "scoringParameters": ... (value from request body if present),
        "scoringProfile": ... (value from request body if present),
        "search": ... (value from request body if present),
        "searchFields": ... (value from request body if present),
        "searchMode": ... (value from request body if present),
        "select": ... (value from request body if present),
        "skip": ... (page size plus value from request body if present),
        "top": ... (value from request body if present minus page size),
      },
      "value": [
        {
          "@search.score": document_score (if a text query was provided),
          "@search.highlights": {
            field_name: [ subset of text, ... ],
            ...
          },
          key_field_name: document_key,
          field_name: field_value (retrievable fields or specified projection),
          ...
        },
        ...
      ],
      "@odata.nextLink": (URL to fetch the next page of results if not all results could be returned in this response; Applies to both GET and POST)
    }

**Примеры**

Дополнительные примеры можно найти в статье [Синтаксис выражений OData для поиска Azure](https://msdn.microsoft.com/library/azure/dn798921.aspx) .

1)    Получение из индекса документов, отсортированных по дате.

    GET /indexes/hotels/docs?search=*&$orderby=lastRenovationDate desc&api-version=2015-02-28-Preview

    POST /indexes/hotels/docs/search?api-version=2015-02-28-Preview { "search": "*", "orderby": "lastRenovationDate desc" }

2)    Аспектный поиск: получение из индекса аспектов по категориям, оценкам, тегам, а также документов с базовым тарифом baseRate в определенных диапазонах.

    GET /indexes/hotels/docs?search=test&facet=category&facet=rating&facet=tags&facet=baseRate,values:80|150|220&api-version=2015-02-28-Preview

    POST /indexes/hotels/docs/search?api-version=2015-02-28-Preview { "search": "test", "facets": [ "category", "rating", "tags", "baseRate,values:80|150|220" ] }

3)    Уточнение результатов аспектного поиска из предыдущего запроса с помощью фильтра после того, как пользователь выбирает оценку 3 и категорию "Motel".

    GET /indexes/hotels/docs?search=test&facet=tags&facet=baseRate,values:80|150|220&$filter=rating eq 3 and category eq 'Motel'&api-version=2015-02-28-Preview

    POST /indexes/hotels/docs/search?api-version=2015-02-28-Preview { "search": "test", "facets": [ "tags", "baseRate,values:80|150|220" ], "filter": "rating eq 3 and category eq 'Motel'" }

4) Установка для результатов аспектного поиска верхнего предела на количество уникальных условий поиска, возвращаемых запросом. Значение по умолчанию — 10, однако его можно увеличивать и уменьшать с помощью параметра `count` в атрибуте `facet`:

    GET /indexes/hotels/docs?search=test&facet=city,count:5&api-version=2015-02-28-Preview

    POST /indexes/hotels/docs/search?api-version=2015-02-28-Preview  {    "search": "test",    "facets": [ "city,count:5" ]  }

5)    Поиск в индексе по определенным полям (например, в зависимости от языка).

    GET /indexes/hotels/docs?search=hôtel&searchFields=description_fr&api-version=2015-02-28-Preview

    POST /indexes/hotels/docs/search?api-version=2015-02-28-Preview { "search": "hôtel", "searchFields": "description_fr" }

6) Поиск в индексе по нескольким полям. Например, в одном индексе можно хранить и искать данные в нескольких доступных для поиска полях на разных языках.  Если в одном документе есть описания на английском и французском, в результатах поиска можно вернуть любые или все документы по запросу:

    GET /indexes/hotels/docs?search=hotel&searchFields=description,description_fr&api-version=2015-02-28-Preview

    POST /indexes/hotels/docs/search?api-version=2015-02-28-Preview  {    "search": "hotel",    "searchFields": "description, description_fr"  }

Обратите внимание на то, что запрос можно отправить только к одному индексу. Не создавайте отдельные индексы для каждого языка, если не планируете отправлять к ним запросы по отдельности.

7)    Разбиение на страницы: получение первой страницы (по 10 элементов на страницу).

    GET /indexes/hotels/docs?search=*&$skip=0&$top=10&api-version=2015-02-28-Preview

    POST /indexes/hotels/docs/search?api-version=2015-02-28-Preview { "search": "*", "skip": 0, "top": 10 }

8)    Разбиение на страницы: получение второй страницы (по 10 элементов на страницу).

    GET /indexes/hotels/docs?search=*&$skip=10&$top=10&api-version=2015-02-28-Preview

    POST /indexes/hotels/docs/search?api-version=2015-02-28-Preview { "search": "*", "skip": 10, "top": 10 }

9)    Получение определенного набора полей.

    GET /indexes/hotels/docs?search=*&$select=hotelName,description&api-version=2015-02-28-Preview

    POST /indexes/hotels/docs/search?api-version=2015-02-28-Preview { "search": "*", "select": "hotelName, description" }

10)  Получение документов, соответствующих определенному выражению фильтра.

    GET /indexes/hotels/docs?$filter=(baseRate ge 60 and baseRate lt 300) or hotelName eq 'Fancy Stay'&api-version=2015-02-28-Preview

    POST /indexes/hotels/docs/search?api-version=2015-02-28-Preview {  "filter": "(baseRate ge 60 and baseRate lt 300) or hotelName eq 'Fancy Stay'" }

11) Поиск в индексе фрагментов с выделением совпадений в результатах.

    GET /indexes/hotels/docs?search=something&highlight=description&api-version=2015-02-28-Preview

    POST /indexes/hotels/docs/search?api-version=2015-02-28-Preview {   "search": "something",   "highlight": "description" }

12) Извлечение из индекса документов, отсортированных по признаку расстояния (от минимального до максимального) от определенного места.

    GET /indexes/hotels/docs?search=something&$orderby=geo.distance(location, geography'POINT(-122.12315 47.88121)')&api-version=2015-02-28-Preview

    POST /indexes/hotels/docs/search?api-version=2015-02-28-Preview {   "search": "something",   "orderby": "geo.distance(location, geography'POINT(-122.12315 47.88121)')" }

13) Поиск по индексу с использованием профиля оценки geo, который содержит две функции оценки расстояния: в одной из них определен параметр currentLocation, в другой — параметр lastLocation.

    GET /indexes/hotels/docs?search=something&scoringProfile=geo&scoringParameter=currentLocation--122.123,44.77233&scoringParameter=lastLocation--121.499,44.2113&api-version=2015-02-28-Preview

    POST /indexes/hotels/docs/search?api-version=2015-02-28-Preview {   "search": "something",   "scoringProfile": "geo",   "scoringParameters": [ "currentLocation--122.123,44.77233", "lastLocation--121.499,44.2113" ] }

14) Поиск документов в индексе с использованием [синтаксиса простых запросов](https://msdn.microsoft.com/library/dn798920.aspx). Этот запрос возвращает гостиницы, в которых поля, участвующие в поиске, содержат слова comfort и location, но не motel:

    GET /indexes/hotels/docs?search=comfort +location -motel&searchMode=all&api-version=2015-02-28-Preview

    POST /indexes/hotels/docs/search?api-version=2015-02-28-Preview {   "search": "comfort +location -motel",   "searchMode": "all" }

Обратите внимание на использование параметра `searchMode=all` выше. Если он указан, он переопределяет значение по умолчанию `searchMode=any`, и предложение `-motel` означает "И НЕ" вместо "ИЛИ НЕ". Без параметра `searchMode=all`используется условие "ИЛИ НЕ", которое расширяет, а не сужает результаты поиска, что может показаться неочевидным для некоторых пользователей.

15) Поиск документов в индексе с использованием [синтаксиса запросов Lucene](https://msdn.microsoft.com/library/mt589323.aspx). Этот запрос возвращает гостиницы, у которых поле «Категория» содержит термин «бюджет», а все поля для поиска содержат фразу «недавно сделан ремонт». Документам, содержащим слова «недавно сделан ремонт», присваивается более высокая оценка в результате повышенного значения этого термина (3).

    GET /indexes/hotels/docs?search=category:budget AND \"recently renovated\"^3&searchMode=all&api-version=2015-02-28-Preview&querytype=full

    POST /indexes/hotels/docs/search?api-version=2015-02-28-Preview {   "search": "category:budget AND \"recently renovated\"^3",   "queryType": "full",   "searchMode": "all" }

<a name="LookupAPI"></a>

## <a name="lookup-document"></a>Запрос документов
Операция **запроса документа** возвращает определенный документ из службы поиска Azure. Она применяется в ситуации, когда пользователь щелкает по тому или иному результату поиска и необходимо получить определенные сведения о соответствующем документе.

    GET https://[service name].search.windows.net/indexes/[index name]/docs/[key]?[query parameters]
    api-key: [admin or query key]

**Запрос**

Запросы к службе отправляются по протоколу HTTPS. **Запрос документа** формируется следующим образом:

    GET /indexes/[index name]/docs/key?[query parameters]

Кроме того, для поиска по ключу можно использовать традиционный синтаксис OData:

    GET /indexes('[index name]')/docs('[key]')?[query parameters]

URI запроса содержит параметр [index name] и [key], которые указывают, какой именно документ нужно извлечь из данного индекса. За один раз можно получить только один документ. Получить сразу несколько документов можно с помощью запроса **поиска** .

**Параметры запроса**

`$select=[string]` (необязательный): список извлекаемых полей через запятую. Если этот параметр не указан или содержит значение `*`, возвращаются все поля, помеченные в схеме как подлежащие извлечению и входящие в проекцию.

`api-version=[string]` (обязательный). Предварительная версия — `api-version=2015-02-28-Preview`. Подробные сведения, в том числе о других версиях, см. в статье об [управлении версиями службы поиска](http://msdn.microsoft.com/library/azure/dn864560.aspx).

Примечание. Для этой операции `api-version` указывается в качестве параметра запроса.

**Заголовки запроса**

В списке ниже перечислены обязательные и необязательные заголовки запроса.

* `api-key`: заголовок `api-key` используется для проверки подлинности запроса в службе поиска. Это строковое значение, уникальное для URL службы. В **запросе документа** для параметра `api-key` может быть указан ключ администратора или ключ запроса.

Для формирования URL-адреса запроса также понадобится имя службы. Имя и `api-key` можно найти в панели мониторинга службы на портале Azure. Дополнительные сведения о навигации по страницам см. в статье, посвященной [созданию службы поиска на портале](search-create-service-portal.md).

**Тело запроса**

Отсутствует.

**Ответ**

Код состояния: в качестве успешного ответа возвращается код "200 — ОК".

    {
      field_name: field_value (fields matching the default or specified projection)
    }

**Пример**

Запрос документа со значением ключа 2.

    GET /indexes/hotels/docs/2?api-version=2015-02-28-Preview

Запрос документа со значением ключа 3 с помощью синтаксиса OData:

    GET /indexes('hotels')/docs('3')?api-version=2015-02-28-Preview

<a name="CountDocs"></a>

## <a name="count-documents"></a>Подсчет документов
Операция **подсчета документов** возвращает количество документов в индексе поиска. Синтаксическая конструкция `$count` является частью протокола OData.

    GET https://[service name].search.windows.net/indexes/[index name]/docs/$count?api-version=[api-version]
    Accept: text/plain
    api-key: [admin or query key]

**Запрос**

Запросы к службе отправляются по протоколу HTTPS. Для отправки запроса на **подсчет документов** можно использовать метод GET.

Параметр [index name] в URI запроса указывает службе, для какого именно индекса требуется вернуть количество документов в коллекции.

`api-version=[string]` (обязательный). Предварительная версия — `api-version=2015-02-28-Preview`. Подробные сведения, в том числе о других версиях, см. в статье об [управлении версиями службы поиска](http://msdn.microsoft.com/library/azure/dn864560.aspx).

**Заголовки запроса**

В списке ниже перечислены обязательные и необязательные заголовки запроса.

* `Accept`: для этого заголовка задается значение `text/plain`.
* `api-key`: заголовок `api-key` используется для проверки подлинности запроса в службе поиска. Это строковое значение, уникальное для URL службы. В запросе на **подсчет документов** для параметра `api-key` может быть указан ключ администратора или ключ запроса.

Для формирования URL-адреса запроса также понадобится имя службы. Имя и `api-key` можно найти в панели мониторинга службы на портале Azure. Дополнительные сведения о навигации по страницам см. в статье, посвященной [созданию службы поиска на портале](search-create-service-portal.md).

**Тело запроса**

Отсутствует.

**Ответ**

Код состояния: в качестве успешного ответа возвращается код "200 — ОК".

Тело ответа содержит целочисленное значение количества, отформатированное в виде обычного текста.

<a name="Suggestions"></a>

## <a name="suggestions"></a>Предложения
Операция **Предложения** возвращает предложения на основе частичных исходных данных. Как правило, она используется в полях поиска и позволяет предложить пользователям варианты при вводе поисковых условий.

Запросы предложений возвращают целевые документы, поэтому текст предложений может повторяться, если несколько документов соответствуют одному и тому же набору исходных данных для поиска. С помощью атрибута `$select` можно извлечь другие поля документа (в том числе ключ), позволяющие определить, какому именно документу соответствует то или иное предложение.

Операция **вызова предложений** выполняется как запрос GET или POST.

    GET https://[service name].search.windows.net/indexes/[index name]/docs/suggest?[query parameters]
    api-key: [admin or query key]

    POST https://[service name].search.windows.net/indexes/[index name]/docs/suggest?api-version=[api-version]
    Content-Type: application/json
    api-key: [admin or query key]

**В каких случаях следует использовать запрос POST вместо GET**

При использовании HTTP-запроса GET для вызова API **предложений** следует помнить, что длина URL-адреса запроса не должна превышать 8 КБ. Для большинства приложений этого достаточно. В то же время некоторые приложения создают очень длинные запросы, в частности выражения фильтров OData. Лучший вариант для этих приложений — использование запроса HTTP POST, так как он позволяет увеличить фильтры по сравнению с GET. При использовании запроса POST ограничивающим фактором является количество предложений в запросе, а не необработанная строка фильтра, так как предельный размер запроса для POST ограничен примерно 16 МБ.

> [!NOTE]
> Даже несмотря на то, что размер запроса POST очень большой, выражения фильтров не могут иметь произвольную сложность. Дополнительные сведения об ограничениях сложности фильтров см. в статье, посвященной [синтаксису выражений OData](https://msdn.microsoft.com/library/dn798921.aspx).
> 
> 

**Запрос**

Запросы к службе отправляются по протоколу HTTPS. Для отправки запроса на **вызов предложений** можно использовать метод GET или POST.

В URI запроса указывается имя индекса. Параметры, например фрагмент условия поискового запроса, указываются в строке (для запросов GET) или в теле (для запросов POST) запроса.

При непосредственном вызове REST API для создания запросов GET рекомендуется преобразовывать ряд параметров запроса в [кодировку URL](https://msdn.microsoft.com/library/system.uri.escapedatastring.aspx) . Для операций **вызова предложений** эти параметры указаны ниже.

* `$filter`
* `highlightPreTag`
* `highlightPostTag`
* `search`

Преобразовывать в кодировку URL рекомендуется только перечисленные выше параметры. Если случайно преобразовать всю строку запроса (все знаки после ?), он завершится ошибкой.

Кроме того, преобразование в кодировку URL необходимо только при непосредственном обращении к API REST с помощью запроса GET. При вызове **предложений** с помощью запроса POST или при использовании [клиентской библиотеки .NET](https://msdn.microsoft.com/library/dn951165.aspx), которая автоматически выполняет кодирование URL-адресов, не требуется выполнять кодирование URL-адресов самостоятельно.

**Параметры запроса**

**Предложения** принимает несколько параметров, которые сообщают условия запроса и определяют способы поиска. Эти параметры указываются в строке запроса URL-адреса (при вызове **предложений** с помощью запроса GET) или в теле запроса в виде свойств JSON (при вызове **предложений** с помощью запроса POST). Синтаксис некоторых параметров зависит от выбора запроса GET и POST. Эти различия описаны ниже.

`search=[string]` — искомый текст, на основе которого должны быть выданы предложения. Минимальная длина — 1 символ, максимальная — 100 символов.

`highlightPreTag=[string]` (необязательный): строковый тег, который добавляется в начале строки количества совпадений поиска. Для него должно быть задано значение `highlightPostTag`.

> [!NOTE]
> При вызове **предложений** с помощью запроса GET зарезервированные символы в URL-адресе следует заменять сочетанием символов со знаком процента (например, %23 вместо #).
> 
> 

`highlightPostTag=[string]` (необязательный): строковый тег, который добавляется в конце строки количества совпадений поиска. Для него должно быть задано значение `highlightPreTag`.

> [!NOTE]
> При вызове **предложений** с помощью запроса GET зарезервированные символы в URL-адресе следует заменять сочетанием символов со знаком процента (например, %23 вместо #).
> 
> 

`suggesterName=[string]`: имя средства подбора, указанное в коллекции `suggesters` в определении индекса. `suggester` определяет, в каких полях выполняется поиск предложений по условиям запроса. Дополнительные сведения см. в разделе [Средства подбора](#Suggesters).

`fuzzy=[boolean]` (необязательно, значение по умолчанию — false): когда для этого параметра задано значение true, API возвращает предложения, даже если в искомом тексте заменен или отсутствует символ. В определенных ситуациях это улучшает результат, однако ведет к снижению производительности, так как запросы по нечеткому соответствию обрабатываются медленнее и потребляют больше ресурсов.

`searchFields=[string]` (необязательный): список полей через запятую, в которых нужно искать указанный текст. Для целевых полей должен быть разрешен поиск предложений.

`$top=#` (необязательный, значение по умолчанию — 5): количество получаемых предложений. Это значение должно быть в диапазоне от 1 до 100.

> [!NOTE]
> При вызове **предложений** с помощью запроса POST этот параметр называется `top`, а не `$top`.
> 
> 

`$filter=[string]` (необязательный): выражение для фильтрации документов, по которым производится поиск предложений.

> [!NOTE]
> При вызове **предложений** с помощью запроса POST этот параметр называется `filter`, а не `$filter`.
> 
> 

`$orderby=[string]` (необязательный): список выражений через запятую для сортировки результатов. Выражение может быть именем поля или вызовом функции `geo.distance()` . После выражения можно указать атрибут (`asc` сортировка по возрастанию) или `desc` (сортировка по убыванию). По умолчанию результаты сортируются по возрастанию. Максимальное количество предложений `$orderby`— 32.

> [!NOTE]
> При вызове **предложений** с помощью запроса POST этот параметр называется `orderby`, а не `$orderby`.
> 
> 

`$select=[string]` (необязательный): список извлекаемых полей через запятую. Если этот параметр не указан, возвращаются только ключ документа и текст предложения. Чтобы явным образом запросить все поля, задайте для этого параметра значение `*`.

> [!NOTE]
> При вызове **предложений** с помощью запроса POST этот параметр называется `select`, а не `$select`.
> 
> 

`minimumCoverage` (необязательно, по умолчанию — 80) — число от 0 до 100, указывающее процент индекса, который должен составлять запрос предложений для возвращения успешного результата запроса. По умолчанию должно быть доступно по крайней мере 80 % индекса, иначе `Suggest` вернет код состояния HTTP 503. Если вы зададите значение параметра `minimumCoverage` и `Suggest` завершится успешно, будет возвращен ответ с состоянием HTTP 200 и значением `@search.coverage`, указывающим процент индекса, включенного в запрос.

> [!NOTE]
> Можно задать для этого параметра значение меньше 100, чтобы обеспечить доступность поиска даже для служб с одной репликой. Однако в таком случае в результатах поиска могут не присутствовать все совпадающие предложения. Если полнота результатов поискового запроса важнее для приложения, чем доступность поиска, лучше оставить для параметра `minimumCoverage` значение ниже значения по умолчанию (80).
> 
> 

`api-version=[string]` (обязательный). Предварительная версия — `api-version=2015-02-28-Preview`. Подробные сведения, в том числе о других версиях, см. в статье об [управлении версиями службы поиска](http://msdn.microsoft.com/library/azure/dn864560.aspx).

Примечание. Для этой операции `api-version` указывается как параметр запроса в URL-адресе независимо от того, с помощью какого запроса вы вызываете **предложения** — GET или POST.

**Заголовки запроса**

В списке ниже перечислены обязательные и необязательные заголовки запроса.

* `api-key`: заголовок `api-key` используется для проверки подлинности запроса в службе поиска. Это строковое значение, уникальное для URL службы. В запросе на **предложения** для параметра `api-key` может быть указан ключ администратора или ключ запроса.

Для формирования URL-адреса запроса также понадобится имя службы. Имя и `api-key` можно найти в панели мониторинга службы на портале Azure. Дополнительные сведения о навигации по страницам см. в статье, посвященной [созданию службы поиска на портале](search-create-service-portal.md).

**Тело запроса**

Для запроса GET: нет.

Для запроса POST:

    {
      "filter": "odata_filter_expression",
      "fuzzy": true | false (default),
      "highlightPreTag": "pre_tag",
      "highlightPostTag": "post_tag",
      "minimumCoverage": # (% of index that must be covered to declare query successful; default 80),
      "orderby": "orderby_expression",
      "search": "partial_search_input",
      "searchFields": "field_name_1, field_name_2, ...",
      "select": "field_name_1, field_name_2, ...",
      "suggesterName": "suggester_name",
      "top": # (default 5)
    }

**Ответ**

Код состояния: в качестве успешного ответа возвращается код "200 — ОК".

    {
      "@search.coverage": # (if minimumCoverage was provided in the query),
      "value": [
        {
          "@search.text": "...",
          "<key field>": "..."
        },
        ...
      ]
    }

Если вы используете параметр проекции для извлечения полей, они включаются в каждый элемент массива:

    {
      "@search.coverage": # (if minimumCoverage was provided in the query),
      "value": [
        {
          "@search.text": "...",
          "<key field>": "..."
          <other projected data fields>
        },
        ...
      ]
    }

**Пример**

Получение пяти предложений для фрагмента поискового запроса lux:

    GET /indexes/hotels/docs/suggest?search=lux&$top=5&suggesterName=sg&api-version=2015-02-28-Preview

    POST /indexes/hotels/docs/suggest?api-version=2015-02-28-Preview
    {
      "search": "lux",
      "top": 5,
      "suggesterName": "sg"
    }

