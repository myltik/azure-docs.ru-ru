---
title: Подключение базы данных SQL Azure к службе поиска Azure с помощью индексаторов | Документация Майкрософт
description: Узнайте, как извлекать данные из Базы данных SQL Azure в индекс Поиска Azure с помощью индексаторов.
author: chaosrealm
manager: jlembicz
services: search
ms.service: search
ms.devlang: rest-api
ms.topic: conceptual
ms.date: 03/26/2018
ms.author: eugenesh
ms.openlocfilehash: 02b4e8cb4963a5c12b528630e8e7906d6c5307fe
ms.sourcegitcommit: fa493b66552af11260db48d89e3ddfcdcb5e3152
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2018
---
# <a name="connecting-azure-sql-database-to-azure-search-using-indexers"></a>Подключение базы данных SQL Azure к Поиску Azure с помощью индексаторов

Перед запросом [индексом службы Поиска Azure](search-what-is-an-index.md) необходимо заполнить его данными. Если данные находятся в базе данных SQL Azure, **индексатор Поиска Azure для базы данных SQL Azure** (сокращенно — **индексатор SQL Azure**) поможет автоматизировать индексирование, что позволяет сократить количество кода и объем инфраструктуры.

В этой статье рассматривается механизм использования [индексаторов](search-indexer-overview.md), а также подробно описываются функции, доступные только в базах данных SQL Azure (например, интегрированное отслеживание изменений). 

В дополнение к базам данных SQL Azure, Поиск Azure предоставляет индексаторы для [Azure Cosmos DB](search-howto-index-cosmosdb.md), [хранилища BLOB-объектов Azure](search-howto-indexing-azure-blob-storage.md) и [хранилища таблиц Azure](search-howto-indexing-azure-tables.md). Чтобы запросить поддержку для других источников данных, оставьте свой отзыв на [форуме отзывов по Поиску Azure](https://feedback.azure.com/forums/263029-azure-search/).

## <a name="indexers-and-data-sources"></a>Индексаторы и источники данных

**Источник данных** определяет, какие данные следует индексировать, какие учетные данные требуются для доступа к данным и какие политики нужны, чтобы эффективно выявлять изменения в данных (новые, измененные или удаленные строки). Он определяется как независимый ресурс, который могут использовать несколько индексаторов.

**Индексатор** — это ресурс, соединяющий один источник данных с целевым индексом поиска. Индексатор используется в следующих случаях.

* однократное копирование данных для заполнения индекса;
* добавление в индекс изменений в источнике данных по расписанию;
* запуск по требованию для обновления индекса при необходимости.

Один индексатор может использовать только одну таблицу или представление, однако можно создать несколько индексаторов, если вы хотите заполнить несколько индексов поиска. Дополнительные сведения см. в статье [Indexer operations (Azure Search Service REST API)](https://docs.microsoft.com/rest/api/searchservice/Indexer-operations#typical-workflow) (Операции с индексаторами в REST API службы поиска Azure).

Индексатор SQL Azure можно установить и настроить с помощью:

* мастера импорта данных на [портале Azure](https://portal.azure.com);
* [пакета SDK .NET для Поиска Azure](https://docs.microsoft.com/dotnet/api/microsoft.azure.search.models.indexer?view=azure-dotnet);
* [REST API](https://docs.microsoft.com/rest/api/searchservice/indexer-operations) Поиска Azure;

В этой статье мы будем использовать REST API для создания **индексаторов** и **источников данных**.

## <a name="when-to-use-azure-sql-indexer"></a>Когда следует использовать индексатор SQL Azure
Уместность использования индексатора Azure SQL зависит от нескольких факторов, связанных с данными. Если данные соответствуют следующим требованиям, вы можете использовать индексатор SQL Azure.

| Критерии | Сведения |
|----------|---------|
| Источником данных является отдельная таблица или представление | Если данные разбиты по нескольким таблицам, можно создать одно представление данных. Однако при использовании представления вы не сможете использовать интегрированное отслеживание изменений SQL Server для обновления индекса с помощью добавочных изменений. Дополнительные сведения см. в разделе [Запись измененных и удаленных строк](#CaptureChangedRows) ниже. |
| Типы данных совместимы | Большинство типов SQL, но не все из них, поддерживаются индексом Поиска Azure. Список см. в разделе [Сопоставление типов данных](#TypeMapping). |
| Синхронизация данных в режиме реального времени необязательна | Индексатор может выполнять повторное индексирование таблицы не чаще, чем раз в пять минут. При частом изменении данных, которые должны быть отражены в индексе в течение нескольких секунд или минут, мы рекомендуем использовать [REST API](https://docs.microsoft.com/rest/api/searchservice/AddUpdate-or-Delete-Documents) или [пакет SDK для .NET](search-import-data-dotnet.md), чтобы отправлять обновленные строки напрямую. |
| Возможно добавочное индексирование | Если вы располагаете большим набором данных и собираетесь запускать индексатор по расписанию, Поиск Azure должен иметь возможность эффективного определения новых, измененных или удаленных строк. Недобавочное индексирование разрешено только при индексировании по требованию или при индексации менее 100 000 строк. Дополнительные сведения см. в разделе [Запись измененных и удаленных строк](#CaptureChangedRows) ниже. |

> [!NOTE] 
> Поиск Azure поддерживает только аутентификацию SQL Server. Если требуется поддержка для аутентификации Azure Active Directory, проголосуйте за это [предложение UserVoice](https://feedback.azure.com/forums/263029-azure-search/suggestions/33595465-support-azure-active-directory-password-authentica).

## <a name="create-an-azure-sql-indexer"></a>Создание индексатора SQL Azure

1. Создайте источник данных:

   ```
    POST https://myservice.search.windows.net/datasources?api-version=2016-09-01
    Content-Type: application/json
    api-key: admin-key

    {
        "name" : "myazuresqldatasource",
        "type" : "azuresql",
        "credentials" : { "connectionString" : "Server=tcp:<your server>.database.windows.net,1433;Database=<your database>;User ID=<your user name>;Password=<your password>;Trusted_Connection=False;Encrypt=True;Connection Timeout=30;" },
        "container" : { "name" : "name of the table or view that you want to index" }
    }
   ```

   Вы можете получить строку подключения на [портале Azure](https://portal.azure.com). Используйте вариант `ADO.NET connection string`.

2. Создайте целевой индекс Поиска Azure, если вы еще не сделали это. Создать индекс можно с помощью [портала](https://portal.azure.com) или [API создания индекса](https://docs.microsoft.com/rest/api/searchservice/Create-Index). Убедитесь, что схема целевого индекса совместима со схемой исходной таблицы. Ознакомьтесь с разделом [Сопоставление типов данных SQL и поиска Azure](#TypeMapping).

3. Создайте индексатор, задав ему имя и связав источник данных с целевым индексом:

    ```
    POST https://myservice.search.windows.net/indexers?api-version=2016-09-01
    Content-Type: application/json
    api-key: admin-key

    {
        "name" : "myindexer",
        "dataSourceName" : "myazuresqldatasource",
        "targetIndexName" : "target index name"
    }
    ```

У индексатора, созданного таким образом, нет расписания. Он автоматически выполняется один раз сразу после создания. Вы можете снова выполнить его в любой момент с помощью запроса на **запуск индексатора** :

    POST https://myservice.search.windows.net/indexers/myindexer/run?api-version=2016-09-01
    api-key: admin-key

Вы можете настроить несколько аспектов поведения индексатора, например размер пакета и сколько документов можно пропустить, прежде чем выполнение индексатора завершится с ошибкой. Чтобы узнать больше, ознакомьтесь с [API создания индексатора](https://docs.microsoft.com/rest/api/searchservice/Create-Indexer).

Вам может потребоваться разрешить службам Azure подключаться к вашей базе данных. Сведения о том, как это сделать, см. в разделе [Подключение из Azure](https://docs.microsoft.com/azure/sql-database/sql-database-firewall-configure).

Для наблюдения за состоянием индексатора и журналом выполнения (количество проиндексированных элементов, ошибки и т. д.) используйте запрос на получение **состояния индексатора**:

    GET https://myservice.search.windows.net/indexers/myindexer/status?api-version=2016-09-01
    api-key: admin-key

Ответ должен выглядеть так:

    {
        "@odata.context":"https://myservice.search.windows.net/$metadata#Microsoft.Azure.Search.V2015_02_28.IndexerExecutionInfo",
        "status":"running",
        "lastResult": {
            "status":"success",
            "errorMessage":null,
            "startTime":"2015-02-21T00:23:24.957Z",
            "endTime":"2015-02-21T00:36:47.752Z",
            "errors":[],
            "itemsProcessed":1599501,
            "itemsFailed":0,
            "initialTrackingState":null,
            "finalTrackingState":null
        },
        "executionHistory":
        [
            {
                "status":"success",
                "errorMessage":null,
                "startTime":"2015-02-21T00:23:24.957Z",
                "endTime":"2015-02-21T00:36:47.752Z",
                "errors":[],
                "itemsProcessed":1599501,
                "itemsFailed":0,
                "initialTrackingState":null,
                "finalTrackingState":null
            },
            ... earlier history items
        ]
    }

Журнал выполнения включает до 50 записей о недавно завершенных запусках, которые сортируются в обратном хронологическом порядке (то есть в ответе первым отображается последний запуск).
Дополнительные сведения об ответе см. [здесь](http://go.microsoft.com/fwlink/p/?LinkId=528198).

## <a name="run-indexers-on-a-schedule"></a>Запуск индексаторов по расписанию
Вы также можете организовать запуск индикатора по расписанию. Для этого добавьте свойство **schedule** при создании или обновлении индексатора. В примере ниже показан PUT- запрос для обновления индексатора:

    PUT https://myservice.search.windows.net/indexers/myindexer?api-version=2016-09-01
    Content-Type: application/json
    api-key: admin-key

    {
        "dataSourceName" : "myazuresqldatasource",
        "targetIndexName" : "target index name",
        "schedule" : { "interval" : "PT10M", "startTime" : "2015-01-01T00:00:00Z" }
    }

Параметр **interval** обязателен. Он указывает время между двумя последовательными запусками индексатора. Наименьшее допустимое значение — 5 минут, наибольшее — один день. Значение должно быть отформатировано как значение dayTimeDuration XSD (ограниченное подмножество значения [продолжительности ISO 8601](http://www.w3.org/TR/xmlschema11-2/#dayTimeDuration) ). Используется следующий шаблон: `P(nD)(T(nH)(nM))`. Примеры: `PT15M` для каждых 15 минут, `PT2H` для каждых 2 часов.

Необязательный параметр **startTime** указывает время, когда должно начаться выполнение по расписанию. Если опустить этот параметр, используется текущее время в формате UTC. Это время может быть прошедшим. В таком случае первое выполнение планируется так, как если бы индексатор не прекращал работу со времени, указанного в параметре startTime.  

Одновременно можно выполнить только один запуск выбранного индексатора. Если во время запланированного выполнения индексатор уже работает, то выполнение откладывается до следующего запланированного времени.

Для большей ясности рассмотрим пример. Предположим, мы настроили следующее почасовое расписание:

    "schedule" : { "interval" : "PT1H", "startTime" : "2015-03-01T00:00:00Z" }

Происходит следующее:

1. Первый запуск индексатора выполняется 1 марта 2015 года ровно или приблизительно в 00:00. Время в формате UTC.
2. Предположим, выполнение займет 20 минут (или иное количество времени в пределах часа).
3. Второй запуск выполняется 1 марта 2015 года ровно или приблизительно в 01:00.
4. Теперь предположим, что выполнение занимает более часа (например, 70 минут) и завершается около 2:10.
5. На часах 02:00 — время для выполнения третьего запуска. Но так как с 01:00 выполняется еще второй запуск, третий запуск пропускается. Третье выполнение начинается в 03:00.

Вы можете добавить, изменить или удалить расписание для существующего индексатора с помощью **PUT-запроса для индексатора** .

<a name="CaptureChangedRows"></a>

## <a name="capture-new-changed-and-deleted-rows"></a>Запись новых, измененных и удаленных строк

Поиск Azure использует **добавочное индексирование** во избежание необходимости повторной индексации всей таблицы или представления при каждом запуске индексатора. Поиск Azure предоставляет две политики отслеживания изменений для поддержки добавочного индексирования. 

### <a name="sql-integrated-change-tracking-policy"></a>Интегрированная политика отслеживания изменений SQL
Если база данных SQL поддерживает [отслеживание изменений](https://docs.microsoft.com/sql/relational-databases/track-changes/about-change-tracking-sql-server), мы рекомендуем использовать **интегрированную политику отслеживания изменений SQL**. Это наиболее эффективная политика. Кроме того, она позволяет Поиску Azure выявлять удаленные строки без необходимости добавлять в таблицу отдельный столбец с информацией об обратимом удалении.

#### <a name="requirements"></a>Требования 

+ Требования к версии базы данных:
  * SQL Server 2012 SP3 и более поздних версий, если вы используете SQL Server на виртуальных машинах Azure.
  * База данных SQL Azure 12, если вы используете базу данных SQL Azure.
+ Только таблицы (представлений нет). 
+ В базе данных [включите отслеживание изменений](https://docs.microsoft.com/sql/relational-databases/track-changes/enable-and-disable-change-tracking-sql-server) таблицы. 
+ Нет составного первичного ключа (первичный ключ, содержащий более одного столбца) в таблице.  

#### <a name="usage"></a>Использование

Чтобы использовать эту политику, создайте или обновите источник данных следующим образом:

    {
        "name" : "myazuresqldatasource",
        "type" : "azuresql",
        "credentials" : { "connectionString" : "connection string" },
        "container" : { "name" : "table or view name" },
        "dataChangeDetectionPolicy" : {
           "@odata.type" : "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
      }
    }

При использовании интегрированной политики отслеживания изменений SQL не указывайте отдельную политику обнаружения удаления данных, так как она уже поддерживает выявление удаленных строк. Однако, чтобы автоматически обнаруживать удаления, ключ документа в индексе поиска должен быть таким же, что и основной ключ в таблице SQL. 

<a name="HighWaterMarkPolicy"></a>

### <a name="high-water-mark-change-detection-policy"></a>Политика обнаружения изменений максимального уровня

Политика обнаружения изменений зависит от столбца изменений максимального уровня, записывающего версию или время последнего обновления строки. При использовании представления следует использовать политику максимального уровня. Столбец максимального уровня должен соответствовать следующим требованиям.

#### <a name="requirements"></a>Требования 

* при каждой вставке указывается значение для столбца;
* при всех обновлениях элементов также изменяется значение столбца;
* значение этого столбца растет с каждой вставкой или обновлением;
* Возможно эффективное выполнение запросов со следующими предложениями WHERE и ORDER BY: `WHERE [High Water Mark Column] > [Current High Water Mark Value] ORDER BY [High Water Mark Column]`.

> [!IMPORTANT] 
> Настоятельно рекомендуется использовать тип данных [rowversion](https://docs.microsoft.com/sql/t-sql/data-types/rowversion-transact-sql) для столбца максимального уровня. В случае использования любого другого типа данных не гарантируется запись всех изменений при наличии транзакций, выполняемых параллельно с запросом индексатора. При использовании **rowversion** в конфигурации с репликами только для чтения необходимо указать индексатор на первичной реплике. Только первичная реплика может использоваться для сценариев синхронизации данных.

#### <a name="usage"></a>Использование

Чтобы использовать политику верхнего предела, создайте или обновите источник данных следующим образом.

    {
        "name" : "myazuresqldatasource",
        "type" : "azuresql",
        "credentials" : { "connectionString" : "connection string" },
        "container" : { "name" : "table or view name" },
        "dataChangeDetectionPolicy" : {
           "@odata.type" : "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy",
           "highWaterMarkColumnName" : "[a rowversion or last_updated column name]"
      }
    }

> [!WARNING]
> Если исходная таблица не имеет индекс для столбца верхнего предела, то время ожидания выполнения запросов, используемых индексатором SQL, может истечь. В частности, если таблица содержит много строк, то для эффективного выполнения предложения `ORDER BY [High Water Mark Column]` требуется индекс.
>
>

Если возникают ошибки времени ожидания, можно использовать параметр конфигурации индексатора `queryTimeout`, чтобы задать время ожидания запроса, превышающее время ожидания по умолчанию, равное 5 минутам. Например, чтобы задать время ожидания, равное 10 минутам, создайте или обновите индексатор, используя приведенную ниже конфигурацию.

    {
      ... other indexer definition properties
     "parameters" : {
            "configuration" : { "queryTimeout" : "00:10:00" } }
    }

Можно также отключить предложение `ORDER BY [High Water Mark Column]`. Однако это не рекомендуется, так как в случае прерывания выполнения индексатора из-за ошибки ему придется повторно обработать все строки при последующем запуске, даже если на момент прерывания почти все из них уже были обработаны. Чтобы отключить предложение `ORDER BY`, используйте параметр `disableOrderByHighWaterMarkColumn` в определении индексатора.  

    {
     ... other indexer definition properties
     "parameters" : {
            "configuration" : { "disableOrderByHighWaterMarkColumn" : true } }
    }

### <a name="soft-delete-column-deletion-detection-policy"></a>Политика обнаружения обратимого удаления столбца
Строки, удаляемые из исходной таблицы, вероятно, также следует удалить из индекса поиска. Если вы используете интегрированную политику отслеживания изменений SQL, это происходит автоматически. Однако политика отслеживания изменений максимального уровня не затрагивает удаленные строки. Что делать?

Если строки физически удалены из таблицы, то Поиску Azure не удастся определить присутствие уже несуществующих записей.  Тем не менее можно использовать метод обратимого удаления, чтобы логически удалять строки, не удаляя их из таблицы. Добавьте специальный столбец в таблицу или представление и помечайте удаленные строки с помощью этого столбца.

При использовании метода обратимого удаления можно указать соответствующую политику во время создания или обновления источника данных:

    {
        …,
        "dataDeletionDetectionPolicy" : {
           "@odata.type" : "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy",
           "softDeleteColumnName" : "[a column name]",
           "softDeleteMarkerValue" : "[the value that indicates that a row is deleted]"
        }
    }

Параметр **softDeleteMarkerValue** должен быть строкой. Используйте строковое представление действительного значения. Например, если имеется столбец целочисленных значений, в котором удаленные строки помечаются значением 1, то следует использовать `"1"`. Если имеется битовый столбец, в котором удаленные строки помечаются логическим значением true, то следует использовать `"True"`.

<a name="TypeMapping"></a>

## <a name="mapping-between-sql-and-azure-search-data-types"></a>Сопоставление типов данных SQL и Поиска Azure
| Тип данных SQL | Совместимые типы полей целевого индекса | Заметки |
| --- | --- | --- |
| bit |Edm.Boolean, Edm.String | |
| int, smallint, tinyint |Edm.Int32, Edm.Int64, Edm.String | |
| bigint |Edm.Int64, Edm.String | |
| real, float |Edm.Double, Edm.String | |
| smallmoney, money decimal numeric |Edm.String |Поиск Azure не поддерживает преобразование десятичных типов в Edm.Double, так как это отрицательно скажется на точности. |
| char, nchar, varchar, nvarchar |Edm.String<br/>Collection(Edm.String) |Для заполнения поля Collection(Edm.String) может использоваться строка SQL, если она представляет массив строк JSON: `["red", "white", "blue"]`. |
| smalldatetime, datetime, datetime2, date, datetimeoffset |Edm.DateTimeOffset, Edm.String | |
| uniqueidentifer |Edm.String | |
| geography |Edm.GeographyPoint |Поддерживаются только географические объекты типа POINT с SRID 4326 (значение по умолчанию). |
| rowversion |Недоступно |Столбцы версии строк не могут храниться в индексе поиска, но их можно использовать для отслеживания изменений. |
| time, timespan, binary, varbinary, image, xml, geometry, CLR types |Недоступно |Не поддерживается |

## <a name="configuration-settings"></a>Параметры конфигурации
Индексатор SQL предоставляет несколько параметров конфигурации.

| Параметр | Тип данных | Назначение | Значение по умолчанию |
| --- | --- | --- | --- |
| queryTimeout |строка |Задает время ожидания для выполнения запроса SQL. |5 мин ("00:05:00") |
| disableOrderByHighWaterMarkColumn |bool |Указывает SQL-запросу, используемому политикой верхнего предела, опустить предложение ORDER BY. Ознакомьтесь с [политикой верхнего предела](#HighWaterMarkPolicy). |false |

Эти параметры используются в объекте `parameters.configuration` в определении индексатора. Например, чтобы задать время ожидания запроса, равное 10 минутам, создайте или обновите индексатор, используя приведенную ниже конфигурацию.

    {
      ... other indexer definition properties
     "parameters" : {
            "configuration" : { "queryTimeout" : "00:10:00" } }
    }

## <a name="faq"></a>Часто задаваемые вопросы

**Вопрос. Можно ли использовать индексатор SQL Azure с базами данных SQL на виртуальных машинах IaaS в Azure?**

Да. Тем не менее необходимо разрешить службе поиска подключаться к базе данных. Дополнительные сведения см. в статье [Настройка подключения из индексатора Поиска Azure к SQL Server на виртуальной машине Azure](search-howto-connecting-azure-sql-iaas-to-azure-search-using-indexers.md).

**Вопрос. Можно ли использовать индексатор SQL Azure с локальными базами данных SQL?**

Не напрямую. Мы не рекомендуем и не поддерживаем прямое соединение, так как в таком случае вам придется открыть свои базы данных для интернет-трафика. Клиенты преуспели в этом сценарии, используя технологии моста, такие как фабрика данных Azure. Дополнительные сведения см. в статье [Передача данных в индекс Поиска Azure с использованием фабрики данных Azure](https://docs.microsoft.com/azure/data-factory/data-factory-azure-search-connector).

**Вопрос. Можно ли использовать индексатор SQL Azure с базами данных в IaaS в Azure помимо баз SQL Server?**

Нет. Мы не поддерживаем этот сценарий, так как мы не проверяли работу индексатора с базами данных не из SQL Server.  

**Вопрос. Можно ли создать несколько индексаторов, выполняющих обработку по расписанию?**

Да. Но на одном узле одновременно может выполнять обработку только один индексатор. Если вам требуется, чтобы одновременно работали несколько индексаторов, вы можете расширить службу поиска, добавив несколько модулей поиска.

**Вопрос. Влияет ли выполнение индексатора на рабочую нагрузку запросов?**

Да. Индексатор выполняется на одном из узлов службы поиска, и ресурсы этого узла распределяются между выполнением индексирования, обслуживанием трафика запросов и другими запросами API. Если при выполнении интенсивных рабочих нагрузок индексирования и запросов часто отображается ошибка 503 или увеличивается время ответа, вы можете [расширить службу поиска](search-capacity-planning.md).

**Вопрос. Можно ли использовать вторичную реплику в [отказоустойчивом кластере](https://docs.microsoft.com/azure/sql-database/sql-database-geo-replication-overview) в качестве источника данных?**

Здесь возможны варианты в зависимости от обстоятельств. Для полной индексации таблицы или представления можно использовать вторичные реплики. 

Для добавочного индексирования Поиск Azure поддерживает две политики отслеживания изменений: интегрированная политика отслеживания изменений SQL и политика обнаружения изменений максимального уровня.

В репликах только для чтения база данных SQL не поддерживает интегрированное отслеживание изменений. Таким образом необходимо использовать политику максимального уровня. 

Стандартно рекомендуется использовать тип данных rowversion для столбца максимального уровня. Однако использование rowversion зависит от функции `MIN_ACTIVE_ROWVERSION` базы данных SQL, которая не поддерживается репликами только для чтения. Таким образом необходимо направить индексатор на первичную реплику при использовании rowversion.

При попытке использовать rowversion с репликой только для чтения появится следующая ошибка: 

    "Using a rowversion column for change tracking is not supported on secondary (read-only) availability replicas. Please update the datasource and specify a connection to the primary availability replica.Current database 'Updateability' property is 'READ_ONLY'".

**Вопрос. Можно ли использовать другой столбец, не rowversion, для отслеживания изменений максимального уровня?**

Не рекомендуется. Только **rowversion** обеспечивает надежную синхронизацию данных. Но в зависимости от логики приложения это может быть безопасно, если:

+ Можно гарантировать, что при выполнении индекса в индексируемой таблице нет необработанных транзакций. Например, все обновления таблицы происходят пакетно по расписанию, а расписание индексатора Поиска Azure настроено избегать перекрытия с расписанием обновления таблицы.  

+ Вы периодически выполняете полное повторное индексирование, чтобы обнаружить все пропущенные строки. 
