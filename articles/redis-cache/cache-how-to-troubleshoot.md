---
title: Как устранять неполадки кэша Redis для Azure | Документация Майкрософт
description: Узнайте, как устранить самые распространенные проблемы с кэшем Redis для Azure
services: redis-cache
documentationcenter: ''
author: wesmc7777
manager: cfowler
editor: ''
ms.assetid: 928b9b9c-d64f-4252-884f-af7ba8309af6
ms.service: cache
ms.workload: tbd
ms.tgt_pltfrm: cache-redis
ms.devlang: na
ms.topic: article
ms.date: 01/06/2017
ms.author: wesmc
ms.openlocfilehash: e5f6f423697d90e889ebde2cd203891e34278b3c
ms.sourcegitcommit: eeb5daebf10564ec110a4e83874db0fb9f9f8061
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/03/2018
ms.locfileid: "28984577"
---
# <a name="how-to-troubleshoot-azure-redis-cache"></a>Способы устранения проблем с кэшем Redis для Azure
Эта статья содержит сведения об устранении следующих категорий проблем с кэшем Redis для Azure.

* [Устранение проблем на стороне клиента](#client-side-troubleshooting). В этом разделе представлены рекомендации по выявлению и устранению проблем, вызванных подключением приложения к серверу кэша Redis для Azure.
* [Устранение проблем на стороне сервера](#server-side-troubleshooting). В этом разделе представлены рекомендации по обнаружению и устранению проблем на сервере кэша Redis для Azure.
* [Исключения времени ожидания StackExchange.Redis](#stackexchangeredis-timeout-exceptions). В этом разделе содержатся сведения об устранении проблем при использовании клиента StackExchange.Redis.

> [!NOTE]
> Шаги по устранению проблем в этой статье также включают в себя указания по выполнению команд Redis и мониторингу различных метрик производительности. Дополнительные сведения и указания см. в разделе [Дополнительные сведения](#additional-information).
> 
> 

## <a name="client-side-troubleshooting"></a>Устранение неполадок на стороне клиента
В этом разделе рассматриваются способы устранения проблем, вызванных определенным условием в клиентском приложении.

* [Нехватка памяти на клиенте](#memory-pressure-on-the-client)
* [Увеличение трафика](#burst-of-traffic)
* [Высокий коэффициент загрузки ЦП клиента](#high-client-cpu-usage)
* [Превышение пропускной способности на стороне клиента](#client-side-bandwidth-exceeded)
* [Большой размер запроса или ответа](#large-requestresponse-size)
* [Что произошло с моими данными в Redis?](#what-happened-to-my-data-in-redis)

### <a name="memory-pressure-on-the-client"></a>Нехватка памяти на клиенте
#### <a name="problem"></a>Проблема
Нехватка памяти на клиентском компьютере служит причиной всевозможных проблем с производительностью, которые вызывают задержку обработки данных, отправленных с помощью экземпляра Redis без задержки. Как правило, при нехватке памяти система перемещает данные со страниц из физической памяти в виртуальную память на диске. Именно *ошибки страниц* существенно замедляют работу системы.

#### <a name="measurement"></a>Измерения
1. Проведите мониторинг использования памяти на компьютере, чтобы убедиться в том, что объем доступной памяти не превышен. 
2. Выполните мониторинг счетчика производительности `Page Faults/Sec`. В большинстве систем ошибки страниц возникают даже во время обычной работы. Понаблюдайте за пиками счетчика производительности ошибок страниц, которые соответствуют времени ожидания.

#### <a name="resolution"></a>Способы устранения:
Увеличьте размер клиентской виртуальной машины или измените шаблоны использования памяти, снизив потребление памяти.

### <a name="burst-of-traffic"></a>Увеличение трафика
#### <a name="problem"></a>Проблема
Увеличение трафика в сочетании с недостаточными параметрами `ThreadPool` может привести к возникновению задержек обработки данных, отправленных сервером Redis, но еще не использованных на стороне клиента.

#### <a name="measurement"></a>Измерения
Проведите мониторинг того, как со временем изменяется статистика `ThreadPool` , используя [такой код](https://github.com/JonCole/SampleCode/blob/master/ThreadPoolMonitor/ThreadPoolLogger.cs). Кроме того, можно просмотреть сообщение `TimeoutException` от StackExchange.Redis. Вот пример: 

    System.TimeoutException: Timeout performing EVAL, inst: 8, mgr: Inactive, queue: 0, qu: 0, qs: 0, qc: 0, wr: 0, wq: 0, in: 64221, ar: 0, 
    IOCP: (Busy=6,Free=999,Min=2,Max=1000), WORKER: (Busy=7,Free=8184,Min=2,Max=8191)

В примере сообщения выше следует обратить внимание на следующее:

1. Обратите внимание, что в разделах `IOCP` и `WORKER` значение `Busy` больше, чем значение `Min`. Это значит, что необходимо настроить параметры `ThreadPool`.
2. Кроме того, обратите внимание на `in: 64221`. Значение 64211 — это количество байт, отправленных на уровень сокета ядра, но еще не считанных приложением (например, StackExchange.Redis). Как правило, это значит, что приложение не успевает считывать весь объем данных, отправленных с сервера.

#### <a name="resolution"></a>Способы устранения:
Настройте [параметры пула потоков](https://gist.github.com/JonCole/e65411214030f0d823cb), чтобы обеспечить быстрое увеличение масштаба пула потоков при увеличении трафика.

### <a name="high-client-cpu-usage"></a>Высокий коэффициент загрузки ЦП клиента
#### <a name="problem"></a>Проблема
Высокий коэффициент загрузки ЦП клиента служит причиной того, что системе не удается справиться со всеми поставленными заданиями. Это означает, что, возможно, клиенту не удастся своевременно обработать ответ от Redis (даже если ответ отправлен очень быстро).

#### <a name="measurement"></a>Измерения
Выполните мониторинг загрузки ЦП для всей системы, используя портал Azure или связанный счетчик производительности. Не путайте ее с загрузкой ЦП *процесса* , так как коэффициент загрузки ЦП одного процесса может быть низким, а всей системы — высоким. Понаблюдайте за пиками загрузки ЦП, которые соответствуют времени ожидания. Результатом высокой загрузки ЦП могут быть высокие значения `in: XXX` в сообщениях об ошибке `TimeoutException`, как описано в разделе [Увеличение трафика](#burst-of-traffic).

> [!NOTE]
> В StackExchange.Redis 1.1.603 и более поздней версии в сообщениях об ошибках `TimeoutException` содержится метрика `local-cpu`. Убедитесь, что вы используете последнюю версию [пакета NuGet для StackExchange.Redis](https://www.nuget.org/packages/StackExchange.Redis/). Это важно, так как ошибки в коде постоянно исправляют, что позволяет обеспечить надежность в отношении времени ожидания.
> 
> 

#### <a name="resolution"></a>Способы устранения:
Увеличьте емкость ЦП виртуальной машины или выясните, что создает пики загрузки ЦП. 

### <a name="client-side-bandwidth-exceeded"></a>Превышение пропускной способности на стороне клиента
#### <a name="problem"></a>Проблема
В зависимости от архитектуры клиентских компьютеров на них применяются разные ограничения доступности пропускной способности сети. Если клиент превысит доступную пропускную способность, он не сможет обрабатывать весь объем данных сразу же после их отправки с сервера. Это может привести к превышению времени ожидания.

#### <a name="measurement"></a>Измерения
Проведите мониторинг того, как изменяется использование пропускной способности со временем, используя [такой код](https://github.com/JonCole/SampleCode/blob/master/BandWidthMonitor/BandwidthLogger.cs). В некоторых окружениях с ограниченными разрешениями (например, веб-сайты Azure) этот код может не удастся выполнить.

#### <a name="resolution"></a>Способы устранения:
Увеличьте размер виртуальной машины или уменьшите использование пропускной способности сети.

### <a name="large-requestresponse-size"></a>Большой размер запроса или ответа
#### <a name="problem"></a>Проблема
Из-за большого размера запроса или ответа может истекать время ожидания. В качестве примера предположим, что значение времени ожидания на клиентском компьютере — 1 секунда. Приложение одновременно запрашивает два ключа (например, А и Б) в одном физическом сетевом подключении. Большинство клиентов поддерживают конвейерный режим отправки запросов. Это означает, что запросы А и Б последовательно отправляются на сервер через физическое подключение, не ожидая получения ответов. Сервер отправляет ответы в том же порядке. Если ответ А достаточно большого размера, его обработка может занять большую часть времени ожидания, необходимого для выполнения следующих запросов. 

Этот сценарий показан в следующем примере. В этом сценарии запросы А и Б отправлены быстро, сервер быстро начал отправку ответов, но из-за длительного времени передачи данных ответ Б задержался после другого запроса и срок его ожидания истек, несмотря на то, что сервер быстро ответил.

    |-------- 1 Second Timeout (A)----------|
    |-Request A-|
         |-------- 1 Second Timeout (B) ----------|
         |-Request B-|
                |- Read Response A --------|
                                           |- Read Response B-| (**TIMEOUT**)



#### <a name="measurement"></a>Измерения
Запрос или ответ сложно измерить. По сути, вам нужно добавить в клиентский код инструменты для отслеживания запросов и ответов большого размера. 

#### <a name="resolution"></a>Способы устранения:
1. Redis оптимизирован для работы с большим количеством данных небольшого объема, а не с малым количеством данных большого объема. Поэтому рекомендуется разбить данные на небольшие связанные части. Дополнительные сведения о том, почему лучше использовать данные небольшого объема, см. в записи на форуме [What is the ideal value size range for redis? Is 100KB too large?](https://groups.google.com/forum/#!searchin/redis-db/size/redis-db/n7aa2A4DZDs/3OeEPHSQBAAJ) (Каков оптимальный размер данных для Redis? 100 КБ — это очень много?).
2. Увеличьте размер виртуальной машины (для клиента и сервера кэша Redis), чтобы увеличить пропускную способность и уменьшить время передачи данных для больших ответов. Увеличение пропускной способности только на сервере или только на клиенте не решит проблему. Измерьте использование пропускной способности и сравните его с возможностями, которые обеспечивает текущий размер вашей виртуальной машины.
3. Увеличьте количество используемых объектов `ConnectionMultiplexer` и запросов циклического перебора между подключениями.

### <a name="what-happened-to-my-data-in-redis"></a>Что произошло с моими данными в Redis?
#### <a name="problem"></a>Проблема
В экземпляре кэша Redis для Azure отсутствуют некоторые данные.

#### <a name="resolution"></a>Способы устранения:
Дополнительные сведения о возможных причинах и способах устранения проблемы см. в статье [What happened to my data in Redis?](https://gist.github.com/JonCole/b6354d92a2d51c141490f10142884ea4#file-whathappenedtomydatainredis-md) (Что произошло с моими данными в Redis?).

## <a name="server-side-troubleshooting"></a>Устранение проблем на стороне сервера
В этом разделе рассматриваются способы устранения проблем, вызванных определенным условием на сервере кэширования.

* [Нехватка памяти на сервере](#memory-pressure-on-the-server)
* [Высокий коэффициент загрузки ЦП и сервера](#high-cpu-usage-server-load)
* [Превышение пропускной способности на стороне сервера](#server-side-bandwidth-exceeded)

### <a name="memory-pressure-on-the-server"></a>Нехватка памяти на сервере
#### <a name="problem"></a>Проблема
Нехватка памяти на сервере кэширования служит причиной всевозможных проблем с производительностью, которые вызывают задержку обработки запросов. Как правило, при нехватке памяти система перемещает данные со страниц из физической памяти в виртуальную память на диске. Именно *ошибки страниц* существенно замедляют работу системы. Нехватка памяти может возникнуть по следующим причинам. 

1. Весь кэш заполнен данными. 
2. Чаще всего причиной высокой степени фрагментации памяти Redis является хранение больших объектов. (Redis оптимизирован для работы с небольшими объектами. Дополнительные сведения см. в записи форума [What is the ideal value size range for redis? Is 100KB too large?](https://groups.google.com/forum/#!searchin/redis-db/size/redis-db/n7aa2A4DZDs/3OeEPHSQBAAJ) (Каков оптимальный размер данных для Redis? 100 КБ — это очень много?). 

#### <a name="measurement"></a>Измерения
Redis предоставляет две метрики, с помощью которых можно определить проблемы: `used_memory` и `used_memory_rss`. [Эти метрики](cache-how-to-monitor.md#available-metrics-and-reporting-intervals) доступны на портале Azure. Или запустите команду [Redis INFO](http://redis.io/commands/info), чтобы получить их.

#### <a name="resolution"></a>Способы устранения:
Настроить оптимальное использование памяти можно несколькими способами.

1. [Настройте политику памяти](cache-configure.md#maxmemory-policy-and-maxmemory-reserved) и параметры времени завершения срока действия ключей. Этой конфигурации может быть недостаточно, если используется фрагментация.
2. [Настройте значение maxmemory-reserved](cache-configure.md#maxmemory-policy-and-maxmemory-reserved) , которого будет достаточно, чтобы компенсировать фрагментацию памяти.
3. Разбейте большие кэшированные объекты на меньшие связанные объекты.
4. [Увеличьте](cache-how-to-scale.md) размер кэша.
5. Если используется [кэш Redis (цен. категории "Премиум") со включенной кластеризацией](cache-how-to-premium-clustering.md), [увеличьте число сегментов](cache-how-to-premium-clustering.md#change-the-cluster-size-on-a-running-premium-cache).

### <a name="high-cpu-usage--server-load"></a>Высокий коэффициент загрузки ЦП и сервера
#### <a name="problem"></a>Проблема
Высокий коэффициент загрузки ЦП служит причиной того, что клиенту может не удаться своевременно обработать ответ от Redis (даже если ответ отправлен быстро).

#### <a name="measurement"></a>Измерения
Выполните мониторинг загрузки ЦП для всей системы, используя портал Azure или связанный счетчик производительности. Не путайте ее с загрузкой ЦП *процесса* , так как коэффициент загрузки ЦП одного процесса может быть низким, а всей системы — высоким. Понаблюдайте за пиками загрузки ЦП, которые соответствуют времени ожидания.

#### <a name="resolution"></a>Способы устранения:
* Ознакомьтесь со всеми рекомендациями и предупреждениями в разделе [Помощник по кэшу Redis](cache-configure.md#redis-cache-advisor).
* Также просмотрите другие рекомендации в этой статье и [рекомендации по использованию кэша Redis для Azure](https://gist.github.com/JonCole/925630df72be1351b21440625ff2671f), чтобы узнать, используете ли вы все параметры, чтобы оптимизировать кэш и клиент. 
* Просмотрите таблицы в разделе [Производительность кэша Redis для Azure](cache-faq.md#azure-redis-cache-performance), чтобы узнать, достигли ли вы порогового значения на текущем уровне. При необходимости [увеличьте](cache-how-to-scale.md) размер кэша и емкость ЦП. Если вы уже используете уровень "Премиум", возможно, нужно выполнить [горизонтальное масштабирование с использованием кластеризации](cache-how-to-premium-clustering.md)


### <a name="server-side-bandwidth-exceeded"></a>Превышение пропускной способности на стороне сервера
#### <a name="problem"></a>Проблема
В зависимости от размера экземпляров кэша на них применяются разные ограничения доступной пропускной способности сети. Если сервер превысит пропускную способность, уменьшится скорость передачи данных с сервера на клиентский компьютер. Это может привести к превышению времени ожидания.

#### <a name="measurement"></a>Измерения
Вы можете провести мониторинг значения метрики `Cache Read` , которая равна объему данных (в МБ/с), считанных из кэша за указанный интервал отчетности. Это значение соответствует пропускной способности сети для этого кэша. Если вы хотите настроить оповещения об ограничениях пропускной способности сети на стороне сервера, их можно создать с использованием счетчика `Cache Read`. Сравните полученные показатели со значениями в [этой таблице](cache-faq.md#cache-performance) , где приводятся наблюдаемые ограничения пропускной способности для различных ценовых категорий и размеров кэша.

#### <a name="resolution"></a>Способы устранения:
Если для вашей ценовой категории и размера кэша почти достигнуто максимальное ограничение пропускной способности, [измените](cache-how-to-scale.md) ценовую категорию или размер, чтобы увеличить пропускную способность, используя значения [этой таблицы](cache-faq.md#cache-performance) для справки.

## <a name="stackexchangeredis-timeout-exceptions"></a>Исключения времени ожидания StackExchange.Redis
Для синхронных операций со значением по умолчанию 1000 мс StackExchange.Redis использует параметр конфигурации `synctimeout`. Если синхронный вызов не завершается за установленное время, клиент StackExchange.Redis выводит ошибку времени ожидания, которая выглядит примерно так:

    System.TimeoutException: Timeout performing MGET 2728cc84-58ae-406b-8ec8-3f962419f641, inst: 1,mgr: Inactive, queue: 73, qu=6, qs=67, qc=0, wr=1/1, in=0/0 IOCP: (Busy=6, Free=999, Min=2,Max=1000), WORKER (Busy=7,Free=8184,Min=2,Max=8191)


В этом сообщении об ошибке содержатся метрики, которые помогут вам определить причину и возможное решение проблемы. В следующей таблице содержатся сведения о метриках сообщения об ошибке.

| Метрики сообщения об ошибке | Сведения |
| --- | --- |
| inst |Указывает, что за последний интервал времени инициировано 0 команд. |
| mgr |Диспетчер сокетов выполняет `socket.select`, а это значит, что он отправляет в ОС запрос на определение сокета, который должен выполнять какое-то действие. Как правило, модуль чтения не выполняет активное чтение из сети, так как он предполагает, что нет действий, которые необходимо выполнить. |
| очередь |Указывает, что выполняется 73 операции. |
| qu |Указывает, что 6 выполняемых операций находится в очереди неотправленных, и они еще не записаны в исходящую сеть. |
| qs |Указывает, что 67 выполняемых операций отправлено на сервер, но ответ еще не доступен. Ответ может быть таким: `Not yet sent by the server` или `sent by the server but not yet processed by the client.` |
| qc |Указывает, что для 0 выполняемых операций отправлены ответы, но операции не отмечены в качестве завершенных ожидания в цикле выполнения. |
| wr |Указывает, что есть bytes/activewriters активных модулей записи (6 неотправленных запросов не игнорируются). |
| больше |Указывает, что отсутствуют активные модули чтения и нет байтов для чтения для bytes/activereaders сетевой карты. |

### <a name="steps-to-investigate"></a>Действия для обнаружения проблем
1. Убедитесь, что для подключения к кэшу с помощью клиента StackExchange.Redis используется следующий шаблон.

    ```csharp
    private static Lazy<ConnectionMultiplexer> lazyConnection = new Lazy<ConnectionMultiplexer>(() =>
    {
        return ConnectionMultiplexer.Connect("cachename.redis.cache.windows.net,abortConnect=false,ssl=true,password=...");
    
    });
    
    public static ConnectionMultiplexer Connection
    {
        get
        {
            return lazyConnection.Value;
        }
    }
    ````

    Дополнительные сведения см. в разделе о [подключении к кэшу с использованием StackExchange.Redis](cache-dotnet-how-to-use-azure-redis-cache.md#connect-to-the-cache).

1. Убедитесь, что кэш Redis для Azure и клиентское приложение расположены в одном регионе Azure. Например, если кэш расположен в восточной части США, а клиент — в западной части США, то может истекать время ожидания выполнения запроса и для выполнения может быть недостаточно интервала `synctimeout`. Кроме того, время ожидания может истекать при отладке на локальном компьютере разработки. 
   
    Кэш и клиент настоятельно рекомендуется размещать в одном и том же регионе Azure. Если используются межрегиональные вызовы, необходимо увеличить значение интервала `synctimeout` по умолчанию (1000 мс), добавив в строку подключения свойство `synctimeout`. В следующем примере показан фрагмент строки подключения кэша StackExchange.Redis со значением 2000 мс для `synctimeout` .
   
        synctimeout=2000,cachename.redis.cache.windows.net,abortConnect=false,ssl=true,password=...
2. Убедитесь, что вы используете последнюю версию [пакета NuGet для StackExchange.Redis](https://www.nuget.org/packages/StackExchange.Redis/). Это важно, так как ошибки в коде постоянно исправляют, что позволяет обеспечить надежность в отношении времени ожидания.
3. Выполнение запросов, связанных с ограничением пропускной способности на сервере или клиенте, занимает больше времени, что приводит к превышению времени ожидания. Дополнительные сведения об истечении времени ожидания, связанном с сетевой пропускной способностью на сервере, см. в разделе [Превышение пропускной способности на стороне сервера](#server-side-bandwidth-exceeded). Дополнительные сведения о превышении времени ожидания, связанном с сетевой пропускной способностью клиента, см. в разделе [Превышение пропускной способности на стороне клиента](#client-side-bandwidth-exceeded).
4. Используются ли ресурсы ЦП на сервере или клиенте?
   
   * Проверьте, не вызвана ли нехватка времени на обработку запроса в разрешенный интервал времени `synctimeout` (что приводит к превышению времени ожидания) высоким коэффициентом загрузки ЦП на стороне клиента. Чтобы решить эту проблему, увеличьте размер клиента или распределите загрузку. 
   * Проверьте коэффициент загрузки ЦП на сервере, выполнив мониторинг [метрики производительности кэша](cache-how-to-monitor.md#available-metrics-and-reporting-intervals) `CPU`. Запросы, поступающие во время выполнения Redis операций, связанных с ЦП, могут вызывать возникновение времени ожидания. Чтобы устранить эту проблему, распределите нагрузку между несколькими сегментами в кэше (цен. категории "Премиум") либо используйте кэш большего размера или другой ценовой уровень. Дополнительные сведения см. в разделе [Превышение пропускной способности на стороне сервера](#server-side-bandwidth-exceeded).
5. Занимает ли выполнение команд на сервере слишком много времени? Выполнение длительных команд на сервере Redis может вызывать истечение времени ожидания. К этим командам относятся `mget` с большим количеством ключей, `keys *` или плохо написанные сценарии LUА. Чтобы проверить, выполняются ли некоторые запросы дольше чем необходимо, подключитесь к экземпляру кэша Redis для Azure с помощью клиента redis-cli или откройте [консоль Redis](cache-configure.md#redis-console) и выполните команду [SlowLog](http://redis.io/commands/slowlog). Сервер Redis и StackExchange.Redis оптимизированы для обработки большого количества небольших запросов, а не нескольких больших запросов. Чтобы повысить их производительность, рекомендуется разбить данные на небольшие фрагменты. 
   
    Дополнительные сведения о подключении к конечной точке SSL кэша Redis для Azure с помощью redis-cli и stunnel см. в записи блога [Announcing ASP.NET Session State Provider for Redis Preview Release](http://blogs.msdn.com/b/webdev/archive/2014/05/12/announcing-asp-net-session-state-provider-for-redis-preview-release.aspx) (Объявление поставщика состояний сеансов ASP.NET для предварительной версии Redis). Дополнительные сведения о команде SlowLog см. [здесь](http://redis.io/commands/slowlog).
6. Высокая загрузка сервера Redis может влечь истечение времени ожидания. Вы можете выполнить мониторинг значения загрузки сервера, измеряя [метрику производительности кэша](cache-how-to-monitor.md#available-metrics-and-reporting-intervals) `Redis Server Load`. Максимальное значение загрузки (100) указывает на то, что сервер слишком загружен обработкой запросов и не простаивает. Чтобы узнать, не использует ли сервер все свои ресурсы на определенные запросы, выполните команду SlowLog, как описано в предыдущем абзаце. Дополнительные сведения см. в разделе [Высокий коэффициент загрузки ЦП и сервера](#high-cpu-usage-server-load).
7. Происходили ли на клиенте другие события, для которых требовалось сетевое кэширование? Проверьте, не выполнялись ли на клиенте (в веб-роли, рабочей роли или на виртуальной машине IaaS) такие операции, как изменение числа экземпляров, развертывание новых версий клиента или включение автомасштабирования. Наше тестирование показало, что автомасштабирование или изменение масштаба может вызвать утрату сетевого подключения на несколько секунд. Код StackExchange.Redis устойчив к таким событиям и подключается повторно. Во время повторного подключения некоторые запросы в очереди могут простаивать.
8. Истекло ли время ожидания при выполнении большого запроса к кэшу Redis перед несколькими небольшими? Параметр `qs` в сообщении об ошибке указывает, сколько необработанных запросов отправлено с клиента на сервер. Это количество может увеличиваться, так как StackExchange.Redis использует одно подключение TCP, которое позволяет обрабатывать только один ответ за раз. Хотя время ожидания первой операции истекло, данные все равно поступают на сервер или с него, а другие запросы блокируются, пока выполняется большой запрос, что приводит к превышению времени ожидания. Чтобы решить эту проблему, рекомендуется снизить вероятность возникновения времени ожидания, увеличив размер кэша для рабочей нагрузки и разбив данные большого объема на небольшие фрагменты. Другое решение — использовать в клиенте пул объектов `ConnectionMultiplexer` и для отправки новых запросов применять наименее загруженный объект `ConnectionMultiplexer`. Это позволяет снизить вероятность того, что истечение времени ожидания одного запроса повлечет истечение времени ожидания других запросов.
9. Если вы используете `RedisSessionStateprovider`, не забудьте правильно установить время ожидания перед повтором попытки. Значение `retrytimeoutInMilliseconds` должно быть выше, чем `operationTimeoutinMilliseonds`, иначе попытки не повторяются. В следующем примере для `retrytimeoutInMilliseconds` задано значение 3000. Дополнительные сведения см. в статьях [Поставщик состояний сеансов ASP.NET для кэша Redis для Azure](cache-aspnet-session-state-provider.md) и [How to use configuration parameters of Session State Provider and Output Cache Provider](https://github.com/Azure/aspnet-redis-providers/wiki/Configuration) (Использование параметров конфигурации поставщика состояний сеанса и поставщика кэша вывода).

    <add
      name="AFRedisCacheSessionStateProvider"
      type="Microsoft.Web.Redis.RedisSessionStateProvider"
      host="enbwcache.redis.cache.windows.net"
      port="6380"
      accessKey="…"
      ssl="true"
      databaseId="0"
      applicationName="AFRedisCacheSessionState"
      connectionTimeoutInMilliseconds = "5000"
      operationTimeoutInMilliseconds = "1000"
      retryTimeoutInMilliseconds="3000" />


1. Проверяйте использование памяти на сервере кэша Redis для Azure, [отслеживая](cache-how-to-monitor.md#available-metrics-and-reporting-intervals) значения `Used Memory RSS` и `Used Memory`. Если используется политика вытеснения, Redis начнет вытеснять ключи, когда значение `Used_Memory` достигнет размера кэша. В идеале значение `Used Memory RSS` должно быть немного больше, чем значение `Used memory`. Большая разница между значениями означает фрагментацию памяти (внутренней или внешней). Если значение `Used Memory RSS` меньше значения `Used Memory`, это значит, что часть кэш-памяти используется операционной системой для подкачки. При этом могут возникать значительные задержки. Так как Redis не контролирует сопоставление распределений со станицами памяти, высокое значение `Used Memory RSS` зачастую является результатом увеличения использования памяти. Когда Redis освобождает память, она возвращается распределителю, который может вернуть или не вернуть память в систему. При этом операционная система может сообщать о расхождении между `Used Memory` и использованием памяти. Это связано с тем, что использованная и освобожденная Redis память не возвращена обратно в систему. Чтобы свести к минимуму проблемы с памятью, выполните следующие шаги:
   
   * Увеличьте размер кэша, чтобы предотвратить превышение ограничения объема используемой памяти в системе.
   * Задайте время истечения срока действия ключей, чтобы они вытеснялись заранее.
   * Отслеживайте метрику кэша `used_memory_rss`. Если это значение близко к значению размера кэша, скорее всего, появятся проблемы с производительностью. Если используется кэш (цен. категории "Премиум"), распределите данные по нескольким сегментам или увеличьте размер кэша.
   
   Дополнительные сведения см. в разделе [Нехватка памяти на сервере](#memory-pressure-on-the-server).

## <a name="additional-information"></a>Дополнительная информация
* [Какое предложение и размер кэша Redis мне следует использовать?](cache-faq.md#what-redis-cache-offering-and-size-should-i-use)
* [Как измерить и протестировать производительность моего кэша?](cache-faq.md#how-can-i-benchmark-and-test-the-performance-of-my-cache)
* [Как выполнять команды Redis?](cache-faq.md#how-can-i-run-redis-commands)
* [Как отслеживать кэш Redis для Azure](cache-how-to-monitor.md)

