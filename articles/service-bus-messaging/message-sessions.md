---
title: Сеансы обмена сообщениями служебной шины Azure | Документация Майкрософт
description: Обработка последовательностей сообщений служебной шины Azure с помощью сеансов.
services: service-bus-messaging
documentationcenter: ''
author: clemensv
manager: timlt
editor: ''
ms.service: service-bus-messaging
ms.workload: na
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 01/02/2018
ms.author: sethm
ms.openlocfilehash: 551432cd13c16fdd5423c46ed9c6f740353808f8
ms.sourcegitcommit: 48ab1b6526ce290316b9da4d18de00c77526a541
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/23/2018
ms.locfileid: "30181645"
---
# <a name="message-sessions-first-in-first-out-fifo"></a>Сеансы сообщений и обработка в порядке очереди (FIFO) 

Сеансы службы "Служебная шина Microsoft Azure" обеспечивают согласованную и упорядоченную обработку несвязанных последовательностей связанных сообщений. Чтобы реализовать надежный механизм FIFO в служебной шине, необходимо использовать сеансы. В служебной шине не регламентируется характер связи между сообщениями и не указывается конкретная модель, определяющая, где начинается или заканчивается последовательность сообщений.

Любой отправитель может создать сеанс при отправке сообщений в очередь или раздел, задав свойству [SessionId](/dotnet/api/microsoft.azure.servicebus.message.sessionid#Microsoft_Azure_ServiceBus_Message_SessionId) какой-либо определяемый приложением идентификатор, уникальный в рамках сеанса. На уровне протокола AMQP 1.0 это значение соответствует свойству *group-id*.

В очередях или подписках с поддержкой сеансов сеансы создаются при наличии по крайней мере одного сообщения, для которого указан [SessionId](/dotnet/api/microsoft.azure.servicebus.message.sessionid#Microsoft_Azure_ServiceBus_Message_SessionId) сеанса. Для созданного сеанса нет определенного интервала времени или API, определяющего его срок действия или существования. Теоретически, сообщение для сеанса может быть получено сегодня, а следующее — через год, и если значение **SessionId** совпадает, то с точки зрения служебной шины это тот же самый сеанс.

Обычно в приложении четко определено, где начинается и заканчивается набор связанных сообщений. Однако служебная шина не устанавливает какие-либо конкретные правила для этого.

Например, чтобы разграничить последовательность для передачи файла, можно задать для свойства **Label** первого сообщения значение **start**, для промежуточных сообщений задать для этого свойства значение **content**, а для последнего сообщения — значение **end**. Относительное положение сообщений с содержимым может быть вычислено как разница между значением *SequenceNumber* текущего сообщения и значением *SequenceNumber* сообщения **start**.

Функция сеансов в служебной шине позволяет выполнить специальную операцию получения посредством [MessageSession](/dotnet/api/microsoft.servicebus.messaging.messagesession) в интерфейсах API C# и Java. Для включения этой функции нужно задать свойство [requiresSession](/azure/templates/microsoft.servicebus/namespaces/queues#property-values) для очереди или подписки с помощью Azure Resource Manager или установить соответствующий флаг на портале. Это необходимо сделать прежде, чем пытаться использовать операции связанных API.

На портале флаг устанавливается с помощью следующего флажка:

![][2]

Интерфейсы API для сеансов существуют в клиентах очереди и подписки. Существует императивная модель, в которой вы управляете получением сеансов и сообщений, и модель на основе обработчика, например *OnMessage*, в которой сложность управления циклом получения скрыта.

## <a name="session-features"></a>Функции сеансов

Сеансы обеспечивают параллельное демультиплексирование потоков сообщений с сохранением и гарантией порядка доставки.

![][1]

Получатель [MessageSession](/dotnet/api/microsoft.servicebus.messaging.messagesession) создается клиентом, принимающим сеанс. Клиент вызывает [QueueClient.AcceptMessageSession](/dotnet/api/microsoft.servicebus.messaging.queueclient.acceptmessagesession#Microsoft_ServiceBus_Messaging_QueueClient_AcceptMessageSession) или [QueueClient.AcceptMessageSessionAsync](/dotnet/api/microsoft.servicebus.messaging.queueclient.acceptmessagesessionasync#Microsoft_ServiceBus_Messaging_QueueClient_AcceptMessageSessionAsync) в C#. В реактивной модели обратного вызова он регистрирует обработчик сеанса.

Когда объект [MessageSession](/dotnet/api/microsoft.servicebus.messaging.messagesession) принимается и хранится в клиенте, этот клиент накладывает монопольную блокировку на все сообщения со значением [SessionId](/en-us/dotnet/api/microsoft.servicebus.messaging.messagesession.sessionid#Microsoft_ServiceBus_Messaging_MessageSession_SessionId) этого сеанса, имеющиеся в очереди или подписке, а также на все сообщения с этим значением **SessionId**, которые продолжают поступать во время сеанса.

Блокировка снимается, когда вызывается функция **Close** или **CloseAsync**. Если же приложение не может выполнить операцию закрытия, блокировка снимается, когда истекает ее срок действия. Блокировка сеанса должна рассматриваться как монопольная блокировка файла. Это означает, что приложение должно закрыть сеанс, как только он стал не нужен и (или) оно не ожидает поступления новых сообщений.

Когда несколько параллельных получателей извлекают сообщения из очереди, сообщения, относящиеся к определенному сеансу, отправляются в конкретный получатель, который в настоящее время наложил блокировку для этого сеанса. Благодаря этой операции поток сообщений с чередованием, находящийся в одной очереди или подписке, четко демультиплексируется для различных получателей. Эти получатели могут находиться на разных клиентских компьютерах, так как управление блокировкой осуществляется на стороне службы, внутри служебной шины.

На предыдущем рисунке показано три параллельных приемника сеансов. У одного сеанса с `SessionId` = 4 нет активного владеющего клиента. Это означает, что сообщения не будут доставлены из этого конкретного сеанса. Сеанс работает по-разному, как и подчередь.

Блокировка сеанса, накладываемая получателем сеанса, — это "зонтик" для блокировки сообщений, используемый для режима согласования *PeekLock*. Получатель не может одновременно обработать два сообщения "на лету", но сообщения должны обрабатываться по порядку. Новое сообщение можно будет получить только после того, как предыдущее сообщение будет обработано или отправлено в очередь недоставленных сообщений. Если сообщение отбрасывается, то это же сообщение обслуживается повторно при следующей операции получения.

## <a name="message-session-state"></a>Состояние сеанса обмена сообщениями

При обработке рабочих процессов в крупномасштабных высокодоступных облачных системах обработчик рабочих процессов, связанный с определенным сеансом, должен обладать механизмами восстановления после непредвиденных сбоев, а также иметь возможность возобновлять частично выполненную работу в другом процессе или на другом компьютере.

Функция состояния сеанса позволяет добавлять определяемые приложением заметки для сеанса обмена сообщениями внутри брокера, чтобы записанное состояние обработки, относящееся к этому сеансу, становилось мгновенно доступным при получении этого сеанса новым обработчиком.

С точки зрения служебной шины состояние сеанса обмена сообщениями — непрозрачный двоичный объект, который может содержать данные, размер которых равен размеру одного сообщения, что составляет 256 КБ для служебной шины категории "Стандартный" и 1 МБ для служебной шины категории "Премиум". Состояние обработки относительно сеанса может сохраняться в состоянии сеанса, или состояние сеанса может указывать на некоторое место хранения либо запись базы данных, где содержатся эти сведения.

Интерфейсы API для управления состоянием сеанса, [SetState](/dotnet/api/microsoft.servicebus.messaging.messagesession.setstate#Microsoft_ServiceBus_Messaging_MessageSession_SetState_System_IO_Stream_) и [GetState](/dotnet/api/microsoft.servicebus.messaging.messagesession.getstate#Microsoft_ServiceBus_Messaging_MessageSession_GetState), можно найти в объекте [MessageSession](/dotnet/api/microsoft.servicebus.messaging.messagesession) в интерфейсах API C# и Java. Сеанс, для которого ранее не было задано состояние сеанса, возвращает в интерфейс API **GetState** **пустую** ссылку. Очистка заданного ранее состояния сеанса выполняется с помощью [SetState(null)](/dotnet/api/microsoft.servicebus.messaging.messagesession.setstate#Microsoft_ServiceBus_Messaging_MessageSession_SetState_System_IO_Stream_).

Обратите внимание, что состояние сеанса не изменяется до очистки (возвращается значение **NULL**), даже если потреблены все сообщения в сеансе.

Все существующие сеансы в очереди или подписке могут быть перечислены с помощью метода **SessionBrowser** в интерфейсе API Java и с помощью метода [GetMessageSessions](/dotnet/api/microsoft.servicebus.messaging.queueclient.getmessagesessions#Microsoft_ServiceBus_Messaging_QueueClient_GetMessageSessions) в интерфейсах API [QueueClient](/dotnet/api/microsoft.azure.servicebus.queueclient) и [SubscriptionClient](/dotnet/api/microsoft.azure.servicebus.subscriptionclient) в клиенте .NET.

Состояние сеанса, хранящееся в очереди или подписке, учитывается при подсчете квоты хранилища этой сущности. Поэтому, когда приложение завершает работу с сеансом, рекомендуется очищать его сохраненное состояние, чтобы избежать затрат на внешнее управление.

## <a name="next-steps"></a>Дополнительная информация

- [Полный пример](https://github.com/Azure/azure-service-bus/tree/master/samples/DotNet/GettingStarted/Microsoft.Azure.ServiceBus/BasicSendReceiveUsingQueueClient) отправки и получения сообщений на основе сеанса через очереди служебной шины с помощью библиотеки .NET Standard.
- [Пример](https://github.com/Azure/azure-service-bus/tree/master/samples/DotNet/Microsoft.ServiceBus.Messaging/Sessions), использующий клиент .NET Framework для обработки сообщений с поддержкой сеансов. 

Дополнительные сведения об обмене сообщениями через служебную шину см. в следующих статьях:

* [Базовая информация о служебной шине](service-bus-fundamentals-hybrid-solutions.md)
* [Очереди, разделы и подписки служебной шины](service-bus-queues-topics-subscriptions.md)
* [Начало работы с очередями служебной шины](service-bus-dotnet-get-started-with-queues.md)
* [Как использовать разделы и подписки служебной шины](service-bus-dotnet-how-to-use-topics-subscriptions.md)

[1]: ./media/message-sessions/sessions.png
[2]: ./media/message-sessions/queue-sessions.png