---
title: Руководство по использованию протокола AMQP 1.0 в служебной шине и концентраторах событий Azure | Документация Майкрософт
description: Руководство по использованию протоколов, в котором рассматривается выражение и описание протокола AMQP 1.0 в служебной шине и концентраторах событий Azure
services: service-bus-messaging,event-hubs
documentationcenter: .net
author: clemensv
manager: timlt
editor: ''
ms.assetid: d2d3d540-8760-426a-ad10-d5128ce0ae24
ms.service: service-bus-messaging
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 04/30/2018
ms.author: clemensv
ms.openlocfilehash: e124ea3f932a81634191785e7ee69c2492cb32fa
ms.sourcegitcommit: 6e43006c88d5e1b9461e65a73b8888340077e8a2
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/01/2018
ms.locfileid: "32312548"
---
# <a name="amqp-10-in-azure-service-bus-and-event-hubs-protocol-guide"></a>Руководство по использованию протокола AMQP 1.0 в служебной шине и концентраторах событий Azure

Улучшенный протокол очередей сообщений (AMQP) 1.0 — это стандартный протокол кадрирования и передачи, который обеспечивает асинхронную безопасную и надежную передачу сообщений между двумя сторонами. Это основной протокол, применяемый для обмена сообщениями служебной шины Azure и концентраторов событий Azure. Обе службы также поддерживают протокол HTTPS. Защищаемый протокол SBMP, который также поддерживается, постепенно вытесняется в пользу протокола AMQP.

Протокол AMQP 1.0 — это результат совместной работы в разных отраслях, которая объединила таких производителей ПО промежуточного слоя, как корпорация Майкрософт и Red Hat, с большим количеством пользователей ПО промежуточного слоя для обмена сообщениями, например компанией JP Morgan Chase, представляющей собой индустрию финансовых услуг. На форуме OASIS по технической стандартизации официально утверждено, что спецификации протокола и расширения AMQP соответствуют международному стандарту ISO/IEC 19494.

## <a name="goals"></a>Цели

В этой статье кратко представлены основные понятия спецификации обмена сообщениями по протоколу AMQP 1.0, а также небольшой набор спецификаций черновых расширений, которые дорабатываются в техническом комитете OASIS по AMQP. Здесь также объясняется, как служебная шина Azure реализует и использует эти спецификации.

Цель заключается в том, чтобы все разработчики, использующие любой имеющийся стек клиента AMQP 1.0 на любой платформе, могли взаимодействовать со служебной шиной Azure через протокол AMQP 1.0.

Распространенные стеки общего назначения AMQP 1.0, например Apache Proton или AMQP.NET Lite, уже реализуют все основные протоколы AMQP 1.0. Для этих базовых жестов иногда в качестве оболочки используется API более высокого уровня. В Apache Proton предусмотрены два API: императивный API Messenger и реактивный API Reactor.

Далее предполагается, что управление подключениями, сеансами и связями AMQP, а также обработка передачи кадров и управление потоком осуществляются с помощью соответствующего стека (например, Apache Proton-C) и для этого не требуется особое внимание со стороны разработчиков приложений. Кроме того, абстрактно предполагается, что доступны несколько примитивных возможностей API, например возможность подключения и создания абстрактных объектов *отправителя* (sender) и *получателя* (receiver), которые затем приобретают форму операций `send()` и `receive()` соответственно.

Расширенные возможности служебной шины Azure, например просмотр сообщений или управление сеансами, описываются в контексте AMQP, а также как многоуровневая псевдореализация на базе этой предполагаемой абстракции API.

## <a name="what-is-amqp"></a>Что такое AMQP?

AMQP — это протокол передачи и кадрирования. Под кадрированием подразумевается предоставление структуры для потоков двоичных данных, которые передаются в любом направлении в рамках сетевого подключения. Структура разграничивает отдельные блоки данных, именуемые *кадрами*, которые передаются между сторонами подключения. Возможности передачи предусматривают, что обе взаимодействующие стороны могут узнать время передачи и завершения передачи кадров.

В отличие от более ранних черновых версий с истекшим сроком действия, созданных рабочей группой AMQP, которые все еще используют несколько брокеров сообщений, окончательная версия стандартизированного протокола AMQP 1.0 не предусматривает наличие брокера сообщений или какой-либо определенной топологии для объектов внутри этого брокера.

Протокол можно использовать для симметричного однорангового обмена данными и взаимодействия с брокерами сообщений, поддерживающими очереди и объекты публикаций и подписок, например со служебной шиной Azure. Его можно также использовать для взаимодействия с инфраструктурой обмена сообщениями, в которой шаблоны взаимодействия отличаются от обычных очередей, как в случае с концентраторами событий Azure. При получении событий концентратор событий выполняет роль очереди, но когда события считываются из него, он действует скорее как служба последовательного хранения. Это отчасти напоминает ленточный накопитель. Клиент выбирает смещение в доступном потоке данных, а затем обрабатывает все события, начиная с этого смещения до последнего доступного.

Протокол AMQP 1.0 предусматривает возможность расширения, то есть его возможности можно дополнить с помощью новых спецификаций. Три спецификации расширения, которые рассмотрены в этом документе, иллюстрируют это. Для обмена данными через имеющуюся инфраструктуру HTTPS или WebSockets, когда настройка собственных TCP-портов по протоколу AMQP может быть очень сложной, спецификация привязки определяет способ наложения протокола AMQP поверх инфраструктуры WebSockets. Чтобы обеспечить взаимодействие с инфраструктурой обмена сообщениями в режиме "запрос — ответ" для управления или предоставления дополнительных функций, спецификация управления AMQP определяет основные примитивные возможности взаимодействия. Для интеграции модели федеративной авторизации спецификация AMQP с безопасностью на основе утверждений определяет способ связывания и обновления маркеров авторизации, сопоставленных со связями.

## <a name="basic-amqp-scenarios"></a>Основные сценарии использования протокола AMQP

В этом разделе описываются основные сценарии использования протокола AMQP 1.0 со служебной шиной Azure, в частности создание подключений, сеансов и связей, а также передача сообщений в сущности служебной шины (очереди, разделы, подписки) и из них.

Самый авторитетный источник сведений о принципах работы протокола AMQP — спецификация AMQP 1.0. Но эта спецификация представляет собой руководство по реализации, а не по использованию протокола. В этом разделе рассматриваются все термины, необходимые для описания использования протокола AMQP 1.0 в служебной шине. Дополнительные сведения о протоколе AMQP, а также подробный обзор протокола AMQP 1.0 представлены в [этом видеокурсе][this video course].

### <a name="connections-and-sessions"></a>Подключения и сеансы

AMQP вызывает *контейнеры* взаимодействующих программ. В них содержатся *узлы*, которые являются взаимодействующими объектами внутри этих контейнеров. Таким узлом может выступать очередь. Протокол AMQP предусматривает мультиплексирование, что позволяет использовать одно подключение для многих путей передачи данных между узлами. Например, клиент приложения может одновременно получать данные из одной очереди и отправлять их в другую очередь через одно и то же сетевое подключение.

![][1]

Таким образом, сетевое подключение привязывается к контейнеру. Его инициирует контейнер в роли клиента. При этом устанавливается исходящее подключение TCP через сокет к контейнеру в роли получателя, который ожидает передачи данных и принимает входящие подключения TCP. Подтверждение подключения включает в себя согласование версии протокола, объявление или согласование использования безопасности транспортного уровня (TLS/SSL) и подтверждение проверки подлинности или авторизации на уровне подключения, основанном на SASL.

Для служебной шины Azure обязательно использование TLS. Он поддерживает подключения через TCP-порт 5671, когда перед вводом подтверждения протокола AMQP на подключение TCP сначала накладывается TLS, а также подключения через TCP-порт 5672, когда сервер незамедлительно предлагает обязательные обновления подключения к TLS с использованием модели, предписанной AMQP. Привязка AMQP WebSockets создает туннель через TCP-порт 443, что эквивалентно подключениям по протоколу AMQP 5671.

После настройки подключения и TLS в служебной шине применяется один из двух вариантов механизма SASL.

* SASL PLAIN, как правило, используется для передачи имени пользователя и пароля на сервер. В служебной шине нет учетных записей, но есть связанные с ключом именованные [правила безопасности общего доступа](service-bus-sas.md), которые присваивают права. Имя правила используется в качестве имени пользователя, а ключ (текст в кодировке Base64) — в качестве пароля. Права, связанные с выбранным правилом, определяют операции, разрешенные для подключения.
* SASL ANONYMOUS используется для обхода авторизации SASL, когда клиент хочет использовать модель безопасности на основе утверждений (CBS), которая описана далее в этой статье. Используя этот вариант, подключение клиента можно установить анонимно на короткий период времени, в течение которого он может взаимодействовать только с конечной точкой CBS. При этом необходимо выполнить подтверждение CBS.

После установки транспортного подключения каждый контейнер объявляет максимальный размер кадра, который он готов обработать, и время ожидания простоя, по истечении которого он в одностороннем порядке отключится, если подключение будет неактивно.

Они также объявляют количество поддерживаемых параллельных каналов. Канал — это однонаправленный исходящий виртуальный путь передачи на основе подключения. Сеанс принимает канал из каждого из взаимосвязанных контейнеров для формирования двустороннего пути обмена данными.

В сеансах предусмотрена модель управления потоком на основе окна. После создания сеанса каждая сторона объявляет количество кадров, которое она готова принять в окне получения. Пока стороны обмениваются кадрами, передаваемые кадры заполняют окно. После заполнения окна передача прекращается и возобновляется только после сброса или развертывания окна с помощью *перформатива потока* (*перформатив* — это термин AMQP, обозначающий жесты на уровне протокола, передаваемые между двумя сторонами).

Эта модель на основе окна является приблизительным аналогом концепции TCP управления потоком на основе окна, но на уровне сеанса в сокете. Благодаря поддержке нескольких параллельных сеансов в рамках протокола регулируемый обычный трафик может сменяться трафиком с высоким приоритетом, как на полосе дорожного движения.

Сейчас в служебной шине Azure для каждого подключения используется только один сеанс. Максимальный размер кадра служебной шины — 262 144 байта (256 КБ) для служебной шины уровня Standard и концентраторов событий. Для служебной шины уровня Premium он составляет 1 048 576 (1 МБ). В служебной шине не установлены определенные окна регулирования на уровне сеанса, но предусмотрен регулярный сброс окна в рамках управления потоком на уровне связи (см. [следующий раздел](#links)).

Подключения, каналы и сеансы являются временными. Если базовое подключение прерывается, подключения, туннель TLS, контекст авторизации SASL и сеансы необходимо установить заново.

### <a name="links"></a>Ссылки

AMQP обеспечивает передачу сообщений через связи. Связь — это созданный в рамках сеанса путь передачи, который позволяет передавать сообщения в одном направлении. Согласование состояния передачи выполняется через связь и является двусторонним между сторонами подключения.

![][2]

Связи могут создаваться в контейнерах в любое время в рамках активного сеанса, что отличает протокол AMQP от многих других протоколов, включая HTTP и MQTT, где инициирование передачи и путь передачи является привилегией стороны, которая создает подключение через сокет.

Контейнер, инициирующий связь, отправляет в противоположный контейнер запрос на принятие связи и выбирает роль отправителя или получателя. Таким образом, контейнер может инициировать создание односторонних или двусторонних путей передачи, которые моделируются в виде пары связей.

У связей есть имена, и они сопоставлены с узлами. Как уже говорилось в начале, узлы являются взаимодействующими объектами внутри контейнера.

В служебной шине понятие узла напрямую соответствует очереди, разделу, подписке или подочереди недоставленных сообщений в очереди или подписке. Имя узла, используемое в AMQP, — это относительное имя объекта в пространстве имен служебной шины. Имя очереди (например, **myqueue**) является также именем узла AMQP этой очереди. Подписка на раздел соответствует условиям соглашения HTTP API, так как она относится к коллекции ресурсов "подписки". Следовательно, для подписки **sub** из раздела **mytopic** имя узла AMQP будет иметь значение **mytopic/subscriptions/sub**.

Для создания связей подключающийся клиент должен использовать имя локального узла. Служебная шина не предписывает использование этих имен узлов и не интерпретирует их. В стеках клиента AMQP 1.0, как правило, используется схема, в соответствии с которой эти временные имена узлов являются уникальными в области клиента.

### <a name="transfers"></a>Передачи

Как только связь будет установлена, через нее можно передавать сообщения. В AMQP передача выполняется с помощью жеста явного протокола (перформатив *передачи*), который перемещает сообщение отправителя к получателю через связь. Передача завершается после "сопоставления", то есть когда обе стороны узнали результат этой передачи.

![][3]

В самом простом случае отправитель может отправлять сообщения "предварительно сопоставленными". Это означает, что клиент не заинтересован в результатах и получатель не предоставляет отчет о результатах операции. Этот режим поддерживается служебной шиной на уровне протокола AMQP, но не представлен ни в одном из клиентских API-интерфейсов.

В обычном случае сообщения отправляются несопоставленными, а затем получатель принимает или отклоняет их с помощью перформатива *обработки*. Сообщения отклоняются, когда получатель не может принять их по какой-либо причине. В этом случае в сообщении об отклонении содержатся сведения о причине, которой является структура ошибки, определенная AMQP. Если сообщения отклоняются из-за внутренних ошибок в служебной шине, служба возвращает дополнительные сведения в этой структуре. Эти сведения можно предоставлять в качестве подсказок для диагностики в службу технической поддержки при заполнении запросов на поддержку. Дополнительные сведения об ошибках приведены далее.

Состояние *released* (освобождено) — это особая форма отклонения, которая означает, что у получателя не возникает технических проблем в связи с передачей, но он не заинтересован в ее сопоставлении. Такое бывает, например, когда сообщение доставляется клиенту служебной шины, который отклоняет это сообщение по причине того, что не может выполнить работу, возникающую в результате обработки сообщения, то есть сама по себе доставка сообщения выполняется без ошибок. Вариант этого состояния — состояние *modified* (изменено), которое позволяет вносить изменения в сообщение, когда оно освобождается. Это состояние сейчас не используется в служебной шине.

Спецификация AMQP 1.0 определяет дополнительное состояние обработки — *received* (получено). Это состояние особенно удобно для обработки восстановления связей. Таким образом можно восстановить состояние связи и ожидающие доставки на основе нового подключения и сеанса, если предыдущее подключение и сеанс потеряны.

В служебной шине не поддерживается восстановление связей. Если клиент теряет подключение к служебной шине и несопоставленная передача сообщения переходит в режим ожидания, эта передача сообщения теряется и клиенту необходимо повторно установить подключение, восстановить связь и повторить попытку передачи.

Таким образом, служебная шина и концентраторы событий поддерживают передачи "как минимум один раз", при которых отправитель может быть уверен, что сообщения приняты и сохранены. Но на уровне AMQP не поддерживаются передачи "ровно один раз", при которых система пытается восстановить связь и согласовать состояние доставки, чтобы не дублировать передачу сообщений.

Чтобы компенсировать возможные повторные отправки, служебная шина может выявлять повторы в очередях и разделах. Эту функцию нужно активировать дополнительно. Этот механизм фиксирует идентификаторы всех входящих сообщений за определенный пользователем период времени и автоматически удаляет все сообщения, идентификаторы которых уже встречались в течение этого периода.

### <a name="flow-control"></a>Управление потоком

В дополнение к модели управления потоком на уровне сеанса, которая уже обсуждалась ранее, каждая связь предусматривает свою собственную модель управления потоком. Благодаря управлению потоком на уровне сеанса контейнеру не приходится обрабатывать слишком много кадров за раз. Благодаря управлению потоком на уровне связей приложение определяет количество поступающих через связь сообщений, которые оно может обработать, а также время обработки.

![][4]

Передачи через связь могут произойти, только если у отправителя достаточно *разрешений на передачу*. Разрешения на передачу — это счетчик, устанавливаемый получателем с помощью перформатива *потока*, предусмотренного для связи. Если у отправителя есть разрешения на передачу, он будет стараться использовать все эти разрешения на отправку сообщений. Каждая доставка сообщения уменьшает доступное количество разрешений на передачу на 1. После использования всех разрешений на передачу доставки прекращаются.

Когда служебная шина выполняет роль получателя, она незамедлительно предоставляет отправителю достаточное количество разрешений на передачу. Таким образом, сообщения можно отправлять сразу. По мере использования разрешений на передачу служебная шина периодически отправляет отправителю перформатив *потока*, чтобы обновить остаток разрешений на передачу.

Выполняя роль отправителя, служебная шина отправляет сообщения, чтобы использовать все оставшиеся разрешения на передачу.

Вызов получения на уровне API преобразуется в перформатив *потока*, который клиент отправляет в служебную шину. Служебная шина расходует эти разрешения, забирая из очереди первое доступное и не заблокированное сообщение, блокируя его и передавая получателю. Если сообщений, доступных для доставки, нет, все неиспользованные разрешения для всех связей с конкретными объектами сохраняются в порядке поступления. Пока остаются доступные разрешения, все поступающие сообщения будут сразу же блокироваться и передаваться.

Блокировка сообщения снимается, когда передача переходит в одно из конечных состояний: *accepted* (принято), *rejected* (отклонено) или *released* (освобождено). Сообщение удаляется из служебной шины, если передача переходит в конечное состояние *accepted* (принято). Оно остается в служебной шине и будет доставлено следующему получателю, когда передача перейдет в любое другое состояние. Служебная шина автоматически переместит сообщение в очередь недоставленных сообщений объекта, когда будет достигнуто максимальное число доставок, разрешенное для объекта из-за повторяющихся отклонений или освобождений.

В интерфейсах API служебной шины такая возможность сейчас не предоставляется напрямую. Несмотря на это клиент протокола AMQP нижнего уровня может использовать модель разрешений на передачу, чтобы сменить взаимодействие с извлечением, при котором выдается одно разрешение для каждого запроса на получение, на модель с отправлением, при которой выдается большое количество разрешений на передачу. Это позволяет получать сообщения сразу, как только они станут доступными, без дополнительных согласований. Поддержка модели с отправлением зависит от значения свойства [MessagingFactory.PrefetchCount](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_PrefetchCount) или [MessageReceiver.PrefetchCount](/dotnet/api/microsoft.servicebus.messaging.messagereceiver#Microsoft_ServiceBus_Messaging_MessageReceiver_PrefetchCount). Если их значения отличны от нуля, клиент AMQP использует их в качестве разрешений на передачу.

В этом контексте важно понимать, что срок действия блокировки сообщения внутри объекта начинается с того момента, когда сообщение извлекается из объекта, а не когда сообщение поступает в сеть. Каждый раз, когда клиент указывает о готовности к приему сообщений путем выдачи разрешений на передачу, ожидается, что он может активно получать сообщения через сеть и готов их обрабатывать. В противном случае срок действия блокировки сообщения может истечь еще до доставки сообщения. Использование управления потоком разрешений на передачу должно непосредственно отображать немедленную готовность к работе с доступными сообщениями, отправляемыми получателю.

В следующих разделах предоставляется схематический обзор потока перформатива во время взаимодействия различных API. В каждом разделе описывается отдельная логическая операция. Некоторые из этих взаимодействий могут быть "ленивыми", то есть выполняться только по требованию. Сетевое взаимодействие не всегда возникает в результате создания отправителя сообщения. Оно возникает при отправлении или запросе первого сообщения.

Стрелки в следующей таблице указывают направление потока перформатива.

#### <a name="create-message-receiver"></a>Создание получателя сообщения

| Клиент | Служебная шина Azure |
| --- | --- |
| --> attach(<br/>name={имя ссылки},<br/>handle={числовой дескриптор},<br/>role=**receiver**,<br/>source={имя сущности},<br/>target={идентификатор связи клиента}<br/>) |Клиент подключается к объекту в качестве получателя |
| Служебная шина подключает конец его связи |<-- attach(<br/>name={имя ссылки},<br/>handle={числовой дескриптор},<br/>role=**sender**,<br/>source={имя сущности},<br/>target={идентификатор связи клиента}<br/>) |

#### <a name="create-message-sender"></a>Создание отправителя сообщения

| Клиент | Служебная шина Azure |
| --- | --- |
| --> attach(<br/>name={имя ссылки},<br/>handle={числовой дескриптор},<br/>role=**sender**,<br/>source={идентификатор связи клиента},<br/>target={имя сущности}<br/>) |Нет действий |
| Нет действий |<-- attach(<br/>name={имя ссылки},<br/>handle={числовой дескриптор},<br/>role=**receiver**,<br/>source={идентификатор связи клиента},<br/>target={имя сущности}<br/>) |

#### <a name="create-message-sender-error"></a>Создание отправителя сообщения (ошибка)

| Клиент | Служебная шина Azure |
| --- | --- |
| --> attach(<br/>name={имя ссылки},<br/>handle={числовой дескриптор},<br/>role=**sender**,<br/>source={идентификатор связи клиента},<br/>target={имя сущности}<br/>) |Нет действий |
| Нет действий |<-- attach(<br/>name={имя ссылки},<br/>handle={числовой дескриптор},<br/>role=**receiver**,<br/>source=null,<br/>target=null<br/>)<br/><br/><-- detach(<br/>handle={числовой дескриптор},<br/>closed=**true**,<br/>error={сведения об ошибке}<br/>) |

#### <a name="close-message-receiversender"></a>Закрытие получателя или отправителя сообщений

| Клиент | Служебная шина Azure |
| --- | --- |
| --> detach(<br/>handle={числовой дескриптор},<br/>closed=**true**<br/>) |Нет действий |
| Нет действий |<-- detach(<br/>handle={числовой дескриптор},<br/>closed=**true**<br/>) |

#### <a name="send-success"></a>Отправка (успешно)

| Клиент | Служебная шина Azure |
| --- | --- |
| --> transfer(<br/>delivery-id={числовой дескриптор},<br/>delivery-tag={двоичный дескриптор},<br/>settled=**false**,,more=**false**,<br/>state=**null**,<br/>resume=**false**<br/>) |Нет действий |
| Нет действий |<-- disposition(<br/>role=receiver,<br/>first={идентификатор доставки},<br/>last={идентификатор доставки},<br/>settled=**true**,<br/>state=**accepted**<br/>) |

#### <a name="send-error"></a>Отправка (ошибка)

| Клиент | Служебная шина Azure |
| --- | --- |
| --> transfer(<br/>delivery-id={числовой дескриптор},<br/>delivery-tag={двоичный дескриптор},<br/>settled=**false**,,more=**false**,<br/>state=**null**,<br/>resume=**false**<br/>) |Нет действий |
| Нет действий |<-- disposition(<br/>role=receiver,<br/>first={идентификатор доставки},<br/>last={идентификатор доставки},<br/>settled=**true**,<br/>state=**rejected**(<br/>error={сведения об ошибке}<br/>)<br/>) |

#### <a name="receive"></a>Получение

| Клиент | Служебная шина Azure |
| --- | --- |
| --> flow(<br/>link-credit=1<br/>) |Нет действий |
| Нет действий |< transfer(<br/>delivery-id={числовой дескриптор},<br/>delivery-tag={двоичный дескриптор},<br/>settled=**false**,<br/>more=**false**,<br/>state=**null**,<br/>resume=**false**<br/>) |
| --> disposition(<br/>role=**receiver**,<br/>first={идентификатор доставки},<br/>last={идентификатор доставки},<br/>settled=**true**,<br/>state=**accepted**<br/>) |Нет действий |

#### <a name="multi-message-receive"></a>Получение нескольких сообщений

| Клиент | Служебная шина Azure |
| --- | --- |
| --> flow(<br/>link-credit=3<br/>) |Нет действий |
| Нет действий |< transfer(<br/>delivery-id={числовой дескриптор},<br/>delivery-tag={двоичный дескриптор},<br/>settled=**false**,<br/>more=**false**,<br/>state=**null**,<br/>resume=**false**<br/>) |
| Нет действий |< transfer(<br/>delivery-id={числовой дескриптор+1},<br/>delivery-tag={двоичный дескриптор},<br/>settled=**false**,<br/>more=**false**,<br/>state=**null**,<br/>resume=**false**<br/>) |
| Нет действий |< transfer(<br/>delivery-id={числовой дескриптор+2},<br/>delivery-tag={двоичный дескриптор},<br/>settled=**false**,<br/>more=**false**,<br/>state=**null**,<br/>resume=**false**<br/>) |
| --> disposition(<br/>role=receiver,<br/>first={идентификатор доставки},<br/>last={идентификатор доставки+2},<br/>settled=**true**,<br/>state=**accepted**<br/>) |Нет действий |

### <a name="messages"></a>Сообщения

В следующих разделах объясняется, какие свойства из стандартных разделов сообщений AMQP использует служебная шина, и как они соотносятся с набором API служебной шины.

Любое свойство, которое требуется определить приложению, следует сопоставить с сопоставлением `application-properties` AMQP.

#### <a name="header"></a>Верхний колонтитул

| Имя поля | Использование | Имя API |
| --- | --- | --- |
| durable |- |- |
| priority |- |- |
| ttl |Срок жизни сообщения |[TimeToLive](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_TimeToLive) |
| first-acquirer |- |- |
| delivery-count |- |[DeliveryCount](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_DeliveryCount) |

#### <a name="properties"></a>properties

| Имя поля | Использование | Имя API |
| --- | --- | --- |
| message-id |Определяемый приложением идентификатор свободной формы для этого сообщения. Используется для обнаружения дубликатов. |[MessageId](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_MessageId) |
| user-id |Определяемый приложением идентификатор пользователя, который не интерпретируется служебной шиной. |Недоступно через API служебной шины. |
| значение |Определяемый приложением идентификатор назначения, который не интерпретируется служебной шиной. |[To](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_To) |
| subject |Определяемый приложением идентификатор назначения сообщения, который не интерпретируется служебной шиной. |[Label](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Label) |
| reply-to |Определяемый приложением индикатор пути ответа, который не интерпретируется служебной шиной. |[ReplyTo](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_ReplyTo) |
| correlation-id |Определяемый приложением идентификатор корреляции, который не интерпретируется служебной шиной. |[CorrelationId](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_CorrelationId) |
| content-type |Определяемый приложением индикатор типа содержимого, который не интерпретируется служебной шиной. |[ContentType](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_ContentType) |
| content-encoding |Определяемый приложением индикатор кодирования содержимого, который не интерпретируется служебной шиной. |Недоступно через API служебной шины. |
| absolute-expiry-time |Объявляет абсолютное время истечения срока действия сообщения. Игнорируется во входных данных (отмечается значение TTL заголовка), учитывается в выходных данных. |[ExpiresAtUtc](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_ExpiresAtUtc) |
| creation-time |Объявляет время создания сообщения. Не используется служебной шиной. |Недоступно через API служебной шины. |
| group-id |Определяемый приложением идентификатор связанного набора сообщений. Используется для сеансов служебной шины. |[SessionId](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_SessionId) |
| group-sequence |Счетчик, определяющий относительный порядковый номер сообщения в сеансе. Игнорируется служебной шиной. |Недоступно через API служебной шины. |
| reply-to-group-id |- |[ReplyToSessionId](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_ReplyToSessionId) |

#### <a name="message-annotations"></a>Заметки к сообщениям

Существует несколько других свойств сообщений служебной шины, которые не считаются свойствами сообщений AMQP и передаются как `MessageAnnotations` в сообщении.

| Ключ сопоставления заметки | Использование | Имя API |
| --- | --- | --- |
| x-opt-scheduled-enqueue-time | Объявляет, в какое время сообщение должно появиться в сущности. |[ScheduledEnqueueTime](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage.scheduledenqueuetimeutc?view=azure-dotnet) |
| x-opt-partition-key | Определяемый приложением ключ, который указывает, в какой раздел должно попасть сообщение. | [PartitionKey](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage.partitionkey?view=azure-dotnet) |
| x-opt-via-partition-key | Определяемое приложением значение ключа раздела в случае, когда используется транзакция для отправки сообщений через очередь передачи. | [ViaPartitionKey](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage.viapartitionkey?view=azure-dotnet) |
| x-opt-enqueued-time | Определяемое службой время в формате UTC, представляющее собой фактическое время постановки сообщения в очередь. Игнорируется во входных данных. | [EnqueuedTimeUtc](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage.enqueuedtimeutc?view=azure-dotnet) |
| x-opt-sequence-number | Определяемый службой уникальный номер, назначенный сообщению. | [SequenceNumber](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage.sequencenumber?view=azure-dotnet) |
| x-opt-offset | Определяемый службой порядковый номер постановки сообщения в очередь. | [EnqueuedSequenceNumber](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage.enqueuedsequencenumber?view=azure-dotnet) |
| x-opt-locked-until | Определяется службой. Дата и время, до которых сообщение будет заблокировано в очереди или подписке. | [LockedUntilUtc](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage.lockeduntilutc?view=azure-dotnet) |
| x-opt-deadletter-source | Определяется службой. Источник исходного сообщения, если сообщение получено из очереди недоставленных сообщений. | [DeadLetterSource](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage.deadlettersource?view=azure-dotnet) |

### <a name="transaction-capability"></a>Возможность транзакций

Транзакция объединяет две или более операций в область выполнения. По своей природе такая транзакция должна обеспечивать либо успешное, либо неудачное выполнение всех относящихся к данной группе операций.
Операции группируются по идентификатору `txn-id`.

Для транзакционного взаимодействия клиент действует как `transaction controller`, контролируя операции, которые должны быть сгруппированы вместе. Служба "Служебная шина" выступает в качестве `transactional resource` и выполняет задачи, которые запрашивает `transaction controller`.

Клиент и служба взаимодействуют через `control link`, что устанавливается клиентом. Сообщения `declare` и `discharge` отправляются контроллером по каналу управления для выделения и завершения транзакций соответственно (они не определяют границ для работы с транзакциями). Фактическая отправка или получение по этому каналу не осуществляются. Каждая запрашиваемая транзакционная операция явным образом определяется по нужному `txn-id` и поэтому может появляться в любом канале подключения. Если канал управления закроется, несмотря на созданные им неразгруженные транзакции, все такие транзакции немедленно откатываются, и попытки выполнить дальнейшую работу с ними приведут к ошибке. Сообщения по каналу управления не должны предварительно согласовываться.

Каждое подключение должно инициировать собственный канал управления, чтобы получить возможность запускать и завершать транзакции. Служба определяет специальный целевой объект, который функционирует как `coordinator`. Клиент или контроллер устанавливает канал управления для этого целевого объекта. Канал управления находится за границами сущности. Это значит, что один и тот же канал управления можно использовать для запуска и разгрузки транзакций для нескольких сущностей.

#### <a name="starting-a-transaction"></a>Запуск транзакции

Чтобы начать работу с транзакциями, контроллер должен получить `txn-id` от координатора. Для этого он отправляет сообщения с типом `declare`. Если объявление выполнено успешно, координатор отправляет в ответ результаты обработки сообщения `declared` с назначенным `txn-id`.

| Клиент (контроллер) | | Служебная шина (координатор) |
| --- | --- | --- |
| attach(<br/>name={имя ссылки},<br/>... ,<br/>role=**sender**,<br/>target=**Coordinator**<br/>) | ------> |  |
|  | <------ | attach(<br/>name={имя ссылки},<br/>... ,<br/>target=Coordinator()<br/>) |
| transfer(<br/>delivery-id=0, ...)<br/>{ AmqpValue (**Declare()**)}| ------> |  |
|  | <------ | disposition( <br/> first=0, last=0, <br/>state=**Declared**(<br/>**txn-id**={transaction id}<br/>)|

#### <a name="discharging-a-transaction"></a>Разгрузка транзакций

Контроллер завершает работу с транзакциями, отправляя координатору сообщение `discharge`. Контроллер указывает, что он собирается зафиксировать или откатить работу с транзакциями, устанавливая флаг `fail` в тексте сообщения о разгрузке. Если координатору не удается завершить разгрузку, сообщение отклоняется с результатом, который содержит `transaction-error`.

> Примечание. Значечние fail=true означает откат транзакции, а fail=false — фиксацию.

| Клиент (контроллер) | | Служебная шина (координатор) |
| --- | --- | --- |
| transfer(<br/>delivery-id=0, ...)<br/>{ AmqpValue (Declare())}| ------> |  |
|  | <------ | disposition( <br/> first=0, last=0, <br/>state=Declared(<br/>txn-id={transaction id}<br/>)|
| | . . . <br/>Работа с транзакциями<br/>на других каналах<br/> . . . |
| transfer(<br/>delivery-id=57, ...)<br/>{ AmqpValue (<br/>**Discharge(txn-id=0,<br/>fail=false)**)}| ------> |  |
| | <------ | disposition( <br/> first=57, last=57, <br/>state=**Accepted()**)|

#### <a name="sending-a-message-in-a-transaction"></a>Отправка сообщения в транзакции

Вся транзакционные операции выполняются с состоянием доставки транзакции `transactional-state`, которое содержит txn-id. При отправке сообщений состояние транзакции (transactional-state) передается кадром передачи сообщения. 

| Клиент (контроллер) | | Служебная шина (координатор) |
| --- | --- | --- |
| transfer(<br/>delivery-id=0, ...)<br/>{ AmqpValue (Declare())}| ------> |  |
|  | <------ | disposition( <br/> first=0, last=0, <br/>state=Declared(<br/>txn-id={transaction id}<br/>)|
| transfer(<br/>handle=1,<br/>delivery-id=1, <br/>**state=<br/>TransactionalState(<br/>txn-id=0)**)<br/>{ полезная нагрузка }| ------> |  |
| | <------ | disposition( <br/> first=1, last=1, <br/>state=**TransactionalState(<br/>txn-id=0,<br/>outcome=Accepted()**))|

#### <a name="disposing-a-message-in-a-transaction"></a>Обработка сообщения в транзакции

Обработка сообщения предусматривает такие операции, как `Complete` / `Abandon` / `DeadLetter` / `Defer`. Для выполнения этих операций в рамках транзакции передайте `transactional-state` с помощью перформатива обработки.

| Клиент (контроллер) | | Служебная шина (координатор) |
| --- | --- | --- |
| transfer(<br/>delivery-id=0, ...)<br/>{ AmqpValue (Declare())}| ------> |  |
|  | <------ | disposition( <br/> first=0, last=0, <br/>state=Declared(<br/>txn-id={transaction id}<br/>)|
| | <------ |transfer(<br/>handle=2,<br/>delivery-id=11, <br/>state=null)<br/>{ полезная нагрузка }|  
| disposition( <br/> first=11, last=11, <br/>state=**TransactionalState(<br/>txn-id=0,<br/>outcome=Accepted()**))| ------> |


## <a name="advanced-service-bus-capabilities"></a>Расширенные возможности служебной шины

В этом разделе рассматриваются расширенные возможности служебной шины Azure, основанные на черновых расширениях AMQP, которые сейчас разрабатываются в техническом комитете OASIS для AMQP. Служебная шина реализует последнюю версию этих черновиков и внедряет внесенные изменения, как только эти черновики переходят в состояние стандартных.

> [!NOTE]
> Дополнительные операции обмена сообщениями служебной шины поддерживаются с помощью шаблона "запрос — ответ". Дополнительные сведения об этих операциях см. в статье [AMQP 1.0 в служебной шине Microsoft Azure: операции c запросами и ответами](service-bus-amqp-request-response.md).
> 
> 

### <a name="amqp-management"></a>Управление AMQP

Спецификация управления AMQP — это первое черновое расширение, рассмотренное в этой статье. Эта спецификация определяет набор протоколов, расположенных над уровнем протокола AMQP, которые позволяют выполнять взаимодействия по управлению с инфраструктурой обмена сообщениями по протоколу AMQP. Спецификация определяет такие универсальные операции, как *создание*, *чтение*, *обновление* и *удаление*, для управления объектами в инфраструктуре обмена сообщениями, а также набор операций запросов.

Для всех этих жестов требуется взаимодействие "запрос — ответ" между клиентом и инфраструктурой обмена сообщениями. Поэтому спецификация определяет реализацию этого шаблона взаимодействия поверх AMQP: клиент подключается к инфраструктуре обмена сообщениями, инициирует сеанс, а затем создает пару связей. В одной связи клиент выступает в роли отправителя, а в другой — в качестве получателя, тем самым создавая пару связей, которая может выполнять роль двустороннего канала.

| Логическая операция | Клиент | Служебная шина Azure |
| --- | --- | --- |
| Создание пути "запрос-ответ" |--> attach(<br/>name={*имя связи*},<br/>handle={*числовой дескриптор*},<br/>role=**sender**,<br/>source=**null**,<br/>target=”myentity/$management”<br/>) |Нет действий |
| Создание пути "запрос-ответ" |Нет действий |\<-- attach(<br/>name={*имя связи*},<br/>handle={*числовой дескриптор*},<br/>role=**receiver**,<br/>source=null,<br/>target=”myentity”<br/>) |
| Создание пути "запрос-ответ" |--> attach(<br/>name={*имя связи*},<br/>handle={*числовой дескриптор*},<br/>role=**receiver**,<br/>source=”myentity/$management”,<br/>target=”myclient$id”<br/>) | |
| Создание пути "запрос-ответ" |Нет действий |\<-- attach(<br/>name={*имя связи*},<br/>handle={*числовой дескриптор*},<br/>role=**sender**,<br/>source=”myentity”,<br/>target=”myclient$id”<br/>) |

При наличии этой пары связей реализация модели "запрос — ответ" выполняется очень просто: запросом считается сообщение, отправленное в объект в инфраструктуре обмена сообщениями, которая поддерживает эту модель. В этом запросе-сообщении для поля *reply-to* в разделе *properties* установлен *целевой* идентификатор для связи, через которую отправляется ответ. Объект обработки обрабатывает запрос и предоставляет ответ через связь, *целевой* идентификатор которой соответствует указанному идентификатору в поле *reply-to*.

Для шаблона требуется, чтобы контейнер клиента и созданный клиентом идентификатор для назначения ответа были уникальными среди всех клиентов. Кроме того, по соображениям безопасности его должно быть сложно предугадать.

Операции обмена сообщениями, используемые для протокола управления и всех остальных протоколов, в которых используется один и тот же шаблон, происходят на уровне приложения. Они не определяют новые жесты на уровне протокола AMQP. Это сделано намеренно, чтобы приложения могли сразу применять эти расширения с совместимыми стеками AMQP 1.0.

В служебной шине пока не реализованы основные функции спецификации управления, но шаблон "запрос — ответ", определенный в этой спецификации, крайне важен для функции безопасности на основе утверждений и почти для всех расширенных возможностей, которые рассматриваются в следующих разделах.

### <a name="claims-based-authorization"></a>Авторизация на основе утверждений

Черновик спецификации для авторизации на основе утверждений (CBS) в AMQP основан на шаблоне "запрос — ответ" спецификации управления и описывает обобщенную модель использования маркеров федеративной безопасности с протоколом AMQP.

Модель безопасности AMQP по умолчанию, описанная во введении, основана на SASL и интегрируется при помощи подтверждения подключения AMQP. При использовании SASL предоставляется расширяемая модель, для которой определен набор механизмов. Любой протокол, в котором используется SASL, может использовать этот набор. К этим механизмам относятся следующие: PLAIN для передачи имен пользователей и паролей, EXTERNAL для привязки к безопасности на уровне TLS, ANONYMOUS для выражения отсутствия явной проверки подлинности или авторизации и широкий набор дополнительных механизмов, позволяющих передавать учетные данные или маркеры для проверки подлинности и (или) авторизации.

Интеграция SASL в протоколе AMQP имеет два недостатка:

* Все учетные данные и маркеры ограничены подключением. Инфраструктура обмена сообщениями может предоставлять дифференцированный контроль доступа на основе объектов, например разрешить носителю маркера отправлять сообщения в очередь A, а не в очередь Б. Если контекст авторизации привязан к подключению, нельзя использовать одно и то же подключение с разными маркерами доступа для очередей А и Б.
* Как правило, маркеры доступа действительны в течение ограниченного периода времени. Пользователю приходится периодически повторно получать маркеры. Это позволяет поставщику маркеров отклонить выдачу нового маркера, если изменятся разрешения пользователя на доступ. Подключения AMQP могут быть действительными в течение продолжительного периода времени. Модель SASL предоставляет возможность задать маркер только во время подключения. Это означает, что инфраструктура обмена сообщениями должна либо отключить клиент по истечении срока действия маркера, либо принять риск продолжительного обмена данными с клиентом, в течение которого права доступа клиента могут быть отозваны.

Спецификация CBS AMQP, реализуемая служебной шиной, элегантно обходит обе эти проблемы: клиент может связать маркеры доступа с каждым узлом и обновить их до истечения срока действия, не прерывая поток сообщений.

CBS определяет виртуальный узел управления *$cbs*, который должна предоставить инфраструктура обмена сообщениями. Узел управления принимает маркеры от имени других узлов в инфраструктуре обмена сообщениями.

Жест протокола — это обмен данными по типу "запрос-ответ", как определено в спецификации управления. Это означает, что клиент устанавливает пару связей с узлом *$cbs*, а затем передает запрос в исходящую связь, после чего ожидает ответа во входящей связи.

Сообщение запроса обладает следующими свойствами приложения.

| Ключ | Необязательно | Тип значения | Содержимое значения |
| --- | --- | --- | --- |
| операция |Нет  |строка |**put-token** |
| Тип |Нет  |строка |Тип размещаемого маркера. |
| name |Нет  |строка |"Аудитория", к которой относится маркер. |
| expiration |Yes |timestamp |Время окончания срока действия маркера. |

Свойство *name* определяет объект, с которым необходимо связать маркер. В служебной шине это путь к очереди, разделу или подписке. Свойство *type* определяет тип маркера:

| Тип маркера | Описание маркера | Тип текста | Заметки |
| --- | --- | --- | --- |
| amqp:jwt |JSON Web Token (JWT) |Значение AMQP (строка) |Пока недоступно. |
| amqp:swt |Простой веб-маркер (SWT) |Значение AMQP (строка) |Поддерживается только для маркеров SWT, выданных AAD или ACS |
| servicebus.windows.net:sastoken |Маркер SAS служебной шины |Значение AMQP (строка) |- |

Маркеры предоставляют права. Служебная шина распознает три основных вида прав: право "Отправление" позволяет отправлять, право "Прослушивание" — принимать, а право "Управление" — управлять объектами. Маркеры SWT, выданные AAD или ACS, явно включают в себя эти права в качестве утверждений. Маркеры SAS служебной шины ссылаются на правила, настроенные в пространстве имен или объекте, и эти правила настраиваются с помощью этих прав. Таким образом, если подписать маркер с помощью ключа, связанного с этим правилом, он предоставит соответствующие права. Маркер, связанный с объектом с помощью *put-token*, позволит подключенному клиенту взаимодействовать с объектом, используя права маркера. Для связи, в которой клиент принимает роль *отправителя*, требуются права на отправку, а для роли *получателя* — права на прослушивание.

Для сообщения ответа предусмотрены следующие значения *свойств приложения*.

| Ключ | Необязательно | Тип значения | Содержимое значения |
| --- | --- | --- | --- |
| status-code |Нет  |int |Код ответа HTTP **[RFC2616]**. |
| status-description |Yes |строка |Описание состояния. |

Клиент может вызвать запрос *put-token* несколько раз для любого объекта в инфраструктуре обмена сообщениями. Маркеры ограничиваются текущим клиентом и привязываются к текущему подключению. Это означает, что сервер удаляет хранимые маркеры после разрыва подключения.

Текущая реализация служебной шины предусматривает использование CBS только в сочетании с методом SASL ANONYMOUS. Подключение SSL/TLS всегда необходимо устанавливать до подтверждения SASL.

Таким образом, выбранный клиент AMQP 1.0 должен поддерживать механизм ANONYMOUS. Анонимный доступ означает, что при подтверждении первого подключения и создании первого сеанса в служебную шину не поступают сведения о том, кто устанавливает подключение.

После установки подключения и создания сеанса единственными допустимыми операциями являются подключение связей к узлу *$cbs* и отправка запроса *put-token*. Для определенного узла объекта в течение 20 секунд после установки подключения необходимо задать допустимый маркер с помощью запроса *put-token*. В противном случае служебная шина разорвет подключение в одностороннем порядке.

После этого клиент отвечает за отслеживание срока действия маркеров. По истечении срока действия маркера служебная шина незамедлительно разрывает все связи с соответствующим объектом. Чтобы избежать этого, клиент может в любое время заменить маркер для узла новым маркером через виртуальный узел управления *$cbs* с помощью того же запроса *put-token*, при этом не препятствуя трафику полезных данных, который поступает в разных связях.

### <a name="send-via-functionality"></a>Функция отправки через посредника

[Отправка через посредника / передача отправителя](service-bus-transactions.md#transfers-and-send-via) — это функция, позволяющая служебной шине перенаправлять заданное сообщение к сущности назначения через другую сущность. В основном это используется для выполнения операций между сущностями в единой транзакции.

С помощью данной функции вы создаете отправителя и устанавливаете канал связи с `via-entity`. При установлении канала передаются дополнительные сведения для установления истинного назначения сообщений/передач по этому каналу. После успешного присоединения все сообщения, отправленные по этому каналу, будут автоматически перенаправляться к *сущности назначения* через *промежуточную сущность*. 

> Примечание. Перед установлением этого канала необходимо выполнить проверку подлинности как для *промежуточной сущности*, так и для *сущности назначения*.

| Клиент | | Служебная шина Azure |
| --- | --- | --- |
| attach(<br/>name={имя ссылки},<br/>role=sender,<br/>source={идентификатор связи клиента},<br/>target=**{промежуточная-сущность}**,<br/>**properties=map [(<br/>com.microsoft:transfer-destination-address=<br/>{сущность-назначения} )]** ) | ------> | |
| | <------ | attach(<br/>name={имя ссылки},<br/>role=receiver,<br/>source={идентификатор связи клиента},<br/>target={промежуточная-сущность},<br/>properties=map [(<br/>com.microsoft:transfer-destination-address=<br/>{сущность-назначения} )] ) |

## <a name="next-steps"></a>Дополнительная информация

Дополнительные сведения об AMQP см. в следующих статьях:

* [Протокол AMQP служебной шины — обзор]
* [Поддержка AMQP 1.0 для секционированных очередей и разделов служебной шины]
* [Протокол AMQP служебной шины для Windows Server]

[this video course]: https://www.youtube.com/playlist?list=PLmE4bZU0qx-wAP02i0I7PJWvDWoCytEjD
[1]: ./media/service-bus-amqp-protocol-guide/amqp1.png
[2]: ./media/service-bus-amqp-protocol-guide/amqp2.png
[3]: ./media/service-bus-amqp-protocol-guide/amqp3.png
[4]: ./media/service-bus-amqp-protocol-guide/amqp4.png

[Протокол AMQP служебной шины — обзор]: service-bus-amqp-overview.md
[Поддержка AMQP 1.0 для секционированных очередей и разделов служебной шины]: service-bus-partitioned-queues-and-topics-amqp-overview.md
[Протокол AMQP служебной шины для Windows Server]: https://msdn.microsoft.com/library/dn574799.aspx
