---
title: Передача, блокировка и согласование сообщений служебной шины Azure | Документация Майкрософт
description: Общие сведения об операциях передачи и согласования сообщений служебной шины.
services: service-bus-messaging
documentationcenter: ''
author: clemensv
manager: timlt
editor: ''
ms.service: service-bus-messaging
ms.workload: na
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 01/25/2018
ms.author: sethm
ms.openlocfilehash: 4789da3c84d52b2615bf4250a36093a74154e1d4
ms.sourcegitcommit: ded74961ef7d1df2ef8ffbcd13eeea0f4aaa3219
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/29/2018
ms.locfileid: "28199038"
---
# <a name="message-transfers-locks-and-settlement"></a>Передача, блокировка и согласование сообщений

Одной из основных возможностей брокера обмена сообщениями, в том числе служебной шины, является прием сообщений в очередь или раздел и их хранение для последующего извлечения. *Отправка* — это термин, который широко применяется для передачи сообщения в брокер обмена сообщениями. *Получение* — это термин, который широко применяется для передачи сообщения в получающий клиент.

Когда клиент отправляет сообщение, обычно он хочет знать, было ли оно правильно передано и принято брокером, или же произошли какие-либо ошибки. Это подтверждение или неподтверждение передачи позволяет согласовать представление клиента и брокера о состоянии передачи сообщения, поэтому оно называется *согласованием*.

Точно так же, когда брокер передает сообщение клиенту, брокеру и клиенту требуется определить, было ли сообщение успешно обработано и можно ли его удалить, или же доставить и обработать сообщение не удалось, и поэтому его нужно доставить повторно.

## <a name="settling-send-operations"></a>Согласование операций отправки

При использовании любого поддерживаемого клиента API служебной шины операции отправки в служебную шину всегда согласовываются явным образом. Это значит, что операция API ожидает результата приема из служебной шины, и только после его получения выполняет операцию отправки.

Если сообщение отклоняется служебной шиной, то данные отклонения содержат индикатор ошибки и текст с идентификатором трассировки. Эти данные также содержат сведения о том, можно ли повторить операцию с какой-либо вероятностью успеха. В клиенте эти сведения преобразуются в исключение, передаваемое вызывающей стороне операции отправки. Если сообщение принято, операция завершается автоматически.

При использовании протокола AMQP, который принудительно используется клиентом .NET Standard и клиентом Java, а также [может использоваться клиентом .NET Framework](service-bus-amqp-dotnet.md), передача и согласование сообщение обрабатывается посредством конвейера полностью в асинхронном режиме, и рекомендуется использовать API для асинхронной модели программирования.

Отправитель может быстро передать несколько сообщений по сети в течение короткого промежутка времени без ожидания подтверждения каждого сообщения, что имело бы место в случае с протоколом SBMP или HTTP 1.1. Эти асинхронные операции отправки считаются выполненными, когда соответствующие сообщения принимаются и сохраняются в секционированных сущностях или когда совмещаются операции отправки в разные сущности. Выполнение также может завершаться не в первоначальном порядке отправки.

Стратегия обработки результата операций отправки может мгновенно и значительно влиять на производительность вашего приложения. Примеры в этом разделе написаны на языке C# и подходят для объектов Future в Java.

Если приложение создает пакет сообщений, показанных здесь в простом цикле, и должно ожидать завершения каждой операции отправки перед отправкой следующего сообщения, то результаты синхронного и асинхронного API будут схожи, так как они смогут отправить все 10 сообщений только после 10 последовательных выполнений кругового пути для согласования.

Если предположить, что задержка кругового пути TCP между локальным сайтом и служебной шиной составляет 70 мс, и служебная шина должна за 10 мс принять и сохранить каждое сообщение, приведенные ниже цикл длится 8 мс без учета времени передачи полезных данных или потенциального влияния перегрузки маршрута.

```csharp
for (int i = 0; i < 100; i++)
{
  // creating the message omitted for brevity
  await client.SendAsync(…);
}
```

Если приложение запускает 10 последовательных операций асинхронной отправки и ожидает их завершения по отдельности, то время кругового пути этих 10 операций отправки будет совмещаться. 10 сообщений передаются подряд, потенциально даже в общих кадрах TCP, и общее время передачи во многом зависит от времени, необходимого сети для передачи этих сообщений в брокер.

Сделав те же предположения, что и для предыдущего цикла, общее совмещенное время выполнения приведенного ниже цикла может составить меньше секунды.

```csharp
var tasks = new List<Task>();
for (int i = 0; i < 100; i++)
{
  tasks.Add(client.SendAsync(…));
}
await Task.WhenAll(tasks.ToArray());
```

Важно отметить, что все асинхронные модели программирования используют разновидности скрытых рабочих очередей в памяти, в которых хранятся ожидающие операции. При возвращении результата [SendAsync](/dotnet/api/microsoft.azure.servicebus.queueclient.sendasync#Microsoft_Azure_ServiceBus_QueueClient_SendAsync_Microsoft_Azure_ServiceBus_Message_) (C#) или **Send** (Java) задача отправки перемещается в эту рабочую очередь, но операция протокола начнется только после того, как наступит очередь выполнения этой задачи. В ситуациях, когда код отправляет пакеты сообщений и важна надежность, следует соблюдать осторожность, чтобы не оказалось, что слишком много сообщений одновременно находится в состоянии "на лету", так как все отправленные сообщения занимают место в памяти, пока не будут переданы по сети.

Семафоры, как показано в следующем фрагменте кода на C#, — это объекты синхронизации, при необходимости обеспечивающие подобное регулирование на уровне приложения. Такое использование семафора гарантирует, что в состоянии "на лету" одновременно могут находиться не более 10 сообщений. Один из 10 доступных семафоров блокируется перед отправкой, и блокировка снимается только после завершения отправки. При 11-ом выполнении цикла ожидается завершение хотя бы одной из предыдущих операций отправки, после чего блокировка снимается.

```csharp
var semaphore = new SemaphoreSlim(10);

var tasks = new List<Task>();
for (int i = 0; i < 100; i++)
{
  await semaphore.WaitAsync();

  tasks.Add(client.SendAsync(…).ContinueWith((t)=>semaphore.Release()));
}
await Task.WhenAll(tasks.ToArray());
```

Приложения **никогда** не должны инициировать операцию асинхронной передачи по принципу "отправить и забыть", то есть без получения результата операции. В противном случае это может привести к тому, что внутренняя невидимая очередь задач займет всю память, и приложение не сможет обнаруживать ошибки отправки.

```csharp
for (int i = 0; i < 100; i++)
{

  client.SendAsync(message); // DON’T DO THIS
}
```

Используя клиент AMQP низкого уровня, служебная шина также принимает "предварительно согласованные" передачи. Предварительно согласованная передача — это операция, выполняемая по принципу "отправить и забыть", то есть ее результат в любом случае не передается обратно в клиент, и сообщение считается согласованным после отправки. Отсутствие обратной связи для клиента также означает отсутствие действенных данных для диагностики. Поэтому этот режим не соответствует требованиям для получения помощи от службы поддержки Azure.

## <a name="settling-receive-operations"></a>Согласование операций получения

Для операций получения клиенты API служебной шины используют два разных явных режима: *ReceiveAndDelete* и *PeekLock*.

В режиме [ReceiveAndDelete](/dotnet/api/microsoft.servicebus.messaging.receivemode) брокер считает, что все сообщения, отправляемые им в получающий клиент, являются согласованными после отправки. Это означает, что сообщение считается использованным, как только брокер отправит его по сети. Если происходит сбой передачи сообщения, оно утрачивается.

Преимуществом этого режима является то, что получателю не требуется предпринимать дальнейшие действия с сообщением и его работа не замедляется из-за ожидания результата согласования. Если данные, содержащиеся в отдельных сообщениях, имеют низкую ценность и (или) важны только в течение очень короткого времени, этот режим является неплохим выбором.

В режиме [PeekLock](/dotnet/api/microsoft.servicebus.messaging.receivemode) брокеру указывается, что принимающему клиенту необходимо явно согласовывать полученные сообщения. Сообщение становится доступным для обработкой получателем. На этот период на сообщение накладывается монопольная блокировка в службе, чтобы его не могли просмотреть другие конкурирующие получатели. Длительность блокировки изначально определяется на уровне очереди или подписки. Она может быть увеличена клиентом, владеющим блокировкой, с помощью операции [RenewLock](/dotnet/api/microsoft.azure.servicebus.core.messagereceiver.renewlockasync#Microsoft_Azure_ServiceBus_Core_MessageReceiver_RenewLockAsync_System_String_).

Когда сообщение заблокировано, другие клиенты, получающие сообщения из той же очереди или подписки, могут накладывать свои блокировки и получать следующие доступные сообщения, которые не заблокированы. Когда блокировка сообщения снимается явным образом или истекает ее срок действия, сообщение извлекается обратно и помещается в начало или близко к началу последовательности получения для повторной доставки.

Если сообщение несколько раз освобождается получателями или они позволяют истечь сроку его блокировки заданное число раз ([maxDeliveryCount](/dotnet/api/microsoft.servicebus.messaging.queuedescription.maxdeliverycount#Microsoft_ServiceBus_Messaging_QueueDescription_MaxDeliveryCount)), то сообщение автоматически удаляется из очереди или подписки и помещается в связанную очередь недоставленных сообщений.

Принимающий клиент инициирует согласование полученного сообщения с подтверждением передачи при вызове операции [Complete](/dotnet/api/microsoft.servicebus.messaging.queueclient.complete#Microsoft_ServiceBus_Messaging_QueueClient_Complete_System_Guid_) на уровне API. Это указывает брокеру, что сообщение успешно обработано, и оно удаляется из очереди или подписки. Брокер отвечает на намерение согласования получателя, сообщая, возможно ли выполнить это согласование.

Когда получающему клиенту не удается обработать сообщение, но нужно повторить его доставку, клиент может явно запросить мгновенное освобождение и разблокирование этого сообщения, вызвав операцию [Abandon](/dotnet/api/microsoft.servicebus.messaging.queueclient.abandon), или же он может ничего не предпринимать, позволив сроку блокировки истечь.

Если получающему клиенту не удается обработать сообщение и он знает, что повторная доставка сообщения и повторение данной операции не поможет, то он может отклонить это сообщение. Оно будет перемещено в очередь недоставленных сообщений посредством вызова операции [DeadLetter](/dotnet/api/microsoft.servicebus.messaging.queueclient.deadletter), которая также позволяет настроить пользовательское свойство, чтобы добавить код причины, который можно будет получить вместе с сообщением из очереди недоставленных сообщений.

Особым случаем согласования является откладывание, которое рассматривается в отдельной статье.

Операции **Complete**, **DeadLetter** и **RenewLock** могут завершиться ошибкой из-за неполадок сети, если срок наложенной блокировки уже истек. Кроме того, согласованию могут помешать и другие условия на стороне службы. В одном из последний случаев служба отправляет неподтверждение передачи, которое отображается в клиентах API как исключение. Если причиной является нарушение сетевого подключения, то блокировка снимается, так как служебная шина не поддерживает восстановление существующих ссылок AMQP через другое подключение.

Если операция **Complete** завершается ошибкой, а это обычно происходит в самом конце обработки сообщения, а в некоторых случаях — через несколько минут обработки, то принимающее приложение может решить, что следует сделать: сохранить состояние работы и пропустить это сообщение при его повторной доставке или отбросить результат работы и повторить попытку обработки, когда сообщение будет доставлено повторно.

Типичный механизм определения доставки повторяющихся сообщений подразумевает проверку идентификатора сообщения, который может и должен быть задан отправителем в виде уникального значения, возможно, в соответствии с идентификатором из исходного процесса. Планировщик заданий скорее всего присвоит идентификатору сообщения идентификатор задания, которое он пытается назначить рабочему процессу, и рабочий процесс пропустит второй экземпляр назначенного задания, если это задание уже выполнено.

## <a name="next-steps"></a>Дополнительная информация

Дополнительные сведения об обмене сообщениями через служебную шину см. в следующих статьях:

* [Базовая информация о служебной шине](service-bus-fundamentals-hybrid-solutions.md)
* [Очереди, разделы и подписки служебной шины](service-bus-queues-topics-subscriptions.md)
* [Начало работы с очередями служебной шины](service-bus-dotnet-get-started-with-queues.md)
* [Как использовать разделы и подписки служебной шины](service-bus-dotnet-how-to-use-topics-subscriptions.md)
